<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[FE Factory]]></title><description><![CDATA[tip, info and study case of FE enginner]]></description><link>https://willowryu.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sat, 21 Dec 2024 11:10:34 GMT</lastBuildDate><item><title><![CDATA[Passkey.io]]></title><description><![CDATA[대부분의 사이트가 ID, PW…]]></description><link>https://willowryu.github.io/2024-12-11/</link><guid isPermaLink="false">https://willowryu.github.io/2024-12-11/</guid><pubDate>Thu, 12 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;대부분의 사이트가 ID, PW 를 입력하고 들어가게 되는데, 주기적으로 비밀번호를 변경하도록&lt;br&gt;
권장 또는 강제적으로 사용자에게 요구하고 있다.&lt;/p&gt;
&lt;p&gt;이때 비밀번호를 변경할때 대부분의 사람들은 이전 비밀번호와 완전히 다른 비밀번호를 입력하기&lt;br&gt;
보다 대부분 이전 비밀번호에서 1~2개의 숫자 또는 영문을 변경해서 변경하게 된다.&lt;br&gt;
아마 다들 본인만의 비밀번호를 하나씩 간직하고 있으리라.&lt;/p&gt;
&lt;p&gt;이 패스워드 방식의 문제점은 예전부터 지적되었지만 하나의 비밀번호가 노출된다면&lt;br&gt;
내가 사용하는 모든 사이트가 다 털릴 위험이 존재한다.&lt;/p&gt;
&lt;p&gt;이걸 보완해서 이제는 2차 인증을 하기도 하는데 Authenticator 앱을 활용해 2FA 를&lt;br&gt;
활성하거나, 해당 서비스 전용앱으로 이를 수행하기도 한다,&lt;/p&gt;
&lt;p&gt;또는 구글의 패스워드 관리자는 그냥봐도 외우기 힘든 난해한 비밀번호를 자동으로 추천해주고&lt;br&gt;
저장해주기도 한다.&lt;/p&gt;
&lt;p&gt;이 시점에서 예전에 어떤 사이트 인지 기억 나진 않지만 패스키를 생성해서 로그인 했던&lt;br&gt;
기억이 있다.&lt;/p&gt;
&lt;p&gt;그때 맥북에 있는 지문으로 패스키를 만들고 특정 사이트에 등록해두면 해당 서비스에 접근할때&lt;br&gt;
간편하게 지문으로 로그인해서 편리했던 기억이 있다.&lt;br&gt;
추가로 맥북이 없을때는 모바일의 생체인증을 이용해서 로그인 할 수 있었다.&lt;/p&gt;
&lt;p&gt;그래서 이 기회에 패스키를 알아보고 예제를 만들어 보았다.&lt;/p&gt;
&lt;h2&gt;FIDO&lt;/h2&gt;
&lt;p&gt;일단 패스키를 만든 집단(?)을 알아보려면 &lt;code class=&quot;language-text&quot;&gt;FIDO(Fast IDentity Online) Alliance&lt;/code&gt; 를&lt;br&gt;
알아야 한다.&lt;/p&gt;
&lt;p&gt;FIDO 연합은 온라인 인증을 간소화하고 보안을 강화하기 위헤 2012년에 설립된&lt;br&gt;
비영리 단체이다.&lt;/p&gt;
&lt;p&gt;이들은 인증을 위한 &lt;code class=&quot;language-text&quot;&gt;UAF&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;U2F&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;FIDO2&lt;/code&gt; 표준을 만들었는데 현재 많은 곳에서 이 표준을 이용하여&lt;br&gt;
서비스 되고 있다.&lt;/p&gt;
&lt;p&gt;간단히 &lt;code class=&quot;language-text&quot;&gt;UAF (Universal Authentication Framework)&lt;/code&gt; 는 비밀번호가 없는 인증을&lt;br&gt;
목표로 만들어진 표준이며 현재 우리가 많이 사용하고 있는 생체인식 또는 PIN 번호를 사용해&lt;br&gt;
인증을 수행하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;U2F (Universal 2nd Factor)&lt;/code&gt; 는 기존 비밀번호 인증에 2단계 인증을 추가하기&lt;br&gt;
위해 설계된 표준으로 주로 물리 보안키를 사용하는 인증에 사용된다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;code class=&quot;language-text&quot;&gt;FIDO2&lt;/code&gt; 가 지금 설명하려는 패스키가 따르는 표준이며, 비밀번호 없이 인증을 가능케&lt;br&gt;
하는 표준이다.&lt;/p&gt;
&lt;p&gt;현재 FIDO 연합에는 Apple, MS, Google, 샘숭 등 많은 글로벅 빅테크 기업이 참가해&lt;br&gt;
안전하고 편리하며, 크로스 인증이 가능하도록 노력 중이다.&lt;br&gt;
우리는 그걸 일단 쓰면 된다.&lt;/p&gt;
&lt;h2&gt;패스키?&lt;/h2&gt;
&lt;p&gt;생체인증만큼 안전한 인증이 있을까?&lt;br&gt;
패스키에서는 우리가 주위에서 많이 접하는 Touch ID, Face ID, Windows Hello 등&lt;br&gt;
생체인식을 활용해 패스워드 없는 안전한 인증을 보장한다.&lt;/p&gt;
&lt;p&gt;생체인식의 장점은 말안해도 다들 알고 있을거고, 패스키를 사용하게 되면 패스워드의 도난 또는&lt;br&gt;
비밀번호를 주기적으로 바꾸면서 잊어버리는 불상사를 방지 할수 있다.&lt;/p&gt;
&lt;p&gt;위 FIDO 연합에 속한 기업들을 봐도 알겠지만 패스키는 특정 OS, 기기에 속하지 않고&lt;br&gt;
서로 크로스 인증이 가능하기 때문에 windows 로 등록한 패스키를 맥os 나 모바일에서&lt;br&gt;
같이 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;뭐 그렇다고 장점만 존재하는 건 아니다.&lt;br&gt;
일단 어쨌든 생체 인식이 가능한 기기가 있어야 하고, 패스워드를 도난,분실의 위험은 없지만&lt;br&gt;
만약 등록한 모든 디바이스를 잃어버린다면 계정 복구가 조금 복잡해 질 수 있다.&lt;br&gt;
이 부분은 백업 인증을 추가 함으로써 충분히 해결 될 듯 하다.&lt;/p&gt;
&lt;p&gt;가장 큰 문제는 다른 기술들도 그렇지만 초기 단계라 이를 지원하는 서비스가 많이 없는게&lt;br&gt;
단점일수도? 그 말은 그동안 패스워드만 사용하던 사용자들이 혼란을 겪을 수 있다.&lt;/p&gt;
&lt;p&gt;빅테크 기업들은 이미 도입하고 권장을 하고 있긴한데..&lt;br&gt;
어쨌든 백업을 위해서도 마음 속 패스워드 하나는 다들 가지고 있어야 한다.&lt;/p&gt;
&lt;h2&gt;패스키 생성&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;WebAuthn&lt;/code&gt; 이라는 공개키 기반 인증으로 이를 수행하게 된다.&lt;br&gt;
간단하게 설명하면 User, Client, Server 의 관점으로 보자.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기준&lt;/th&gt;
&lt;th&gt;행동&lt;/th&gt;
&lt;th&gt;수신자&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;패스키 생성 요청&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;해당 서비스의 도메인, 고유 계정정보 (이메일, 사용자 ID) 전달&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;수신 정보로 Challenge, RPID, 공개키 옵션 생성 하여 전달&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;Authenticator 에게 수신받은 정보를 전달&lt;/td&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;생체인식 으로 사용자 본인 인증&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;공개키,개인키 쌍 생성. 개인키 기기저장 Challenge 개인키로 서명&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;공개키, 서명한 Challenge, 그외 사용자 정보(디바이스 정보 등) 전달&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;서명을 공개키로 검증. 검증 성공후 서버에 공개키, 사용자 ID, 그외 정보 저장&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;대략 순서대로 표로 만들어봤다.&lt;br&gt;
내 마크다운이 형편없는 걸 이해했음 한다.&lt;/p&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;Challenge&lt;/code&gt; 는 Client 에서 받은 정보로 Webauthn 의 API 로 생성한&lt;br&gt;
ArrayBuffer 값이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Authenticator&lt;/code&gt; 는 디바이스의 인증을 담당하는 보안장치 이다.&lt;br&gt;
스마트폰의 생체인증 모듈이나 맥북의 TouchId 같은 플랫폼 인증자 또는&lt;br&gt;
USB, NFC, 블루투스 장치를 뜻한다.&lt;/p&gt;
&lt;p&gt;이제 패스키가 생성 되었다면 사용자는 패스키를 통해 간단하게 인증절차를 수행할 수 있다.&lt;/p&gt;
&lt;h2&gt;패스키 인증&lt;/h2&gt;
&lt;p&gt;그럼 만들어진 패스키로 인증하는 절차는 어떻게 될까?&lt;br&gt;
대략적으로 생성과 비슷하다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;기준&lt;/th&gt;
&lt;th&gt;행동&lt;/th&gt;
&lt;th&gt;수신자&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;패스키를 이용해 인증 요청.&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;해당 서비스의 RPID 와 인증 요청 (사용자 계정정보 등) 전달&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;수신 정보로 Challenge, RPID, 사용자의 인증키 를 전달&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;User 에게 생체 인증 요청&lt;/td&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User&lt;/td&gt;
&lt;td&gt;생체 인증을 이용하여 인증&lt;/td&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt;인증 후 개인키로 Challenge 를 서명. RPID, 사용자 인증키 전달.&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;사용자 인증키로 사용자 계정에 등록된 공개키 조회.&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;공개키가 있을경우 사용자 디바이스에서 왔음을 검증.&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;서명한 Challenge 를 서버에서 보낸 값과 같은지 확인.&lt;/td&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;Challenge 가 검증되면 인증 완료&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;생성부분과 비슷하다.&lt;br&gt;
크게 다른점은 사용자 고유 정보로 등록된 사용자 인증키를 서버에서 전달해주는 부분이다.&lt;/p&gt;
&lt;h2&gt;실제 코드 예제&lt;/h2&gt;
&lt;p&gt;클라이언트 부분은 Remix 로 만들어봤고&lt;br&gt;
서버는 Rust 와 Webauthn 을 위한 node server 도 함께 사용했다.&lt;br&gt;
전체 코드 repo는 맨 아래에 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2b4525293fa72e4e42422890b17242d1/1.gif&quot; alt=&quot;index&quot;&gt;&lt;/p&gt;
&lt;p&gt;로그인 화면이다.&lt;br&gt;
조금 실험적인 UI 를 적용하고 있어서 특이해 보일 수 있다.&lt;/p&gt;
&lt;p&gt;처음 들어왔을때&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; const checkWebAuthAvailable: () =&amp;gt; Promise&amp;lt;{
    username: string;
  }&amp;gt; = async () =&amp;gt; {
    if (
      window.PublicKeyCredential &amp;amp;&amp;amp;
      !!PublicKeyCredential.isConditionalMediationAvailable
    ) {
      try {
        const cma = await PublicKeyCredential.isConditionalMediationAvailable();
        if (cma) {
          const user = await authenticate();
          const userName = user?.data?.username as string;
          return { username: userName ?? &amp;quot;&amp;quot; };
        }
      } catch {
        alert(&amp;quot;WebAuthn is not available&amp;quot;);
      }
    }

    return {
      username: &amp;quot;&amp;quot;,
    };
  };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 코드가 먼저 실행된다.&lt;br&gt;
여기서 &lt;code class=&quot;language-text&quot;&gt;PublicKeyCredential&lt;/code&gt; 은 공개키/개인키 쌍을 이용하는 인터페이스 중 하나로&lt;br&gt;
해당 인터페이스가 존재하는지 확인하고, &lt;code class=&quot;language-text&quot;&gt;isConditionalMediationAvailable&lt;/code&gt; 의 지원을 확인한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;isConditionalMediationAvailable&lt;/code&gt; 사용자 입력없이 등록된 자격증명 데이터를 가져 올 수 있는 방식이다.&lt;/p&gt;
&lt;p&gt;브라우저가 &lt;code class=&quot;language-text&quot;&gt;isConditionalMediationAvailable&lt;/code&gt; 를 지원하고 이를 적용하기 위해서는 미리&lt;br&gt;
input 의 autoComplete 에 &lt;code class=&quot;language-text&quot;&gt;webauthn&lt;/code&gt; 을 추가해두면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;CustomInput
  autoFocus
  autoComplete=&amp;quot;username webauthn&amp;quot;
  name=&amp;quot;username&amp;quot;
  value={username}
  onChange={e =&amp;gt; setUsername(e.target.value)}
  placeholder=&amp;quot;&amp;quot;
  title=&amp;quot;Your Name&amp;quot;
  subText=&amp;quot;Please enter any name.&amp;quot;
/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 두면 실제로 사용자가 인증작업울 하기 까지 background 에서 대기하고 있게 되고&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9fd6cbdf19e7e3594fd24c9131053e0b/39c09/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.64864864864865%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB9ElEQVQoz12SWXMSQRSFB3yLVbiwzc6sDDDMsAzFsCQgBCWEKJaoD1ErUeISLf//4/H2DVrEh1P3dnfN1+fcHsntvIGfvEM4vITove72QG9hxxsMzm4RHl/BDC9w1HwPqXWNzIGyQm3q258hDde/kS6/oTf7gMHqJ/rL76Qf1N/yWtTh+S+GW80LPAy3yMSf8CD+SKCrO+AexkCLHMiah3xBgWHV4XgRSzOrUA2fq0Lnqu5C0z0oJFkXezZy3gRSZ3cfaNZX8KoxknQK32/g5astVucb2HbAlxRLGsqywSqVDciKSapAUzQ8cdL7wM4XSJVwDb/WRjKYol5vYfpsibCZoNXuYzSeYXw8x2A4xXy+orMXSAcTTKjWqg3krD5BbvawPTCaXUNWbeTzMnTDhWF65Mbk3q82UaNLbKfG1fNDOK4YSwOmbuGxMyCHN//cMTBe7GBUAgaJj4SryfQ5giDG07yCQlGj2DrFV1ncF3UoZYrsDhmY3bvLCmBtfIkwTjFbvubIp4s1Q6O4x47+umy1+rxXb7QRUe9YHh7ZKTLdrwxidXeQ7GgDzaDXUy1UgwhJbwSXIokPBfj45JT3TiYLnmWSjGiO9IBugNwhkGAMPKqu6LdxoBKwLFc4knhFMUfRi5cVVUQXEutCyYAi30X+H/gHzzIxNqTtlMsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;login&quot;
        title=&quot;login&quot;
        src=&quot;/static/9fd6cbdf19e7e3594fd24c9131053e0b/fcda8/2.png&quot;
        srcset=&quot;/static/9fd6cbdf19e7e3594fd24c9131053e0b/12f09/2.png 148w,
/static/9fd6cbdf19e7e3594fd24c9131053e0b/e4a3f/2.png 295w,
/static/9fd6cbdf19e7e3594fd24c9131053e0b/fcda8/2.png 590w,
/static/9fd6cbdf19e7e3594fd24c9131053e0b/39c09/2.png 624w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이런식으로 기존에 등록한 passkey 를 이용해 인증이 가능하게 된다.&lt;br&gt;
일단 먼저 패스키의 등록전 간단하게 사용자를 등록하고&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  form?.addEventListener(&amp;quot;submit&amp;quot;, async (e) =&amp;gt; {
    e.preventDefault();
    e.stopImmediatePropagation();

    if (e.target) {
      const formData = new FormData(e.target as HTMLFormElement);
      const cred: FormDataObj = {};

      formData.forEach((v, k) =&amp;gt; (cred[k] = v));
      _fetch((e.target as HTMLFormElement).action, {
        payload: cred,
      })
        .then((res) =&amp;gt; {
          if (res?.data?.id) {
            location.href = &amp;quot;http://localhost:5173/reauth&amp;quot;;
            return;
          }
          alert(res?.message);
        })
        .catch(console.log);
    }
  });&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;서버에서는 해당 username 을 저장하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;pub async fn handle_username(
    Extension(db): Extension&amp;lt;DatabaseConnection&amp;gt;,
    session: Session,
    Json(payload): Json&amp;lt;CreateUser&amp;gt;,
) -&amp;gt; Result&amp;lt;Json&amp;lt;ResponseUser&amp;gt;, Response&amp;gt; {
    let username_regex = Regex::new(r&amp;quot;^[a-zA-Z0-9@\.\-_]+$&amp;quot;).unwrap();

    if !username_regex.is_match(&amp;amp;payload.username) {
        return Err(
            AppError::new(&amp;quot;Invalid username&amp;quot;.to_owned(), StatusCode::BAD_REQUEST).into_response(),
        );
    }

    let user = match find_user_by_username(&amp;amp;db, &amp;amp;payload.username).await {
        Ok(user) =&amp;gt; user,
        Err(_) =&amp;gt; {
            let id = generate_base64_id();
            let new_user = users::ActiveModel {
                username: Set(payload.username.to_owned()),
                displayname: Set(payload.username.to_owned()),
                id: Set(id),
            };

            new_user.insert(&amp;amp;db).await.map_err(|_| {
                AppError::new(
                    &amp;quot;Failed to save user&amp;quot;.to_owned(),
                    StatusCode::INTERNAL_SERVER_ERROR,
                )
                .into_response()
            })?
        }
    };

    store_username_in_session(&amp;amp;session, payload.username.to_owned()).await?;

    Ok(Json(ResponseUser { data: user }))
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 password 를 입력하기 위한 reauth 페이지로 가게 되는데&lt;br&gt;
현재는 password 를 따로 저장하지 않고 그냥 아무거나 넣어도 진행이 된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/918e2985238fda5fbe19b7652867cf07/8b70b/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 95.27027027027027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAADG0lEQVQ4y22U208TQRSHd1eDvih3CuUmtqXtttuW7QXKLVoVKpdy6b2U1lJAeTExBjAxitGIDz6owfjoO4n/489zZralKTx8mc1M+s3vzJypoji2oDi2oTiZNBQXk4EymZW4c0QeiocpQPEWJXoJKuPbgcL4y8QulJtlFu4sVE+OyEP1MgWJXrxZZrCwXebKotO9ApvnGfrdS+ibfCpxS/o9S7B5l9DlXb0mUwMVFl4vs8+TxJj3Ccb8y3CYKTjDG3g4tS6+x2mO1wa8SSk0rmRS2H5mLKTdR/UlTJibmCu8x0LxAxK1czyqfIEzlsUopR/QV2U6g0SGlKnBKgvbLyCHfn0NY3oS0cdlzC3XMPO0iliigvlkneZ2KeVz2HzrQthIxjI1+IKE7bdJDOhUprlNpWZgzJUQXCgTOwjMl+CKZMWazZeySq02ZWqoIbSSydYgoW8Dk5EcnVkG8eUDzCUPsbh6hFn6dtE8Swf9m1TqblOmhVhYI2GrjFqCR5uf0k1lSZjDRDCD8cA2HhATwbSY47UhI22VeiVTp/YsYWvT0jhoZOAIZUmSobILcM+UBc5IUWzAa/ZATgg1FlkyTQibMtmwPNoDeXjCRThDefgX61irfcJK9QzBxKGYc5tFjIQKslwhqwmZZtZZKGWcjrufn1S3P4dhSjBk5GAP5mGnHzcYos14rjdQEJfQSMYyzdwnYYus+ZyEmNL6Shb8IqxXwY0cIDhdm0wLC2GrjPqKe4uekmzWarMtNOvw+cy0hqhNpoUPSGg9dJFEp/PUKbGP8FNCf+masPUCrmQHksghlIZMM/bQEX6DjojkbuQt7pivqbyKhJ8VN644NylVTSJcJ/aFTIu8JKH4Cyqie/oM4+l/GE1fYoTwpi7hXv6LrugJumPE9Am6Yu2c0vw73I8d4xbJtCgJxWHT2Q3FPyK+/Rvh9R+Ipn7BXP+J2NYFwili4wLx9B+4Et9hn/mK4dlzDMclI/FvGJz5jNvRIxK+YmFZPKF7VF4v7dpLu/UQ/N03fSq+e3ieEvLYHT2WiS16KGUnJ2Rh7Aj/AQd2Y0xFGpjoAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;password&quot;
        title=&quot;password&quot;
        src=&quot;/static/918e2985238fda5fbe19b7652867cf07/fcda8/3.png&quot;
        srcset=&quot;/static/918e2985238fda5fbe19b7652867cf07/12f09/3.png 148w,
/static/918e2985238fda5fbe19b7652867cf07/e4a3f/3.png 295w,
/static/918e2985238fda5fbe19b7652867cf07/fcda8/3.png 590w,
/static/918e2985238fda5fbe19b7652867cf07/efc66/3.png 885w,
/static/918e2985238fda5fbe19b7652867cf07/c83ae/3.png 1180w,
/static/918e2985238fda5fbe19b7652867cf07/8b70b/3.png 1266w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;어쨌든 password 를 넣고 로그인 하게되면 이제 passkey 를 만들수 있는&lt;br&gt;
사용자 정보 창이 나온다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/e374684dd70428d4710a4181f9945bdc/afa26/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 103.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEMklEQVQ4y12US0xcVRyH770MfUAVC5WaFpRheAzMMMwwbyqtKdhCoTO8y3OezIwMEGPRBQLWaAtjBSytLkxMbJMmToxLF+6NiQvXNpgu0JrGpVvs4ufvnDOAdZIv59y59373/zjnaJplAJplEFptCFr1ZWhV3dBq+F/9FI6cu4Fi3yLnvN84qmgah948Cd0egdE6Q5LQbVPQbJPQ7By1Oj5s6UdR6yxOdt+FI/M9fMs7iN7/B5E8UB79GXrDIAxHEkZLgmNCzTnq9mmJFO2j1Y8woh6UhvIIPQCmSOCjv2Bb+Amnhx9C8y5BqxtjZJMqkuZxzscYJSO1TRxGJmiZFsJhphuGqW0BJZ1bvDHLFPmSOcwP9aGuK4vg2CrKvHGZst48QdGk5FA2rWQtESEcgoyyjnWr7WN6QzAYgSFe5GjuzMIRWsQJN4XWsedlUjh5INMdkUKEDYIR6I0jsp5aTa+K0MJUbYzYMcfoRlSKImWOuhREoTuTanSoa02IJI3XWJsYSjpuoHLwAZrnfkR46ymi3wBn5x4xuhE2Ig7DmVK40jDaMgVhQd4qhEJkCeH4lfvo/RJIsbOhr4DOO8/Q8eFjVMd+gHFhk1Gyu+LllqiKRDZBNWJfprfG9oVhHLuQQ232F7w88DWKuf60lrTsbmV7AtbueZS4YzJd/aCjhaj+IzOcUjgqi1/UfE0t4Pp+GNZhmOz8zz4Bx8ASLibXUXHuLSkyOaMoksRgcsUlBmW6U8DG6VYRITtdzSa8RmHNkMIslhNrW8UmnQmp6zrx7KhCzAX1bBwjNCjTKZcL29y1gKuzt9GdWkdPOoeeTA5vJm+iM/4xLs2s4VJqDV3JW+hM3MTlzCe4kt1Az+wG+uY3cTF1G0d9GUqZsitBYVUIK9vf4v+/3d0/sPPbY+z+/gRP/nyKXx/tSPb2nj333N97gLl/nfWdgMmdEstmFKc7sng9tong9AaCEY7RTQQ4Bjh6pj4lG/CJe7HP0B6/IwmKMbENb+wejgUWoLGGRtsMa0izkMoTxixOHQFraGHN6kfxoj+J8vY0mxGR11oD69bAujUKuMit47IZQiaFYikY3EImLs4iCTvIegiKWeRT57OofGMeJ/xpdpZdbUsq3DMKT+pAZoiU5b6UJwg72sQIxPKxEfu42qP2Ao5CJ2U3ExKDYolbyaRQyIp4vh0PrJBl1mMFpf4VvODjscWtpoltJXZAa6wgixdk+8JDmeFJC+EYTvpXUTv8HWqG83h1MI+m/jycVx/iVOADVAbfJ8vcMcuo8C+hnB8q9x9S4V/GUe8cdJG6h8tHHEGvBFfhD2+jrXdT4urbgm/gLjzhe/D2fy7xD36BmvM5nAncwtl2EhSsoao9hxLv20ro5W4S26nUNY8y93XyDso81wvzRTU/YFHyknefdxW+93DEm4XuzUjhv+PZ6VTUNcD1AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;home&quot;
        title=&quot;home&quot;
        src=&quot;/static/e374684dd70428d4710a4181f9945bdc/fcda8/4.png&quot;
        srcset=&quot;/static/e374684dd70428d4710a4181f9945bdc/12f09/4.png 148w,
/static/e374684dd70428d4710a4181f9945bdc/e4a3f/4.png 295w,
/static/e374684dd70428d4710a4181f9945bdc/fcda8/4.png 590w,
/static/e374684dd70428d4710a4181f9945bdc/efc66/4.png 885w,
/static/e374684dd70428d4710a4181f9945bdc/c83ae/4.png 1180w,
/static/e374684dd70428d4710a4181f9945bdc/afa26/4.png 1258w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 CreatePasskey 를 이용해 패스키 생성을 하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const useCreateCredential = () =&amp;gt; {
  const createCred = async () =&amp;gt; {
    const response = await _fetch(auth_api.registerRequest);
    const { data: options } = response;

    options.user.id = base64url.decode(options.user.id);
    options.challenge = base64url.decode(options.challenge);

    if (options.excludeCredentials) {
      for (let cred of options.excludeCredentials) {
        cred.id = base64url.decode(cred.id);
      }
    }

    options.authenticatorSelection = {
      authenticatorAttachment: &amp;quot;platform&amp;quot;,
      requireResidentKey: true,
    };

    const cred = (await navigator.credentials.create({
      publicKey: options,
    })) as any;

    const credential: any = {};
    credential.id = cred?.id;
    credential.rawId = cred?.id;
    credential.type = cred?.type;

    if (cred?.authenticatorAttachment) {
      credential.authenticatorAttachment = cred.authenticatorAttachment;
    }

    const clientDataJSON = base64url.encode(cred.response.clientDataJSON);
    const attestationObject = base64url.encode(cred.response.attestationObject);

    const transports = cred.response.getTransports
      ? cred.response.getTransports()
      : [];

    credential.response = {
      clientDataJSON,
      attestationObject,
      transports,
    };

    return await _fetch(auth_api.registerResponse, {
      payload: credential,
    });
  };

  return [createCred] as const;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;첫번째&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;await _fetch(auth_api.registerRequest)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 이미 server 에서는 login 한 사용자의 정보를 session 에 저장하고 있기 때문에&lt;br&gt;
별도의 payload 없이 challenge 를 생성하기 위한 요청을 한다.&lt;br&gt;
생성된 challenge 는 서버의 session 에 저장되고, 클라이언트에게 전송된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;pub async fn handle_register_request(
    Extension(db): Extension&amp;lt;sea_orm::DatabaseConnection&amp;gt;,
    session: Session,
    request: Request,
) -&amp;gt; Result&amp;lt;Json&amp;lt;RespnseValue&amp;gt;, AppError&amp;gt; {
    if let Some(user) = request.extensions().get::&amp;lt;users::Model&amp;gt;() {
        let mut exclude_credentials: Vec&amp;lt;ExcludeCredentials&amp;gt; = vec![];
        if let Ok(credentials) = get_keys_by_user_id(&amp;amp;db, &amp;amp;user.id).await {
            credentials.iter().for_each(|cred| {
                let id_buffer = base64_url_decode(&amp;amp;cred.id).unwrap_or_else(|_| vec![]);
                exclude_credentials.push(ExcludeCredentials {
                    id: String::from_utf8(id_buffer).unwrap_or_else(|_| &amp;quot;&amp;quot;.to_string()),
                    r#type: &amp;quot;public-key&amp;quot;.to_string(),
                    transport: cred.transports.clone(),
                });
            });
        }

        let user_id = user.id.as_bytes().to_vec();

        let request_props = &amp;amp;json!({
            &amp;quot;rpName&amp;quot;: &amp;quot;SimpleWebAuthn Example&amp;quot;,
            &amp;quot;rpID&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;userID&amp;quot;: &amp;amp;user_id,
            &amp;quot;userName&amp;quot;: &amp;amp;user.username,
            &amp;quot;userDisplayName&amp;quot;: &amp;amp;user.displayname,
            &amp;quot;attestationType&amp;quot;: &amp;quot;none&amp;quot;,
            &amp;quot;excludeCredentials&amp;quot;: exclude_credentials,
            &amp;quot;authenticatorSelection&amp;quot;: {
                &amp;quot;authenticatorAttachment&amp;quot;: &amp;quot;platform&amp;quot;,
                &amp;quot;requireResidentKey&amp;quot;: true
            },
        });

        let resp = reqwest::Client::new()
            .post(&amp;quot;http://localhost:3001/generate-options&amp;quot;)
            .json(&amp;amp;request_props)
            .send()
            .await?;

        let json_resp = resp.json::&amp;lt;Value&amp;gt;().await?;

        session
            .insert(
                const_value::CHALLENGE_KEY,
                &amp;amp;json_resp.get(const_value::CHALLENGE_KEY),
            )
            .await?;

        Ok(Json(RespnseValue { data: json_resp }))
    } else {
        Err(user_not_found_error())
    }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정상적으로 데이터를 전송받으면 절차대로 Authenticator 에서 인증을 진행한다.&lt;br&gt;
난 현재 맥북에서 진행하기 때문에 TouchId 인증이 나오게 된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/76ff7c08d83bbe4fd657848b0110eeee/9cab2/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.78378378378378%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABOklEQVQoz52T227CMAyG8xKj51NaeuDQUmAtnSbBNMEVF3v/l/kXGwVlbFC0i1+OVfuL7TrCdiK8THy4XoIozhGEGRw3Zv8/Etl0jv3hBJlWOJ7OWNZb0CX00fF+g8cuEwRq1zsGDm8HrlIDTYhtgB5BhW5ZWx1MVivyJGJfXv2HFZqOp5LMCsgSaBnmLOmnzwFvg65ANUOCNGHBYuBI2+Le0Mlaagw0isRNIJ0Eth3CUjJjRoE6kNqnH5VmM+RljaJqUCoV6uwH91sX5vBNEbBuXtGsOqzaHuvNwNvQtrsfm3CbJzw1lyCcwlcL7QcZW/JdBZxYwZ+6bZnzVa6nKhdRUqLZfmA4fKF7P6PtPrHujxfoyKtw3MtmVIse9WbPr0wQOZYVknShNOdzLGd829iK6NFEcck5NNtvp89HkZxppZkAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;auth&quot;
        title=&quot;auth&quot;
        src=&quot;/static/76ff7c08d83bbe4fd657848b0110eeee/fcda8/5.png&quot;
        srcset=&quot;/static/76ff7c08d83bbe4fd657848b0110eeee/12f09/5.png 148w,
/static/76ff7c08d83bbe4fd657848b0110eeee/e4a3f/5.png 295w,
/static/76ff7c08d83bbe4fd657848b0110eeee/fcda8/5.png 590w,
/static/76ff7c08d83bbe4fd657848b0110eeee/9cab2/5.png 864w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const cred = (await navigator.credentials.create({
      publicKey: options,
    })) as any;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이부분이 실제 생체 인증으로 키쌍을 만드는 곳이다.&lt;/p&gt;
&lt;p&gt;이제 위 순서대로 인증을 마치게 되면 공개키/개인키가 생성되고,&lt;br&gt;
전달받은 Challenge 를 서명하고 다시 서버로 보낸다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;return await _fetch(auth_api.registerResponse, {
  payload: credential,
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;서버에서는 이제 전달받은 인증 정보로 검증하게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; let expected_challenge = session
        .get::&amp;lt;String&amp;gt;(const_value::CHALLENGE_KEY)
        .await
        .unwrap();

  // example host
  let expected_origin = &amp;quot;http://localhost:5173&amp;quot;;
  let expected_rp_id = &amp;quot;localhost&amp;quot;;

  let request_post = &amp;amp;json!({
    &amp;quot;response&amp;quot;: payload,
    &amp;quot;expectedChallenge&amp;quot;: &amp;amp;expected_challenge,
    &amp;quot;expectedOrigin&amp;quot;: &amp;amp;expected_origin,
    &amp;quot;expectedRPID&amp;quot;: &amp;amp;expected_rp_id,
    &amp;quot;requireUserVerification&amp;quot;: false,
  });

  let resp = reqwest::Client::new()
      .post(&amp;quot;http://localhost:3001/verify-credentials&amp;quot;)
      .json(&amp;amp;request_post)
      .send()
      .await?;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제로 검증하는건 Webauthn 을 실행하는 node_server 이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  if !json_resp.verified {
      return Err(AppError::new(
          &amp;quot;Verification failed&amp;quot;.to_string(),
          StatusCode::UNAUTHORIZED,
      ));
  }

  let base64_credntial_public_key =
      base64_url_encode(&amp;amp;json_resp.registration_info.credential_public_key);
  let user_agent = user_agent_handler(&amp;amp;headers).await;
  let transports = payload
      .get(&amp;quot;response&amp;quot;)
      .and_then(|response| response.get(&amp;quot;transports&amp;quot;))
      .and_then(|transports| transports.as_array())
      .ok_or(AppError::new(
          &amp;quot;transports error&amp;quot;.to_string(),
          StatusCode::BAD_REQUEST,
      ))?;

  let transports_vec = transports
      .iter()
      .filter_map(|t| t.as_str().map(|s| s.to_string()))
      .collect();

  let new_credential = credentials::ActiveModel {
      id: Set(json_resp.registration_info.credential_id),
      publickey: Set(base64_credntial_public_key),
      user_id: Set(Some(user.id.clone())),
      transports: Set(transports_vec),
      name: Set(user_agent),
  };

  new_credential.insert(&amp;amp;db).await.map_err(|_| {
      AppError::new(
          &amp;quot;Failed to save credential&amp;quot;.to_string(),
          StatusCode::INTERNAL_SERVER_ERROR,
      )
  })?;

  session.remove::&amp;lt;String&amp;gt;(const_value::CHALLENGE_KEY).await?;
  session.insert(const_value::SIGNED_IN_KEY, &amp;quot;yes&amp;quot;).await?;

  Ok(Json(ResponseUser { data: user }))&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;검증에 성공하게 되면 DB 에 인증키와 공개키 정보 그외 사용자 정보를 저장하고&lt;br&gt;
session 에서 Challenge 를 삭제 하게 된다.&lt;/p&gt;
&lt;p&gt;하면서 귀찮았던(?)점은 고놈의 Serialize, Deserialize 절차와&lt;br&gt;
base64 encode, decode 다.&lt;br&gt;
rust 가 엄격한 타입을 사용하다보니 이거 맞추는데 애를 먹었다.&lt;/p&gt;
&lt;p&gt;node_server 에서 검증을 받고 나온 Json 데이터를 Deserialize 해야 하는데&lt;br&gt;
Json 타입으로 어거지로 하는 방법도 있지만, 사실 그러면 타입안정성이&lt;br&gt;
안좋고 결정적으로 내가 보기 안좋다.🤡&lt;br&gt;
때문에 결국 응답 결과를 Rust 에서 사용가능하도록 만들었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;#[derive(Deserialize, Debug)]
#[serde(rename_all = &amp;quot;camelCase&amp;quot;)]
struct RegistrationInfo {
    credential_id: String,

    #[serde(deserialize_with = &amp;quot;deserialize_public_key&amp;quot;)]
    credential_public_key: Vec&amp;lt;u8&amp;gt;,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = &amp;quot;camelCase&amp;quot;)]
struct RequestData {
    registration_info: RegistrationInfo,
    verified: bool,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 데이터 모델을 쓰는데 저넘의 public_key 가 아마 ArrayBuffer 타입인데&lt;br&gt;
타입 매칭이 안되서 Rust 에서 다시 변환을 해줬다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;rust&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;fn deserialize_public_key&amp;lt;&amp;#39;de, D&amp;gt;(deserializer: D) -&amp;gt; Result&amp;lt;Vec&amp;lt;u8&amp;gt;, D::Error&amp;gt;
where
    D: Deserializer&amp;lt;&amp;#39;de&amp;gt;,
{
    // `HashMap&amp;lt;String, u8&amp;gt;`로 데이터를 받음
    let map: HashMap&amp;lt;String, u8&amp;gt; = HashMap::deserialize(deserializer)?;

    // 키를 숫자로 변환하여 정렬하고, 해당 값을 Vec&amp;lt;u8&amp;gt;에 추가
    let mut values: Vec&amp;lt;(usize, u8)&amp;gt; = map
        .into_iter()
        .filter_map(|(k, v)| k.parse::&amp;lt;usize&amp;gt;().ok().map(|i| (i, v)))
        .collect();

    values.sort_by_key(|&amp;amp;(k, _)| k);

    Ok(values.into_iter().map(|(_, v)| v).collect())
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;어쩄든 검증에 성공하면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/edbc79d58f142bde8227dbf5094d4e82/fe9e8/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 135.8108108108108%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEyUlEQVRIx42VyVNcVRjF73uAQmghHZKIGYAGGrqh55FGEpFmCnRDM4UhDTTzkAQSorGsFAmVgNkQNSalRqpCyipdWWbpSv8I/Qd06cqFKy2rjufe95qAktLFqXv7Db/+hvPdJ0RlCqKqD8KWhCjrhDgj1QVhT0MLrKEw/iH0+gxENZ+pGYKovaik1fG+axK6ewq6b477cV4bhVCwyl6+NA1L831UT3yD4M0fkXz4G649B978FMht2oReOwTdlSFgGrpn1gBRmmuCoDFD9ZcIrB5kZO3I73iKtqfAVUK6Hv+F2MYvcCx8j9e6diBci4xwGKJuAsLJKJwjhhzDas3CTOAA0+1BbuAqinq/Rk7jXYh6AiqZWnkSeY4+VMaXUdFyGXkuwmqHDSjT2x+ZgrnSEtgPBZWpV7B2lQlo9j7o8t9rR3A0Mot45h6axu6gwDehgNoB2BgDMGEGcMAA1rDQjlGCmALrJap6FVyUsVlne7jnM7wnIzNk7FV0bIgB5CrsfNAuAXypvJuAXtXh3Mh7KOp8DN/Sd/Df/hX5Ldu8niIgraR7Zyg2xz8PPbAIzUMnuCVQWqE6hdzQOyhLP8f59Z+QePg7hnaBka+AlW+Bc9t/4kj3LrucRo5/ETm0ie5hh6Wy0UmYmyVRRbZ1scs7aPkCGN75A5H1n1E+8wMsssPhW0x1mrWTtTK9puq2r3YmTPNMmBEy7RzPDPLoN+Fe5m/Wp4qGtyVgDaWRWPgAbTNbsAQzqsO6W5qakithSh4JnDSBMkpZR9pHNUgWn9GIunHkeqdw4vwVlDRdZpoEckKEM63uCU6KcPMaUxe8p3klUI3SEI65EjgdHVQ66UviqKMd1roOtVrscVhqWtW+xJ/EyYYBlIRSeMObgM11AaeoPA87zj8X0u1azQCqAnFEeoYR6R1FfawdZbUhVDgje7LVRVFeE4I9Fod3aAzO1EWEYy3od0fxFpXvHoDmmzaACiq9J01u76cXuZeyDx44EJTkNUqT+3o2yH1JSWe6ms+M0JhNaVZzwJ1jKOaEVHVeR1nrKkqbr+As16oLN2DrXMMroVkILw8KAnJ8U2rVTIm9QXeOGiMl7UBwQSCDE02LsDbOoyg6i+LYPJuzjOPnlgjJqI7qCprZg2l+mbI6PQ4Z9DojUrUqn40boyUnhTDNK0EHYXoWeNipIb0lX5YROZLvopayROdojwkVlX4ITA/MQBx6BO25f1wVW6ao0vQakb0MpgdmTeA/Ya7xF7MpJUfK898wPSiBL4ksO5tGvf4fTA/OmUBXdib3QbLyZruZtce0CZv5F0wPEWhExm46aVSn/G5Q9bSRPO49aSM636TRUf/UCwUIJlBpDzhPIH33qn8F1rYnsLZ/DmvHExxr/Qy2th36b12deTlePuybVZ/LvMA88oIL1KKh0BK1zPN00QQywuPR23D0fQl7/zNUp56hpmcXviT38Y9Rdv4ebG9voaJZahOlDRt4veEOtbGn0oa7KI7ehBZWwHGeHrd4KHyEYGIbge5t+LsfwJd4gIaBRwj2foJQylCk7xFON27iVExqy9QmzsTuwxp93wDKRhzxL6PQt4JCv9SqWi3mWhgwZAmsKhWFrlHXURSWWlMqDt9AQXgFengBfwNowXa4SunR4QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;home&quot;
        title=&quot;home&quot;
        src=&quot;/static/edbc79d58f142bde8227dbf5094d4e82/fcda8/6.png&quot;
        srcset=&quot;/static/edbc79d58f142bde8227dbf5094d4e82/12f09/6.png 148w,
/static/edbc79d58f142bde8227dbf5094d4e82/e4a3f/6.png 295w,
/static/edbc79d58f142bde8227dbf5094d4e82/fcda8/6.png 590w,
/static/edbc79d58f142bde8227dbf5094d4e82/efc66/6.png 885w,
/static/edbc79d58f142bde8227dbf5094d4e82/fe9e8/6.png 1146w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게 새로운 패스키가 등록되었다.&lt;br&gt;
앞에 있는 &lt;code class=&quot;language-text&quot;&gt;Macintosh&lt;/code&gt; 는 기본적으로 디바이스 정보를 전달할때 같이 입력되고&lt;br&gt;
이름을 마음대로 변경이 가능하다.&lt;/p&gt;
&lt;p&gt;이제 로그아웃 후 input 창을 보면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/cea7b82731149288d7160221199a9f18/3fca6/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.189189189189186%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB3UlEQVQoz02RS08TURiGz3SmtLowalkYo3gL9Eov8dIS8BIVSCStIvEyndqbhgS8x5/gwqUL1/4Bf4CasFCMGzEx0gs1QQEjBbpy4Q94/GamGhZP3pnvnPPMfOdTKmgSCF0kPXGNIbNKZrLAsdgwfaGTHAqnhVNd0vQNnCA0miVplYiaRTKnx7DiGXLxNHtiE6jkbZQK3cQITeEfyOLrz0rm8IevYEg6BHN4Q5clXXSp9ci6LzKJL3oVb2wKn2DELbRkxRWqsImKWKioTQFN2D00Te/IDHuHZ9iVmSYwMkvvmbsEBD1VRSUqjkBLVrdhC8MidKRdseAR8f5zsxwde8iB8/fYd1aexx/Rf+kJh8cfY6TKqMFbaPGSS6KEx5bbH7JFmkj0aF6w0GMWHsGV59EGixjJMp5E2fl7G48IdKk5pCoO6p/wyOgDGj/aNFc3aaxsuCksrW1RX2kz/7nO6/lPvP2wwNflX7R+dpw9zdUtmrKnJmfWOr95/uwlKphHHbxwn+XFFp3GNzbqLTbr3ZT3dm2J+vuPLLyZ48vcO9YXm059O+u1Fn++r/Dq6QvpyLJbNtGC12WSN2TaMvGwjYkRscnjjxfZKa3tELyxgovc339kvUfQ5Uq043f4C9WFQWlkiOjfAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;logout&quot;
        title=&quot;logout&quot;
        src=&quot;/static/cea7b82731149288d7160221199a9f18/fcda8/7.png&quot;
        srcset=&quot;/static/cea7b82731149288d7160221199a9f18/12f09/7.png 148w,
/static/cea7b82731149288d7160221199a9f18/e4a3f/7.png 295w,
/static/cea7b82731149288d7160221199a9f18/fcda8/7.png 590w,
/static/cea7b82731149288d7160221199a9f18/efc66/7.png 885w,
/static/cea7b82731149288d7160221199a9f18/3fca6/7.png 1112w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2e5d18e35f8b58cabcee7cb11a482947/87254/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACo0lEQVQ4y2WT208aURDGgSaaNK2m3HfluoDc9r7gsiAsFDBeGm20Jk1MowK2feqL/3++zoyAsX2YzDmHPb85881HxAofYI0XsEb3sMJH2JPVS4xXdL6EGS7gzX6hd/4HZesainGDiHmPiL2UiFoPEjEO+wERb/YbTniHptWH3plBPzpDyzuB3j2FFVxsQ2sNka8cQa342K8cY786xF51hHfmHaL2o8A4R4pUMVuwkc+XkVUK8Dwfk/Eclukh/imNRCKDeDyDZDKLVEpFOq0ik1aQpVDp+932NaLO8hVYcb5DKbqYnn5F2/LR6Q4Qjk9gOz7qTQuHdRMNyrrhwTC7aLYctHQPjZYN5UDDTvtGgNENsB0+oUztKEoeak6DZR2h2bRRKtcF3h9M4HX6CPpjDEczOfN7IRy3J98zMOKsBBZ1COhdPqPmzJCMp6GoJVRrbdTrBmqHOjLZwjbSmTxS6ZzkTShq+R/ggoBXzyi1RxiM5mgaHRwff8b85At6QUiaFiW40Js4KEOl4LyjE9BdIeasga3+EoVaAN3soFLT4ftDdDoD1BsmgmCMARVg+GRyivn8QiRgjQM627bsPgkwxsBk6xpZzUcinpI2CsUacvmKvIR1ZAmKpUNZa5WmZN7nC9X1C7+tgQvEXPJmRP+BD6Ue6UYXtaa85vP0TF7BBRJJVbTjvFknUweSRUMCRt8A7RXeF3xMSTe2TZemyBO1bV+s0tZdya4XkEcDWfOETZJIZdsw0COguwFaj+T8ITLJDE2zKBdYP27JoEtsEz7rrAsxjG3Ev4mGAvwpsBgNh4AL7NFfqaqRTtqLRmzkhpja2O7ZOtzqq31youGucfs/8KM2gGtTe2Qbrj6dnot1WEfeX17doqw1ZFDq2jIb27wBeiv8BRcDqneh7fgdAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;login&quot;
        title=&quot;login&quot;
        src=&quot;/static/2e5d18e35f8b58cabcee7cb11a482947/fcda8/8.png&quot;
        srcset=&quot;/static/2e5d18e35f8b58cabcee7cb11a482947/12f09/8.png 148w,
/static/2e5d18e35f8b58cabcee7cb11a482947/e4a3f/8.png 295w,
/static/2e5d18e35f8b58cabcee7cb11a482947/fcda8/8.png 590w,
/static/2e5d18e35f8b58cabcee7cb11a482947/87254/8.png 604w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;짠 하고 현재 등록한 패스키가 다 보인다.&lt;/p&gt;
&lt;p&gt;옆에 적혀 있듯이 해당 패스키의 정보를 &lt;code class=&quot;language-text&quot;&gt;구글 비밀번호 관리자&lt;/code&gt;에 저장 했기 때문에&lt;br&gt;
이제 구글 아이디만 있으면 어떤 디바이스든 해당 사이트를 접속할때&lt;br&gt;
패스키로 간단히 인증이 가능하다.&lt;/p&gt;
&lt;p&gt;맥북의 TouchId 뿐만 아니라 모바일에 해당 구글 아이디가 로그인 되어 있다면&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;별도의 등록없이 모바일의 생체 인증&lt;/code&gt; 으로도 가능하다.&lt;br&gt;
편하긴 정말 편하다.&lt;br&gt;
그리고 스마트 하다.&lt;/p&gt;
&lt;p&gt;위에 적었듯이 현재는 도입한 곳이 많이 없어서 문제지만&lt;br&gt;
실제로 만드는 절차 자체는 그리 어렵지 않다.&lt;/p&gt;
&lt;p&gt;이미 API 가 다 존재하고, 간단하게 패스키를 도입하게 해주는 서비스도&lt;br&gt;
많은 걸로 안다.&lt;/p&gt;
&lt;p&gt;처음 실서비스에 적용할때는 패스워드 로그인과 패스키 둘다 같이 제공하면서&lt;br&gt;
점진적으로 변환을 하면 될 것 같다.&lt;/p&gt;
&lt;p&gt;코드 설명이 조금 빈약한데 다 설명하려니 너무 많아서&lt;br&gt;
더 궁금하다면 코드로 예제를 실행해보고 살펴보길 바란다.&lt;br&gt;
아니면 구글의 &lt;a href=&quot;https://developers.google.com/codelabs/passkey-form-autofill?hl=ko#0&quot; target=&quot;_blank&quot;&gt;Passkey example&lt;/a&gt;을 살펴보자.&lt;/p&gt;
&lt;p&gt;내가 만든 코드역시 해당 코드를 참고 했으며, 서버를 Rust로 변경하고&lt;br&gt;
디자인을 바꾸고, 클라이언트를 Remix 로 변경하면서 이것저것 조금더 추가하고&lt;br&gt;
했을 뿐이다.&lt;br&gt;
거의 싹 갈아 엎긴 했다. 🤡&lt;/p&gt;
&lt;p&gt;github repo: &lt;a href=&quot;https://github.com/WillowRyu/passkey-ex&quot; target=&quot;_blank&quot;&gt;https://github.com/WillowRyu/passkey-ex&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;끝&lt;/h2&gt;
&lt;p&gt;다음은 뭘 만들까 하다가 실제로 진행하는 사이드 프로젝트 외 Rust 로&lt;br&gt;
Tailwind 관련 Parser 를 만들어 볼 예정이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SPA 에서 사용하는 Hot Remote Module Replacement 실험]]></title><description><![CDATA[SPA 프로젝트에서 MF를 사용할때 remote 모듈이 업데이트 되면 새로운 remote 모듈을 사용하기 위해 몇가지 방법이 존재한다. 그전에 간단하게 remote…]]></description><link>https://willowryu.github.io/2024-12-01/</link><guid isPermaLink="false">https://willowryu.github.io/2024-12-01/</guid><pubDate>Sun, 01 Dec 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;SPA 프로젝트에서 MF를 사용할때 remote 모듈이 업데이트 되면 새로운 remote 모듈을&lt;br&gt;
사용하기 위해 몇가지 방법이 존재한다.&lt;/p&gt;
&lt;p&gt;그전에 간단하게 remote를 불러오는 과정을 보면&lt;br&gt;
먼저 &lt;code class=&quot;language-text&quot;&gt;vite&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;rsbuild&lt;/code&gt; 와 같이&lt;br&gt;
특정 번들러에 미리 설정하는 방법과 &lt;code class=&quot;language-text&quot;&gt;FederationRuntime&lt;/code&gt; (이라 runtime) 에&lt;br&gt;
설정했을때와 동작방식이 조금 다르다.&lt;/p&gt;
&lt;p&gt;번들러에 설정했다면 빌드 타임에 불러와야 하는 remote 정보가 등록되며 페이지가 로드될때&lt;br&gt;
즉시 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; (또는 &lt;code class=&quot;language-text&quot;&gt;manifest&lt;/code&gt;) 파일을 불러온다.&lt;/p&gt;
&lt;p&gt;반대로 runtime 을 이용한다면 내가 federation 을 초기화 할수 있는 시점을&lt;br&gt;
정할 수 있고 실제로 &lt;code class=&quot;language-text&quot;&gt;Init&lt;/code&gt; 이 어디에 선언되었는지에 따라 초기화를 시작한다.&lt;/p&gt;
&lt;p&gt;추가로 runtime 에서 제공하는 함수들을 이용해 동적으로 remote 를 등록하고&lt;br&gt;
불러오거나 각종 설정을 변경 시킬수 있다.&lt;/p&gt;
&lt;p&gt;각각의 장단점이 존재하는데 번들러에 포함시킬 경우 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 문을 통해 정적으로&lt;br&gt;
미리 불러올 수 있다는점?이 장점이 될수 있다.&lt;br&gt;
자세한 차이점은 공식 홈페이지를 찾아보자.&lt;/p&gt;
&lt;p&gt;어쨌든 불러온 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; 정보에는 실제로 expose 한 모듈의 소스코드 위치와 이름이 있고&lt;br&gt;
global instance 에 해당 코드를 가져오기 위한 factory 함수가 등록되며, 각 모듈에게&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;moduleId&lt;/code&gt; 가 등록된다.&lt;/p&gt;
&lt;p&gt;이제 remote 가 불러오는 시점, lazy 하게 가져오도록 설정했다면 해당 코드가&lt;br&gt;
렌더링 되는 시점이고,&lt;br&gt;
만약 정적으로 불러온다면 페이지가 처음 로드되는 순간 바로 불러오게 된다.&lt;br&gt;
이때 아까 부여받은 &lt;code class=&quot;language-text&quot;&gt;moduleId&lt;/code&gt; 를 참조해 federation 소스 코드를 불러오게 된다.&lt;/p&gt;
&lt;p&gt;이제 여기서 특정 모듈을 변경하여 업데이트 한 경우를 생각해보자.&lt;br&gt;
변경된 remote 모듈 을 배포하게 되면,&lt;br&gt;
사용자는 이제 새로운 remote 모듈을 사용할 수 있다.&lt;br&gt;
하지만 브라우저 환경에서 이를 사용자에게 자연스럽게 적용시키는 방법이 필요하다.&lt;/p&gt;
&lt;p&gt;특히 브라우저는 아마 처음에 불러온 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; 정보를 캐싱하고 있을 확률이 높다.&lt;br&gt;
이걸 업데이트 된 새로운 코드로 적용시키는 방법은 뭐가 있을까?&lt;/p&gt;
&lt;h2&gt;새로고침&lt;/h2&gt;
&lt;p&gt;가장 깔끔하고 정확한 방법이다.&lt;br&gt;
다만 위에 적었듯이 브라우저는 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; 파일을 받았을때 이를 자체적으로 캐싱을&lt;br&gt;
하고 있을 것이다.&lt;/p&gt;
&lt;p&gt;이럴때는 일반적인 새로고침이 아닌 캐시 무효화 새로고침을 하거나,&lt;br&gt;
아니면 cache 정책을 설정해 cache 를 하지 않도록 하고,&lt;br&gt;
추가로 cdn 을 통해 코드를 공급받고 있다면 cdn 의 캐시도 무효화 해야 할 것이다.&lt;/p&gt;
&lt;h2&gt;수동으로&lt;/h2&gt;
&lt;p&gt;runtime 에서 공개한 함수들을 통해 특정 remote 를 다시 불러오도록 할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const [showComponent, setShowComponent] = useState(false)
const replaceRemote = () =&amp;gt; {
  console.log(&amp;quot;replaceRemote click&amp;quot;)
  registerRemotes(
    [
      {
        name: &amp;quot;dynamic_remote&amp;quot;,
        entry: &amp;quot;http://localhost:3056/mf-manifest.json&amp;quot;,
      },
    ],
    { force: true }
  )

  setShowComponent(true)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 함수를 만들어 해당 remote 를 다시 등록시켜 새로운 remote 를 불러오는&lt;br&gt;
방법도 있다.&lt;/p&gt;
&lt;h2&gt;문제점&lt;/h2&gt;
&lt;p&gt;위 방법들은 사용자가 원할때 새로운 모듈을 받을 수 있도록 할수 있은 좋은 방법들이다.&lt;br&gt;
다만 내가 겪었던 문제들 중 한가지 경우를 소개해본다.&lt;/p&gt;
&lt;p&gt;우리는 &lt;code class=&quot;language-text&quot;&gt;s3 + cloudfront&lt;/code&gt; 조합을 사용중이고 실제 각 모듈의 소스코드는 s3 에 모두&lt;br&gt;
저장되고 있다.&lt;/p&gt;
&lt;p&gt;배포를 하게되면 s3 에 특정해둔 각 모듈 별 폴더 내 모든 파일이 클리어되고&lt;br&gt;
새로운 파일로 채워지게 된다.&lt;/p&gt;
&lt;p&gt;이전 파일들을 모두 지우는 이유는 모듈이 너무 늘어나게 되면서 s3 에 너무 많은 파일이&lt;br&gt;
저장되고 있었다.&lt;/p&gt;
&lt;p&gt;이를 주기적으로 삭제해야 하는데 이 또한 리소스가 들어가기 때문에&lt;br&gt;
그냥 배포 할때 자동으로 이전 파일들은 모두 지우고&lt;br&gt;
무조건 최신버전을 제공하도록 하려고 했다.&lt;/p&gt;
&lt;p&gt;물론 s3 에서 자동으로 특정 기한이 지난 파일을 지우도록 하는 방법도 있긴 하다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;사용자 경험을 생각하면 좋은 방법은 아니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어쨌든 여기서 문제는 위에 적었듯이 &lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 가 실행될때 해당 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; 정보들을&lt;br&gt;
미리 불러오는데 만약 정적으로 모듈을 불러왔다면 해당 소스 파일들을&lt;br&gt;
미리 불러오기 때문에 대상 모듈이 업데이트 되어도 캐싱으로 인해 문제없이 작동을 하게 된다.&lt;/p&gt;
&lt;p&gt;문제는 &lt;code class=&quot;language-text&quot;&gt;lazy&lt;/code&gt; 하게 불러오는 컴포넌트다.&lt;br&gt;
예를들어 처음 로드될때 &lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;remoteEntry&lt;/code&gt; 정보를 불러와서 remote 의 factory를&lt;br&gt;
만들고 remote 정보를 등록한다.&lt;/p&gt;
&lt;p&gt;그리고 현재 &lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;expose&lt;/code&gt; 한 컴포넌트는 사용되지 않았기에 실제 소스코드는 불러오지&lt;br&gt;
않은 상태다.&lt;/p&gt;
&lt;p&gt;여기서 2번 페이지로 이동했을때 &lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; 의 컴포넌트를 &lt;code class=&quot;language-text&quot;&gt;lazy&lt;/code&gt; 하게 불러온다고 생각해보자.&lt;/p&gt;
&lt;p&gt;일반 적인 경우라면 문제 없겠지만 만약 사용자가 2번 페이지로 가지 않은 상황에서&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; 모듈을 업데이트 한뒤 배포 했다면 어떻게 될까?&lt;/p&gt;
&lt;p&gt;사용자가 2번 페이지로 갔을때 브라우저 에서는 미리 불러온 &lt;code class=&quot;language-text&quot;&gt;entry&lt;/code&gt; 정보를 참조해서&lt;br&gt;
업데이트 된 module 이 아닌 이전 module 의 소스코드와 주소를 가리키고 있을 것이다.&lt;br&gt;
하지만 이미 s3 에는 해당 소스코드가 없고 새롭게 생성된 소스코드만 존재한다.&lt;/p&gt;
&lt;p&gt;이제 브라우저는 해당 코드를 가져오지 못하고 &lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt;의 컴포넌트는 위에 설명한 방법으로&lt;br&gt;
다시 불러오기 전까지는 사용하지 못하게 된다.&lt;/p&gt;
&lt;h2&gt;해결방법&lt;/h2&gt;
&lt;p&gt;실제로 특정 모듈이 업데이트 되었을때 사용자에게 브라우저 새로고침에 대한 안내가&lt;br&gt;
자동으로 나타나도록 설정은 되어있다.&lt;/p&gt;
&lt;p&gt;하지만 이건 강제가 아니기 때문에 업데이트를 하지 않고 사용하게 되면 오류를&lt;br&gt;
맞닥뜨릴 상황이 일어날 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아니면 S3 에 이전 업데이트 파일들을 남겨두면 좋지 않을까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그렇다.&lt;br&gt;
그러면 사용자는 오류 없이 제품을 계속 이용할 수 있고 원할때 새로고침으로&lt;br&gt;
업데이트 하면된다.&lt;/p&gt;
&lt;p&gt;사실 이게 가장 좋은 사용자 경험의 예이다.&lt;br&gt;
다만 이는 깊게 들어가면 결국 소스코드 version control 이 필요해지는 상황이 온다.&lt;/p&gt;
&lt;p&gt;그리고 만약에 주요 오류를 수정한 핫픽스라면?&lt;br&gt;
사용자 모두가 지금 빨리 빠르게 최신 버전으로 업데이트 해야 한다면?&lt;/p&gt;
&lt;h2&gt;또 다른 방법&lt;/h2&gt;
&lt;p&gt;그래서 생각한게 그냥 사용자가 모르게 업데이트를 시켜버리면 되지 않나? 라고 생각했다.&lt;br&gt;
새로고침을 할 필요도 없고, 수동으로 버튼을 클릭해서 다시 불러오는 행위 없이&lt;br&gt;
그냥 해당 컴포넌트들이 자동으로 최신버전으로 변경되도록 하고 싶었다.&lt;/p&gt;
&lt;p&gt;보통 실제로 사용자가 활발히 사용하는 시간에 배포한다는 것은 오류로 인한 핫픽스 이거나&lt;br&gt;
style 수정 및 UI 수정 등이 대부분이다.&lt;/p&gt;
&lt;p&gt;주요 새로운 기능이나 업데이트는 정기적인 배포시간을 통해 하는것이 안정적이기 떄문이다.&lt;/p&gt;
&lt;p&gt;다만 조그마한 핫픽스 수정으로 인해 사용자가 오류를 보게 되는 불행한 상황을 피하고&lt;br&gt;
사용자의 흐름을 끊기게 하고 싶지 않았다.&lt;/p&gt;
&lt;p&gt;하여 자동으로 업데이트 된 모듈을 불러오는 플러그인을 만들었다.&lt;/p&gt;
&lt;h2&gt;replaceModulePlugin&lt;/h2&gt;
&lt;p&gt;방법은 단순하다.&lt;br&gt;
모듈을 불러올때 소스코드 업데이트로 인해 factory 를 만들지 못하게 되면&lt;br&gt;
해당 모듈을 최신 코드로 다시 가져온 뒤 factory 를 다시 등록하면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    async getModuleFactory({ remoteEntryExports, expose, moduleInfo }) {
      let moduleFactory;
      let attempts = 0;
      while (attempts - 1 &amp;lt; 3) {
        try {
          if (attempts &amp;gt; 1) {
            const remoteEntryExportsNew = await replaceRemote(moduleInfo);
            if (remoteEntryExportsNew) {
              moduleFactory = await remoteEntryExportsNew.get(expose);
              break;
            }
          }
          moduleFactory = await remoteEntryExports.get(expose);
          break;
        } catch {
          attempts++;
          await new Promise((resolve) =&amp;gt; {
            setTimeout(resolve, 1000);
          });
        }
      }

      return moduleFactory;
    },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;plugin 에는 &lt;code class=&quot;language-text&quot;&gt;getModuleFactory&lt;/code&gt; 라고 공개한 함수가 있다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;lifecycle&lt;/code&gt; 로 보면 remoteEntry 에 등록된 모듈을 불러올때 실행되고&lt;br&gt;
해당 모듈의 factory 를 return 해야한다.&lt;/p&gt;
&lt;p&gt;여기서 오류를 포착했을때 일단 &lt;code class=&quot;language-text&quot;&gt;factory is not a function&lt;/code&gt; 오류를 지연시키고&lt;br&gt;
해당 remote 모듈을 다시 불러와서 등록 시켜야 한다.&lt;/p&gt;
&lt;p&gt;위 코드는 예제로 현재 3번 retry 하게 되어있고 만약 3번 까지 시도했음에도 동작이&lt;br&gt;
안된다면 이는 호스팅 서비스나 네트워크 문제일 확률이 높다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;try {
  if (attempts &amp;gt; 1) {
    const remoteEntryExportsNew = await replaceRemote(moduleInfo)
    if (remoteEntryExportsNew) {
      moduleFactory = await remoteEntryExportsNew.get(expose)
      break
    }
  }
  moduleFactory = await remoteEntryExports.get(expose)
  break
} catch {
  attempts++
  await new Promise(resolve =&amp;gt; {
    setTimeout(resolve, 1000)
  })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;while 문 안에 있는 내용은 만약 attempts 가 1을 넘어가면 그때 새로운 module 을&lt;br&gt;
등록하는 절차를 시작하게 된다.&lt;/p&gt;
&lt;p&gt;이유는 위 &lt;code class=&quot;language-text&quot;&gt;getModuleFactory&lt;/code&gt; 함수는 오류가 있든 없든 무조건 실행되기 때문에&lt;br&gt;
정상적인 remote 들은 새로 불러올 필요가 없다.&lt;/p&gt;
&lt;p&gt;2번째 시도 부터는 오류라고 판단하고 새롭게 remote 를 불러와서 등록하게 된다.&lt;/p&gt;
&lt;p&gt;각 재시도 간격은 1초로 정하고 실제로 화면에서는 &lt;code class=&quot;language-text&quot;&gt;suspense&lt;/code&gt;로 인해 커스텀하게&lt;br&gt;
만들어둔 UI 가 표시되고 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const replaceRemote = async moduleInfo =&amp;gt; {
  let remoteEntryExports
  await registerRemotes(
    [
      {
        name: moduleInfo.name,
        shareScope: moduleInfo.shareScope,
        alias: moduleInfo.alias,
        entryGlobalName: moduleInfo.entryGlobalName,
        entry: `${moduleInfo.entry}?t=${Date.now()}`,
        version: moduleInfo.version,
      },
    ],
    {
      force: true,
    }
  )

  const host = getInstance()
  if (host) {
    const { module } = await host.remoteHandler.getRemoteModuleAndOptions({
      id: moduleInfo.name,
    })
    remoteEntryExports = await module.getEntry()
  }

  return remoteEntryExports ?? null
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;replace remote 는 moduleInfo 정보를 받아와서 새롭게 remote 를 등록하고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 정보를 불러온다.&lt;/p&gt;
&lt;p&gt;그리고 현재 &lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;remoteHandler&lt;/code&gt; 에서 오류가 난 module 의 정보를 가져와서&lt;br&gt;
새롭게 remoteEntry 를 구성하고 이를 return 하게 된다.&lt;/p&gt;
&lt;p&gt;이때 가져온 모듈의 정보는 새롭게 remote 를 등록했기 때문에 최신버전이 적용된&lt;br&gt;
모듈의 정보다.&lt;/p&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;force:true&lt;/code&gt; 같은 경우 해당 remote 를 다시 불러오면서 기존에 있는&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;module cache&lt;/code&gt; 를 지우게 되는데 주의할 점은 해당 remote 가 가지고 있는&lt;br&gt;
모든 remote 모듈의 cache 도 지우게 된다.&lt;/p&gt;
&lt;p&gt;예를 들어 B 모듈을 가져오는데 B모듈이 remote 로 C 모듈을 사용하고 있다면,
B 와 C 둘다 moduleCahce 에서 삭제되고 다시 등록된다.&lt;/p&gt;
&lt;p&gt;만약 여기서 C 모듈이 singleton 으로 특정 state 를 공유하는 있는 특정 코드이고&lt;br&gt;
다른 모듈에서 사용중이라면 side effect 가 생길 수도 있다.&lt;br&gt;
보통 그런 경우는 잘 없겠지만 사용할 때 신중하게 사용해야 한다.&lt;/p&gt;
&lt;p&gt;그리고 singleton 으로 state 를 공유하는 모듈을 remtoe 로 사용하는 건&lt;br&gt;
추천하는 remote 방식이 아니다.&lt;/p&gt;
&lt;p&gt;어쨌든 여기서 새롭게 만든 remoteEntry 정보룰 가지고 &lt;code class=&quot;language-text&quot;&gt;getModuleFactory&lt;/code&gt;에서&lt;br&gt;
다시 등록하게 되면 정상적으로 최신 코드가 반영된 모듈을 사용할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;현재 실험중에는 큰 오류는 없었지만 실제로 프로덕션에 적용했을때 어떤 사이드 이펙트가&lt;br&gt;
생길지 모르기 떄문에 특정 모듈을 시작으로 점진적으로 적용해보려 한다.&lt;/p&gt;
&lt;p&gt;federation 팀에서 좀더 원하는 함수를 더 제공해주면 좋겠지만…&lt;br&gt;
우리 제품이 특수한 경우라 일단 번거롭게 이런 방법을 사용해야 한다.&lt;br&gt;
나중에 시간되면 pr 을 만들거나 제안을 해봐야 겠다.&lt;/p&gt;
&lt;h2&gt;끝&lt;/h2&gt;
&lt;p&gt;이로서 사용자는 새로고침을 할 필요도 없고 뭔가 어떠한 행위없이 최신 코드가 올라갔을때&lt;br&gt;
자동으로 새로운 코드가 적용되도록 할 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;만약 ssr 을 사용한다면 좀 더 쉬운 방법이 있지만 spa 에서는 이런 방법이 절충안이다.&lt;br&gt;
좀더 좋은 방법이 있다면 누가 알려주면 좋겠다.&lt;/p&gt;
&lt;p&gt;나중에 안전한 모듈만 replace 시키는 filter 도 만들고, &lt;code class=&quot;language-text&quot;&gt;registerRemotes&lt;/code&gt; 를&lt;br&gt;
사용하지 않고 오류가 난 remote 만 직접 &lt;code class=&quot;language-text&quot;&gt;moduleCache&lt;/code&gt; 를 조작하는 코드로&lt;br&gt;
수정해보는 것도 좋아보인다.&lt;/p&gt;
&lt;p&gt;rust 와 node, remix 로 만들어본 passkey 예제도 다 만들고 다듬는 중이라..&lt;br&gt;
아마 다음 글에는 나올듯&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Unmanaged Language]]></title><description><![CDATA[최근에 를 공부하면서 GC 와 managend, unmanaged 에 대해 조금 찾아봤다. 이 두 분류를 구분할때 GC (garbage collector) 의 유무에 따라 managed 와 unmanaged…]]></description><link>https://willowryu.github.io/2024-10-03/</link><guid isPermaLink="false">https://willowryu.github.io/2024-10-03/</guid><pubDate>Thu, 03 Oct 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;최근에 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;를 공부하면서 GC 와 managend, unmanaged 에 대해 조금 찾아봤다.&lt;/p&gt;
&lt;p&gt;이 두 분류를 구분할때 GC (garbage collector) 의 유무에 따라 managed 와 unmanaged 를 구분하기도 하고, 해당 언어가 네이티브로 컴파일 되는지, 바이트코드로 컴파일 되는지에 대해서도 분류 하기도 한다.&lt;/p&gt;
&lt;p&gt;이렇게 분류하면 &lt;code class=&quot;language-text&quot;&gt;Java&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;C#&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Python&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Js&lt;/code&gt; 등은 managed 가 되고, &lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;C++&lt;/code&gt; 같이 개발자에게&lt;br&gt;
메모리에 대한 모든 제어권을 주는 언어는 unmanaged 라고 볼수 있다.&lt;/p&gt;
&lt;p&gt;어 &lt;code class=&quot;language-text&quot;&gt;Go&lt;/code&gt; 같은 경우에는 GC 가 있던데요? 하지만 네이티브로 컴파일도 된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Go&lt;/code&gt; 는 그럼 managed 인가?&lt;/p&gt;
&lt;p&gt;개인적으로 managed 와 unmanaged 의 개념을 GC 의 존재 유무로 구분하기로 생각중이라&lt;br&gt;
(&lt;code class=&quot;language-text&quot;&gt;Java&lt;/code&gt; 나 &lt;code class=&quot;language-text&quot;&gt;C#&lt;/code&gt; 도 네이티브 코드로 컴파일 할 수 있다.)&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;GO&lt;/code&gt; 도 managed 라고 생각하고 싶다.&lt;/p&gt;
&lt;p&gt;그럼 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;는 어떨까&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;Ownership&lt;/code&gt; 이라는 독특한 방법을 통해 메모리를 관리한다.&lt;/p&gt;
&lt;p&gt;이게 참 신기한게 개발자가 직접 명시적으로 메모리를 할당하고 해제하는 것 보다&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;가 나에게 자동으로 메모리를 관리할 수 있도록 유도한다고 할까?&lt;/p&gt;
&lt;p&gt;실제로 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 에서 메모리 할당을 해제하는 &lt;code class=&quot;language-text&quot;&gt;drop&lt;/code&gt; 도 존재하지만&lt;br&gt;
거의 쓰이질 않는다. (아마도?)&lt;/p&gt;
&lt;p&gt;그럼 unmanaged 로 분류할 수 있나? 그런 것 같다.&lt;br&gt;
이 &lt;code class=&quot;language-text&quot;&gt;Ownership&lt;/code&gt; 의 규칙을 따라 개발하다보면 자연적으로 메모리 관리를 생각하며&lt;br&gt;
개발하게 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 컴파일러가 정말 끝내주기는 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GC 를 탑재한다는 것은 성능과 생산성의 트레이드오프가 있지만, (Go?)&lt;br&gt;
최근에는 뭐 하드웨어 사양들이 워낙 좋아서&lt;br&gt;
게임이나 임베디드 같이 하드웨어 성능을 극한으로 최적화 시켜야 하는 경우가 아니라면&lt;br&gt;
꼭 unmanaged 를 사용해야 할 이유가 많이 줄었다고 생각한다.&lt;/p&gt;
&lt;p&gt;그럼에도 &lt;code class=&quot;language-text&quot;&gt;unmanaged language&lt;/code&gt; 는 공돌이라면 꼭 공부해야 하는 분야라고 생각한다.&lt;br&gt;
우리 친구 전자계산기의 OS 나 하드웨어의 동작방식에 더 깊은 이해를 가져다 주고,&lt;br&gt;
개발할때 생각하는 방향이 달라진다.&lt;br&gt;
개인적으로 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;에서 가져오고 싶은 개념들이 많다.&lt;/p&gt;
&lt;p&gt;추천하는 언어는 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;이긴 하지만, unmanaged 를 처음 접한다면 러닝커브가 조금 클 것이다.&lt;/p&gt;
&lt;p&gt;추가로 예전에 글에서 적었지만 현재 &lt;code class=&quot;language-text&quot;&gt;Js&lt;/code&gt; 의 전성기가 다시 오고 있는 시점에서&lt;br&gt;
그 뒤에는 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;가 큰 역할을 하고 있다.&lt;br&gt;
흥미가 가는 부분이다.&lt;/p&gt;
&lt;p&gt;코드 하나 없는 재미없는 일기는 여기까지 적고&lt;br&gt;
다음 글은 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 로 만든 서버와 웹서비스 예제를 가지고 살펴 보자.아마도.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Upgrade Project]]></title><description><![CDATA[현재 재직중인 회사의 프로젝트는 거대한은 아니고 큰 monorepo 로 이뤄져 있으며 root 의 package.json 에 각 모듈이 사용하는 모든 package…]]></description><link>https://willowryu.github.io/2024-08-18/</link><guid isPermaLink="false">https://willowryu.github.io/2024-08-18/</guid><pubDate>Sun, 18 Aug 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/074cdd09e1b45ebfce028e7b05d096ca/c1b63/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 78.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD20lEQVQozwHQAy/8ADZ7wzh7xECAxjl7wzJ6x1WBtaGpvtzl89nh7Zi43cjS4/Pz9tHc7c/c7M/b7evt9b/S6WKZ1Xmo23up2wA6fcU5fcU0ecU5fMQ3fchfibuRoL1RjtJilc9Qist2o9aUtt6LrtnF1erQ3O7X4fDl7PWCrt2Tt+Hn7fYASobIPH/HY428QoDCMnvHY4e1trzLU4W+WY/McqLYVY/PTYzPTI7Re6fZob7iw9Hl////3ufzz97w8fT5AHSf0zt9x665ypa22zZ+yztTd2tiaZuNjKaip9XZ5W+g1kqO0k6KylyNxXuZwNrb4uDj6e7v8vr6/crZ6wC8zuZblNJqjru+vciEpMwsNE1MT2CqmI92eXtwcnd0haJWkc9OkNNJf7paaouptMvJ0d/L0N7N2enY5PMA4+fv0OP4RWGIXFNZl4WAKzJJZV9yvqWfhKDAZoKjZWx/doCZYoSwWHyrSlFsRlJzp7HErLXIys/a3eDoAM3U4e3x911hc1dSW5N+dzI2SlU9SphwbKGcpZ+hsmJmc0JFVlVUYUJGWTg4SWJleYem0ISlz6m927K+0wCUoLuzvM5GS2BsYGKekZBldZI+HCFZPENwf51ITF02PE44OUU6QFJHQEZeUlKSkqKYtt91odeAp9edut4AiaDEscDYgoiXp5iQpK/AcJ/YdIGfmI2aeZjAb4yydJjHXWyHTFBkQT5KTEhPbm93oqSxoK3FuMvlxNLoALfH3rLD3b3K4cbQ4qe/3n6k1ougycrDzZOTnYGVsn+Xu05ffWJ0k1NeeHeBl3iPrYKXs5600bbK5LDH5ADQ1uS0xd6iu9uswuCqv92Qs919jLXUzNe9yuCLp8uHmLNmbYBfbH5odYamrLy70u7J2e7K1+nM1uXJ1ecAtL7SucHTzdXjz9fnztfpy9jsgpC0sq3A4uf0tsnmtsXeydfttsDScHmCfoWTv87kxdPpxtftw9Trx9PoAKq917LH4piowqi0xJ6qtbjE0H2Nr4iKpt3a3MHQ17nK2LfH177O37rL3LLD08HQ47rF0rO9ycDM2sfW5wBmc194inxKVEpYYU1QWUdga1hqb3eDg4aTpJKOooyNoI+KnouJnYmSpY9wfW1kbltPWUhDSzdWYklufmcAh4eJgn+GiomRjYuWjYqYjY2cTEZLdXB1lJWlmpiomZenlJOkkpGgkI6cioiShISMf3+Hg4WKfX+Ce3x+AHt2fHZzdXRxcnBscXNxdoB9gygnKk9MVYmIl5aUoJ6Zo3t6h4eGlYSCkX58h4uHi5KMi4+KipGLjJiSkibvSqVUlVAtAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;ff&quot;
        title=&quot;ff&quot;
        src=&quot;/static/074cdd09e1b45ebfce028e7b05d096ca/fcda8/1.png&quot;
        srcset=&quot;/static/074cdd09e1b45ebfce028e7b05d096ca/12f09/1.png 148w,
/static/074cdd09e1b45ebfce028e7b05d096ca/e4a3f/1.png 295w,
/static/074cdd09e1b45ebfce028e7b05d096ca/fcda8/1.png 590w,
/static/074cdd09e1b45ebfce028e7b05d096ca/efc66/1.png 885w,
/static/074cdd09e1b45ebfce028e7b05d096ca/c83ae/1.png 1180w,
/static/074cdd09e1b45ebfce028e7b05d096ca/c1b63/1.png 1200w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;현재 재직중인 회사의 프로젝트는 거대한은 아니고 큰 monorepo 로 이뤄져 있으며&lt;br&gt;
root 의 package.json 에 각 모듈이 사용하는 모든 package 들이 정의되어 있다.&lt;/p&gt;
&lt;p&gt;이렇게 &lt;code class=&quot;language-text&quot;&gt;singleVersionPolicy&lt;/code&gt; 를 사용하게 되면 각 모듈이 별도의 버전을 가지는 것에 비해&lt;br&gt;
내부 모든 코드가 호환되고 일관성이 생기며, 특정 package 를 업데이트 할때 전체 모듈에게&lt;br&gt;
한번에 배송된다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;monorepo 구조의 개발과 배포에 대한 부담감을 상당히 줄여주는 package 중 하나는&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;turborepo&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;nx&lt;/code&gt; 가 있겠다.&lt;/p&gt;
&lt;p&gt;이는 많은 수의 개별 모듈을 만들고 실행할때 명령어들을 하나로 압축하여&lt;br&gt;
한번에 관리 할수 있는 아주 편리한 기능을 제공해주며, caching 으로 인해 시간의 손실을&lt;br&gt;
현격히 줄여준다.&lt;/p&gt;
&lt;p&gt;또 하나로 흔히 말하는 &lt;code class=&quot;language-text&quot;&gt;micro frontend&lt;/code&gt; 구조를 위해 &lt;code class=&quot;language-text&quot;&gt;module federation (mfe)&lt;/code&gt; 를&lt;br&gt;
사용하고 있는데 이는 모듈의 변경사항을 적용할때 각모듈을 이어주고 런타임에서&lt;br&gt;
적용시켜주는 아주 고마운 기능을 제공해준다.&lt;/p&gt;
&lt;p&gt;위 2가지 핵심기술과 나머지 도구들을 조합하여 몇년전부터 계속 프로젝트를 진행하던 중&lt;br&gt;
나는 슬슬 속도에 불만이 생기기 시작했다. 🤔&lt;/p&gt;
&lt;p&gt;우리는 &lt;code class=&quot;language-text&quot;&gt;shared&lt;/code&gt; 한 기능을 수정하거나 &lt;code class=&quot;language-text&quot;&gt;internal package&lt;/code&gt; 가 변경될때&lt;br&gt;
모든 모듈을 다시 &lt;code class=&quot;language-text&quot;&gt;build&lt;/code&gt; 하고 배포해야 하는 경우가 종종 생기게 되는데&lt;br&gt;
현재 모듈이 약 40개 가까이 만들어져 있으므로 CI 에서 속도가 점점 느려지기 시작했다.&lt;/p&gt;
&lt;p&gt;이를 개선하기 위해 각 CI 단계에서 실행되는 명령어중 속도를 올릴수 있는 도구로&lt;br&gt;
변경해 보기로 했다.&lt;/p&gt;
&lt;h2&gt;lint&lt;/h2&gt;
&lt;p&gt;eslint 는 역사가 깊고, 커스텀할 수 있는 영역이 굉장히 많아 대부분의 개발자가 사용하는&lt;br&gt;
범용적인 linter 이다.&lt;/p&gt;
&lt;p&gt;사실 lint 자체의 속도는 그렇게 큰 이슈가 되지 않았지만 가장먼저 만만해 보이는 lint 먼저&lt;br&gt;
rust 기반의 &lt;code class=&quot;language-text&quot;&gt;oxlint&lt;/code&gt; 로 변경했다.&lt;/p&gt;
&lt;p&gt;확실히 변경 후 속도가 10초 이상을 가는 적이 없을 정도로 효과가 어마어마 했다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;oxlint&lt;/code&gt; 로 변경할때 &lt;code class=&quot;language-text&quot;&gt;eslint&lt;/code&gt; 의 구성을 가져다 쓸수도 있고, 자체적으로 왠만한 범용규칙은&lt;br&gt;
가지고 있기 때문에 변경하는데 큰 어려움은 없었다.&lt;/p&gt;
&lt;h2&gt;tsc&lt;/h2&gt;
&lt;p&gt;우리는 pr 이든 push 든 모든 부분에서 &lt;code class=&quot;language-text&quot;&gt;noEmit&lt;/code&gt; 상태로 &lt;code class=&quot;language-text&quot;&gt;tsc&lt;/code&gt; 를 실행한다.&lt;br&gt;
다만 &lt;code class=&quot;language-text&quot;&gt;tsc&lt;/code&gt; 의 속도는 발전했다고는 하나 아직 여전히 느리다. 내생각에는.&lt;br&gt;
CI 에서 다른 부분의 속도가 빨라지게 되니 tsc 의 시간이 차지하는 지분이 점점 많아졌다.&lt;/p&gt;
&lt;p&gt;이미 2020년에 &lt;code class=&quot;language-text&quot;&gt;noEmit&lt;/code&gt; 상태에서 &lt;code class=&quot;language-text&quot;&gt;incremental&lt;/code&gt; 의 옵션을 적용 가능 하기 때문에&lt;br&gt;
CI 에서 해당 옵션을 적용할 수 있도록 caching 을 손보기 시작했다.&lt;/p&gt;
&lt;p&gt;적용 후 어느정도 빨라지긴 했지만 아직은 만족할 수 없다.&lt;br&gt;
이제 rust 기반의 툴에 익숙해진 탓이다.&lt;/p&gt;
&lt;h2&gt;webpack&lt;/h2&gt;
&lt;p&gt;이외에 다른 부분도 자잘하게 변경하여 시간의 손실을 조금씩 막았지만, &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 의&lt;br&gt;
빌드 부분은 최적화를 하고 또 해도 한계가 있어보였다.&lt;/p&gt;
&lt;p&gt;기능 구조를 바꾸고 모듈을 더 쪼개고 각 모듈이 적은 코드를 가질 수 있도록 변경해도&lt;br&gt;
속도에 대해서는 그렇게 큰 이점을 얻지 못했다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 의 최적화는 속도보다 최종 결과물의 용량에 대해 더 관여하는 느낌이었다.&lt;/p&gt;
&lt;p&gt;그래서 결국 이전부터 눈여겨보던 &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 으로의 변경을 시도했다.&lt;br&gt;
때마침 &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;1.0.0 alpha, beta&lt;/code&gt; 버전이 출시 되기 시작했다.&lt;/p&gt;
&lt;h2&gt;변경하기 전에&lt;/h2&gt;
&lt;p&gt;특정 패키지를 변경할때 뿐만 아니라 기능을 변경하거나 추가할때, 어쨌든 하위호환이 가능하도록&lt;br&gt;
유지하고 점진적으로 프로젝트를 변경해야 한다.&lt;/p&gt;
&lt;p&gt;번들러가 변경된다고 내부 코드에서 특정 무언가를 변경하는 경우가 없도록 해야 한다.&lt;br&gt;
이 점을 최대한 유의하며 작업을 시작했다.&lt;/p&gt;
&lt;h2&gt;webpack plugin&lt;/h2&gt;
&lt;p&gt;번들러 변경시 첫번째로 걱정된점은&lt;br&gt;
우리는 &lt;code class=&quot;language-text&quot;&gt;tailwindcss&lt;/code&gt; 를 주력으로 사용중이며, module 간 tailwind 의 treeshaking 으로&lt;br&gt;
만들어진 css 정의가 중복되면 안되고, &lt;code class=&quot;language-text&quot;&gt;css cascade&lt;/code&gt; 에 서로 영향을 받지 않도록&lt;br&gt;
만들어야 했다.&lt;/p&gt;
&lt;p&gt;이를 위해 별도의 &lt;code class=&quot;language-text&quot;&gt;webpack plugin&lt;/code&gt; 을 자체적으로 만들어 각 모듈이 build 될때&lt;br&gt;
module의 이름이 &lt;code class=&quot;language-text&quot;&gt;prefix&lt;/code&gt; 로 담긴 &lt;code class=&quot;language-text&quot;&gt;css 파일&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;className&lt;/code&gt; 을 만들어 주도록 했다.&lt;/p&gt;
&lt;p&gt;다행히 &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 에서는 기존 webpack 의 plugin 과 호환성을 가지도록 인터페이스가 제공되어&lt;br&gt;
특별히 해당 plugin 을 변경 할 필요는 없었다.&lt;/p&gt;
&lt;h2&gt;module federation&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 에서 빌드된 파일들이 기존 프로젝트에서 서로 호환이 유지되어야 했다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;module federation core&lt;/code&gt; 팀은 번들러에 내장된 기능을 사용하는 것이 아닌&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;module federation runtime&lt;/code&gt; 으로 새롭게 분리하여 특정 번들어에 종속되지 않고&lt;br&gt;
federation 기능을 사용할 수 있도록 만들었다.&lt;/p&gt;
&lt;p&gt;그래서 먼저 &lt;code class=&quot;language-text&quot;&gt;module federation runtime&lt;/code&gt; 을 활용하여 federation 의 역활과&lt;br&gt;
번들러의 역활을 명확하게 나누어 새로운 구조를 만들었다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 으로 빌드를 하던, &lt;code class=&quot;language-text&quot;&gt;vite&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 으로 빌드를 하던 mfe 는 그에 상관없이&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;runtime&lt;/code&gt; 에 remote 와 host 가 잘 통합된다.&lt;/p&gt;
&lt;h2&gt;module federation plugin&lt;/h2&gt;
&lt;p&gt;mfe 가 별도의 라이브러리로 분리되면서 기존에 있던 불편한점이 많이 사라졌다.&lt;br&gt;
예를 들면 &lt;code class=&quot;language-text&quot;&gt;dynamic remote load&lt;/code&gt; 를 할때 &lt;code class=&quot;language-text&quot;&gt;new promise&lt;/code&gt; 를 사용하는 짜치는 방법에서&lt;br&gt;
이제는 runtime 에 포함된 기능으로 간단히 구현이 가능한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;분리되면서 federation 의 기능을 좀더 세밀하게 제어할 수 있는 인터페이스가&lt;br&gt;
많이 생겼다. 공식 홈페이지를 참고해보자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이번에 구조를 바꾸면서 공통적으로 사용 할 2가지 &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt; 을 추가 했는데,&lt;br&gt;
첫번째는 기존 webpack 의 plugin 으로 사용하던 &lt;code class=&quot;language-text&quot;&gt;external remote plugin&lt;/code&gt; 을&lt;br&gt;
mfe 의 plugin 으로 옮겨서 적용했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { FederationRuntimePlugin } from &amp;quot;@module-federation/enhanced/runtime&amp;quot;

function externalRemoteLoadPlugin(): FederationRuntimePlugin {
  return {
    name: &amp;quot;external-remote-load-plugin&amp;quot;,
    beforeRequest: args =&amp;gt; {
      const { options, id } = args
      const remoteName = id.split(&amp;quot;/&amp;quot;).shift()
      const remote = options.remotes.find(remote =&amp;gt; remote.name === remoteName)
      if (!remote) {
        return args
      }

      // @ts-ignore
      if (remote?.entry?.includes(&amp;quot;?t=&amp;quot;)) {
        return args
      }

      // @ts-ignore
      remote.entry = `${remote?.entry}?t=${Date.now()}`
      return args
    },
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러면 &lt;code class=&quot;language-text&quot;&gt;remoteEntry.js&lt;/code&gt; 파일에대해 &lt;code class=&quot;language-text&quot;&gt;cache busting&lt;/code&gt; 을 plugin 없이 적용 가능하다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;manifest.json&lt;/code&gt; 파일을 사용 할 경우 추가 코드가 필요하지만 맥락은 같다.&lt;/p&gt;
&lt;p&gt;또 다른 하나는 &lt;code class=&quot;language-text&quot;&gt;hmr&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt; 와 관련된 부분이다.&lt;/p&gt;
&lt;p&gt;기존에 local 에서 특정 host 와 remote 를 연결해서 개발할때 자체적으로 만든 명령어를&lt;br&gt;
사용하여 각 모듈을 개발 서버로 띄워서 hmr 기능을 활용하도록 만들었다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;context&lt;/code&gt; 의 공유 문제나 특정 모듈이 먼저 로드 되어야 할때,&lt;br&gt;
예를 들어 디자인시스템 등,&lt;br&gt;
shared 로 설정된 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt; 를 어떤 모듈에서 가져와 사용할지에 대해&lt;br&gt;
애매한 부분이 있었다.&lt;/p&gt;
&lt;p&gt;아마 &lt;code class=&quot;language-text&quot;&gt;shared&lt;/code&gt; 에 대한 설정이 기본적으로 &lt;code class=&quot;language-text&quot;&gt;version-first&lt;/code&gt; 이기 때문에 실제로는&lt;br&gt;
마지막에 load 한 모듈에서 사용하는 것으로 설정이 된다.&lt;br&gt;
그렇다고 미리 가져온 shared 모듈을 다시 불러온다는 뜻은 아니다.&lt;br&gt;
출처만 변경 된다는 것이다.&lt;/p&gt;
&lt;p&gt;왠만한 경우에서는 큰 문제가 되지 않을 것이다. (또는 eager 를 사용하면 해결은 된다.)&lt;br&gt;
다만 &lt;code class=&quot;language-text&quot;&gt;eager 옵션의 사용은 최대한 자제&lt;/code&gt;하고, 강제적으로 현재 &lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 에서&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt; 을 사용하도록 하기 위해 두개의 package 는&lt;br&gt;
host 에서 가져오도록 강제하는 plugin 을 추가 했다.&lt;/p&gt;
&lt;p&gt;이는 local 에서 개발할때 hmr 적용 시 &lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt; 을 사용하도록 만들고,&lt;br&gt;
배포 된 후에는 최상위 &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;host&lt;/code&gt; 모듈에서 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;react-dom&lt;/code&gt; 을 가져가도록 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    resolveShare(args) {
      if (args.pkgName !== &amp;#39;react&amp;#39; &amp;amp;&amp;amp; args.pkgName !== &amp;#39;react-dom&amp;#39;) {
        return args;
      }

      const {
        shareScopeMap,
        scope,
        pkgName,
        version,
        GlobalFederation } = args;
      const host = GlobalFederation[&amp;#39;__INSTANCES__&amp;#39;][0];

      if (!host) {
        return args;
      }

      args.resolver = function () {
        const hostScope = Array.isArray(host.options.shared[pkgName])
          ? host.options.shared[pkgName][0]
          : host.options.shared[pkgName];

        if (hostScope) {
          shareScopeMap[scope][pkgName][version] = hostScope;
        }

        return shareScopeMap[scope][pkgName][version];
      };

      return args;
    },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;plugin 의 interface 중 &lt;code class=&quot;language-text&quot;&gt;resolveShare&lt;/code&gt; 에서 공유 모듈을 어떤식으로 지정할지에 대한&lt;br&gt;
정의를 해주었다.&lt;/p&gt;
&lt;p&gt;위 plugin 의 기능은 SPA 에서는 없어도 잘 돌아갈수 있으나 일종의 보험 같은 것이다.&lt;/p&gt;
&lt;p&gt;나머지 &lt;code class=&quot;language-text&quot;&gt;remote load&lt;/code&gt; 에 대한 &lt;code class=&quot;language-text&quot;&gt;에러처리&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;초기화&lt;/code&gt;와 관련해서 몇가지를 더 추가해서&lt;br&gt;
federation 이 잘 돌아갈수 있도록 안정성을 높여두었다.&lt;/p&gt;
&lt;h2&gt;module federation dts&lt;/h2&gt;
&lt;p&gt;이번 federation 설정에서 자체적으로 remote 의 &lt;code class=&quot;language-text&quot;&gt;ts type&lt;/code&gt; 을 생성해주는&lt;br&gt;
기능을 포함해서 나왔다. 이전에는 분리되어 있던 plugin 이지만 요즘엔 ts 를 안쓰는 프로젝트를&lt;br&gt;
찾는게 더 힘드니 당연히 포함되서 나온 듯 하다.&lt;/p&gt;
&lt;p&gt;해당 기능으로 인해 remote 로 가져오는 모듈에 대해 ts 의 자동완성 기능을 더 잘 활용할수&lt;br&gt;
있고 자체적으로 d.ts 를 만들 필요가 없어졌다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt; 옵션이라고 개발중에 실시간으로 &lt;code class=&quot;language-text&quot;&gt;tstype&lt;/code&gt; 을 생성해주는 기능이 있는데&lt;br&gt;
현재 &lt;code class=&quot;language-text&quot;&gt;매우 느리기 때문에 사용을 비추&lt;/code&gt;한다.&lt;/p&gt;
&lt;h2&gt;rspack&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 으로의 전환은 그렇게 큰 문제는 있지 않았다.&lt;br&gt;
rspack 에서 webpack 과의 호환성을 워낙 잘 맞춰둔 것도 있고&lt;br&gt;
webpack 에서 했던 여러 설정들이 하나로 합쳐진 부분도 있고 해서 더 간소화 시킬 수 있었다.&lt;/p&gt;
&lt;p&gt;주요 변경점은 &lt;code class=&quot;language-text&quot;&gt;csslodaer&lt;/code&gt; 의 사용변경과 기존에는 &lt;code class=&quot;language-text&quot;&gt;esbuild&lt;/code&gt; 로 빌드하고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;swc&lt;/code&gt; 로 &lt;code class=&quot;language-text&quot;&gt;polyfill&lt;/code&gt; 을 넣어 주고 있었는데 이제는 &lt;code class=&quot;language-text&quot;&gt;swc&lt;/code&gt; 로 통일 되었다는 점?&lt;/p&gt;
&lt;p&gt;나머지 짜잘한 설정들은 시행착오를 겪으며 조금씩 수정하여 모든 모듈을 빌드 버전으로&lt;br&gt;
local 에서 테스트 한뒤 전환을 하였다.&lt;/p&gt;
&lt;p&gt;아마 webpack 관련 설정은 안정화 되면 약 1개월 뒤 삭제 될 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;rspack&lt;/code&gt; 으로 전환 후 결과적으로 빌드 속도가 3배는 빨라진듯하다. &lt;code class=&quot;language-text&quot;&gt;붉은혜성&lt;/code&gt; 같다.&lt;/p&gt;
&lt;h2&gt;추가 변경&lt;/h2&gt;
&lt;p&gt;그외 회사 자체 lib 를 모아둘 패키지를 만들어 버전 관리를 하기 시작하였고&lt;br&gt;
이는 추후 오픈소스로 내보낼수 있다면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;그리고 폴더구조나 명령어삭제,추가 등 조금더 개발을 빠르고 편하게 사용할 수 있도록&lt;br&gt;
변경을 조금 하였다.&lt;/p&gt;
&lt;p&gt;중요한점은&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;변경된 구조와 package 가 적용되는 도중에도&lt;br&gt;
누구도 현재 개발작업에 방해를 받지 않았고&lt;br&gt;
변경된 후에도 이전과 같은 명령어로 똑같이 개발이 가능하다는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;물론 변경된 후 구조나 변경점에 대해 설명은 하였다.&lt;br&gt;
포인트는 이렇게 &lt;code class=&quot;language-text&quot;&gt;대규모 변경을 할때도 하위호환을 유지하는 것&lt;/code&gt;과&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;breaking change 를 최대한 줄이는게 아주 중요&lt;/code&gt;하다는 것이다.&lt;/p&gt;
&lt;p&gt;인원이 많고 연구할 시간이 많은 대기업에서는 모르겠지만,&lt;br&gt;
빠르게 움직여야 하는 기업이나 팀에서는 기존 작업에서 오류가 생기거나&lt;br&gt;
작업에 방해되는 부분이 생기면 많은 부분에서 손실이 클 수 있다.&lt;/p&gt;
&lt;p&gt;어쩔수 없는 부분이 생길수도 있지만 잘 생각해보면 방법은 있을 것이다.🤡&lt;/p&gt;
&lt;h2&gt;회고&lt;/h2&gt;
&lt;p&gt;프로젝트 업그레이드 회고 인데 module federation 에 대한 설명이 많은 것 같다.&lt;br&gt;
그만큼 현재 fe 에서 중요한 부분을 담당하는 기능이기도 해서 그런듯.&lt;br&gt;
더 설명하고 싶은 부분이 많지만 너무 글이 길어질 것 같아서 피곤해서 끝&lt;/p&gt;
&lt;p&gt;궁금점이나 논의 하고 싶은 부분은 언제든지 문의 주길 바란다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[The Programmer's Brain]]></title><description><![CDATA[…]]></description><link>https://willowryu.github.io/2024-06-16/</link><guid isPermaLink="false">https://willowryu.github.io/2024-06-16/</guid><pubDate>Sun, 16 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이번엔 최근에 읽은 책의 후기를 적어보려 한다.&lt;br&gt;
책은  &lt;code class=&quot;language-text&quot;&gt;The Progeammer&apos;s Brain&lt;/code&gt; 이다.  &lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/dc973651deb0d170839d08baae9a1015/70dea/1.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 125.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAYBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAABoM+HsFZIGTnNNc0CQf/EAB4QAAIBBAMBAAAAAAAAAAAAAAECAAMEEyEQETIz/9oACAEBAAEFArZe3ypAQws21gSIoUUvY0JR+3H/xAAVEQEBAAAAAAAAAAAAAAAAAAAQAf/aAAgBAwEBPwEh/8QAFxEBAAMAAAAAAAAAAAAAAAAAEAERIf/aAAgBAgEBPwG9JP/EAB4QAAIBAwUAAAAAAAAAAAAAAAABAhARITEyQXKB/9oACAEBAAY/Ak84aNxdEk/C5aOgkuaw7Kv/xAAfEAACAQQCAwAAAAAAAAAAAAABEQAQITFBYZFRcfD/2gAIAQEAAT8hbowC9zhdx4GIPV4BQHuBvzEcUEdgQA7iB0KfM81//9oADAMBAAIAAwAAABDryTD/xAAWEQEBAQAAAAAAAAAAAAAAAAABESD/2gAIAQMBAT8QCFw//8QAFxEBAQEBAAAAAAAAAAAAAAAAARARIf/aAAgBAgEBPxB0iDs//8QAIBABAAIBBAIDAAAAAAAAAAAAAQARITFRYXEQQYGR8P/aAAgBAQABPxAKSOQxdML1MzS1seeeGVhWVY3Nb1AHsrt3M8IBoRn47fuC6sqHLrMkKsGraSg1UAG3E1n6mzz/AP/Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;book&quot;
        title=&quot;book&quot;
        src=&quot;/static/dc973651deb0d170839d08baae9a1015/1c72d/1.jpg&quot;
        srcset=&quot;/static/dc973651deb0d170839d08baae9a1015/a80bd/1.jpg 148w,
/static/dc973651deb0d170839d08baae9a1015/1c91a/1.jpg 295w,
/static/dc973651deb0d170839d08baae9a1015/1c72d/1.jpg 590w,
/static/dc973651deb0d170839d08baae9a1015/70dea/1.jpg 861w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 책은 인지과학 측면에서 프로그래머가 코드를 보거나 작성할때&lt;br&gt;
어떻게 생각하는지, 어떤 흐름으로 이어지는지에 대한 설명과&lt;br&gt;
효율적으로 코드를 작성하고 생각하는 방법에 대해 설명해주고 있다.    &lt;/p&gt;
&lt;p&gt;너무 과학적인 용어나 설명만 많아서 읽기 어려운 책은 아니고&lt;br&gt;
적절한 코드와 해당 사항에 대한 실험 결과, 예제들을 많이 수록하고 있어&lt;br&gt;
편하게 읽을 수 있었다.  &lt;/p&gt;
&lt;p&gt;책의 내용을 간단하게 소개하면 실제로 프로그래머가 생소한 코드를 봤을때&lt;br&gt;
왜 혼란이 일어나는지, 그리고 어떤 종류의 혼란이 일어나는지에 대해 설명이 되어있다.  &lt;/p&gt;
&lt;p&gt;어찌보면 코드 뿐만 아니라 다양한 환경에서도 똑같이 느낄수 있기도 하겠다. &lt;/p&gt;
&lt;p&gt;이책에서는 크게 3가지의 이유로 혼란이 일어난다고 되어있는데&lt;br&gt;
이는 &lt;code class=&quot;language-text&quot;&gt;지식의 부족&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;정보의 부족&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;처리능력의 부족&lt;/code&gt; 이다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;지식의 부족&lt;/code&gt; 은 말그대로 해당 코드에 대한 지식, 즉 내가 모르는 언어라서&lt;br&gt;
해당 언어의 함수나 기능 자체를 모르는 경우이다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정보의 부족&lt;/code&gt; 은 해당 코드를 읽을 순 있지만 어떤 기능을 하는지 알수가 없을 때다.&lt;br&gt;
javascript 나 Java 등 우리가 익히 알고 있는 코드를 볼때 만약  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  function BinaryCalculator(n: number) {
    return parseInt(n).toString(2);
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 이런식의 코드가 있다면 우리는 코드를 읽을 순 있지만 저 &lt;code class=&quot;language-text&quot;&gt;parseInt&lt;/code&gt; 가&lt;br&gt;
어떤 기능을 하는지, &lt;code class=&quot;language-text&quot;&gt;toString&lt;/code&gt; 이 어떤 기능인지 알수 없다.&lt;br&gt;
이것이 정보의 부족이다.  &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;처리능력의 부족&lt;/code&gt; 은 코드 자체를 천천히 읽으면 이해할 수는 있으나, 머릿속에서&lt;br&gt;
모든 정보를 처리 할 수 없는 경우이다.&lt;br&gt;
이럴땐 변수에 들어가는 값을 따로 메모하거나, 그림으로 적어두기도 한다.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; function whoami(n1) {
    if (n1 === 0) return &amp;quot;0&amp;quot;;
    let n2 = &amp;quot;&amp;quot;;
    while (n1 &amp;gt; 0) {
        n2 = (n1 % 2) + n2;
        n1 = Math.floor(n1 / 2);
    }
    return n2;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 함수를 볼때 코드를 하나씩 읽어가면 어떤 기능인지 알 수 있지만, 처음볼때&lt;br&gt;
이해하기 어렵고 혼란 스러울수 있다.&lt;br&gt;
에제를 위해 변수명과 함수명은 일부러 막 적었다.  &lt;/p&gt;
&lt;p&gt;위 3가지 부족현상을 인지과학 적으로 말하면
&lt;code class=&quot;language-text&quot;&gt;지식의 부족&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt; 의 문제로 이어지고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;정보의 부족&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 의 문제, &lt;code class=&quot;language-text&quot;&gt;처리능력의 부족&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;작업기억 공간의&lt;/code&gt; 문제 가 된다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;Long-term Memory&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;Short-term Memory&lt;/code&gt; 이다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;작업기업 공간&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt; 에서 가져온 지식과 정보를 기반으로&lt;br&gt;
해당 코드를 이해하려 할때 머릿속에서 일어나는 복잡한 작업 과정이라고 볼 수 있다.  &lt;/p&gt;
&lt;p&gt;이 3가지 인지과정은 서로 상호작용하며 머릿속에서 작업이 이루어 지는데&lt;br&gt;
먼저 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 에서 정보를 가져오고, &lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt; 에서는 지식을 가져온다.  &lt;/p&gt;
&lt;p&gt;예를 들어 위 BinaryCalculator 함수를 예를 들면&lt;br&gt;
n 이 정수형이라는 정보는 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 에 저장되고, 동시에 &lt;code class=&quot;language-text&quot;&gt;정수&lt;/code&gt; 라는 개념의 정보는&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt; 에서 가져오게 된다.  &lt;/p&gt;
&lt;p&gt;그리고 이를 기반으로 머릿속에서 코드가 어떤 기능을 하는지 파악하는 일은&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;작업기능 공간&lt;/code&gt;에서 이루어진다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이걸 보면서 &lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt; 은 하드드라이브, &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 은 메모리,&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;작업기억 공간&lt;/code&gt;은 CPU 와 비슷하다고&lt;br&gt;
느낀 사람도 있을 것이다. 어찌보면 비슷해 보이긴 한다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;인간의 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt; 은 한계가 있다고 되어있다.&lt;br&gt;
책에서는 어느정도의 한계가 있는지 그리고 각 사람, 분야마다 &lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt;의 효율이 차이가 나는&lt;br&gt;
이유가 무엇인지 알기위한 실험 결과가 많이 있다.  &lt;/p&gt;
&lt;p&gt;우리가 코드에서 많이 봐온 &lt;code class=&quot;language-text&quot;&gt;청크(Chunk)&lt;/code&gt;라는 개념도 나오며, 이를 활용하는&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;청킹&lt;/code&gt; 작업에 대해서도 나온다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;청킹&lt;/code&gt;은 기억의 조각들을 각각의 그룹으로 묶은 &lt;code class=&quot;language-text&quot;&gt;청크&lt;/code&gt; 상태로 만들어 기억하는 것을&lt;br&gt;
말한다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;보다보면 왜 디자인 패턴이 나오고 발전했으며, 왜 중요한지에 대해 알 수 있다.&lt;br&gt;
그리고 숙련자와 초보자가 코드를 이해하고 읽을때 어떤 부분때문에 차이가 나는지&lt;br&gt;
상세히 알수있다.  &lt;/p&gt;
&lt;p&gt;위 3가지 개념 &lt;code class=&quot;language-text&quot;&gt;LTM&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;STM&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;작업기업공간&lt;/code&gt; 을 가지고&lt;br&gt;
뇌에서 어떤 작업을 하고 있는지, 그리고 코드를 효율적으로 작성하고&lt;br&gt;
이해하기 쉽게 적는 방법에 대해 쭉 나와있다.  &lt;/p&gt;
&lt;p&gt;특히 뒷부분에서는 팀에서의 효율적인 협업 작업과 신규 팀원이 합류했을때&lt;br&gt;
빠르게 회사 코드에 적응시킬수 있는 훈련법도 소개하고 있어 도움이 많이 되었다.  &lt;/p&gt;
&lt;p&gt;적은 예제들은 책의 극초반부에 나오는 내용으로 이외에도 많은 유익한 내용이 있으니&lt;br&gt;
시간이 된다면 한번 읽어 보길 추천하는 책이다.  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[기본 컴포넌트 설계 패턴]]></title><description><![CDATA[…]]></description><link>https://willowryu.github.io/2024-06-04/</link><guid isPermaLink="false">https://willowryu.github.io/2024-06-04/</guid><pubDate>Tue, 04 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;앱을 개발하며 컴포넌트를 만들고 구조를 설계할때 어떤식으로 하면 좋을까&lt;br&gt;
인터넷이나 책에 다양한 방식의 설계 방법이 존재하고 있지만 공통적으로 말하고 있는 부분은&lt;br&gt;
비즈니스 로직을 어디다 둘 것인가, 상태관리를 어떤식으로 할 것 인가에 따라&lt;br&gt;
서비스 설계의 많은 부분이 변경된다.&lt;/p&gt;
&lt;p&gt;물론 리팩토링은 꾸준히 하겠지만 처음 만들때 제대로 정해두지 않으면 팀이 커질수록&lt;br&gt;
서비스 유지보수에 많은 어려움이 생기고 DX에 악영향을 끼칠수 있다.&lt;/p&gt;
&lt;p&gt;시중에 나와있는 다양한 패턴을 다 설명하는 것 보다 기본적으로 컴포넌트를 만들때&lt;br&gt;
요정도의 지식을 알고 있다면 추후 서비스를 개발할때 처음부터 헤메는 일은 없을 것 이라 본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;모든 코드는 React 기준으로 작성되어있다.&lt;br&gt;
다만 단순히 컴포넌트의 구축 방향을 보기 때문에&lt;br&gt;
타 UI 프레임워크 에서도 응용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;가장 기본적이고 먼저 볼 부분은 &lt;code class=&quot;language-text&quot;&gt;Statless&lt;/code&gt; 컴포넌트 다.&lt;br&gt;
말 그대로 이 컴포넌트는 상태를 가지고 있지 않고 오로지 UI 에 집중되어 있다.&lt;/p&gt;
&lt;p&gt;예를 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface CountControlProps {
  control: {
    increment: () =&amp;gt; void;
    decrement: () =&amp;gt; void;
    reset: () =&amp;gt; void;
  }
  count: number
}

export function CountControl({ control, count = 0 }: CountControlProps) {
  const { increment, decrement, reset } = control;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;button onClick={increment} type=&amp;quot;button&amp;quot;&amp;gt;
        Increment
      &amp;lt;/button&amp;gt;
      &amp;lt;button onClick={decrement} type=&amp;quot;button&amp;quot;&amp;gt;
        Decrement
      &amp;lt;/button&amp;gt;
      &amp;lt;button onClick={reset} type=&amp;quot;button&amp;quot;&amp;gt;
        Reset
      &amp;lt;/button&amp;gt;
      &amp;lt;p&amp;gt;count: {count}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;내부에서는 별도의 상태를 가지지 않고 외부에서 모든 &lt;code class=&quot;language-text&quot;&gt;state&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;control&lt;/code&gt; 을 주입받는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Statless&lt;/code&gt; 장점은 일단 의존하는 부분이 없기 때문에 &lt;code class=&quot;language-text&quot;&gt;재사용성이 매우 높고&lt;/code&gt;&lt;br&gt;
모든 것이 외부 입력에 의해 컨트롤 되므로 &lt;code class=&quot;language-text&quot;&gt;테스트 하기가 쉽다&lt;/code&gt;.&lt;br&gt;
아마 디자인 시스템의 대부분 UI 컴포넌트에서 사용될 것이다.&lt;/p&gt;
&lt;p&gt;다음으로 볼 컴포넌트는 &lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 컴포넌트다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Statless&lt;/code&gt; 와 다르게 &lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 은 컴포넌트가 로컬 State 와 로직을 가지고 있다.&lt;br&gt;
위 CountControl 컴포넌트를 &lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 로 변경하면 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function CountControl() {
  const [conut, setCount] = useState&amp;lt;number&amp;gt;(0);
  const control = {
    increment: () =&amp;gt; setCount(count + 1),
    decrement: () =&amp;gt; setCount(count - 1),
    reset: () =&amp;gt; setCount(0),
  }

  const { increment, decrement, reset } = control

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;button onClick={increment} type=&amp;quot;button&amp;quot;&amp;gt;
        Increment
      &amp;lt;/button&amp;gt;
      &amp;lt;button onClick={decrement} type=&amp;quot;button&amp;quot;&amp;gt;
        Decrement
      &amp;lt;/button&amp;gt;
      &amp;lt;button onClick={reset} type=&amp;quot;button&amp;quot;&amp;gt;
        Reset
      &amp;lt;/button&amp;gt;
      &amp;lt;p&amp;gt;count: {count}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 은 로컬 State 를 가지며, 자체적으로 State 를 컨트롤한다.&lt;br&gt;
당연히 외부 주입도 없고, 의존성도 없으며 local state 로 작동하기 때문에&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Stateless&lt;/code&gt; 와 같이 &lt;code class=&quot;language-text&quot;&gt;재사용성이 매우 높으며&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;테스트 하기 쉽다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 은 주로 디자인 컴포넌트에서 상태가 필요한 컴포넌트들&lt;br&gt;
토글바나 다이얼로그, 메뉴 등에 사용된다.&lt;/p&gt;
&lt;h2&gt;Domain 과 합체&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Presentatin&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;Domain&lt;/code&gt; 을 분리하여 만드는 패턴이다.&lt;br&gt;
아마 &lt;code class=&quot;language-text&quot;&gt;Container&lt;/code&gt; 라고 불리는 컴포넌트 들이 여기 해당된다.&lt;/p&gt;
&lt;p&gt;이때부터는 컴포넌트가 외부 상태와 느슨한 결합이 생기며, 의존성을 가지게 된다.&lt;br&gt;
예를 들어 서버에서 현재 사용자들을 불러온다고 해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// UserListControl

export const useUserListControl = () =&amp;gt; {
  const getUsers: Promise&amp;lt;UserModel[]&amp;gt; = async () =&amp;gt; {
    const res = await fetch(&amp;quot;https://jsonplaceholder.typicode.com/comments&amp;quot;).then((res) =&amp;gt; res.json);
    return res;
  }

  return {
    getUsers
  }
}

// Container
export function UserListContainer() {
  const [users, setUsers] = useState&amp;lt;UserModel[]&amp;gt;();
  const [isLoading, setLoading] = useState&amp;lt;boolean&amp;gt;(true);

  const { getUsers } = useUserListControl();

  const getUserList = async () =&amp;gt; {
    const userList = await getUsers();
    setUsers(userList);
    setLoading(false);
  }

  useEffect(() =&amp;gt; {
    getUserList();
  }, []);

  if (isLoading) {
    return &amp;lt;div&amp;gt;Loading&amp;lt;/div&amp;gt;;
  }

  if (!users) {
    return &amp;lt;div&amp;gt;No data&amp;lt;/div&amp;gt;;
  }

  return (
    &amp;lt;div&amp;gt;
      {users.map((user) =&amp;gt; (
        // User 는 Statelss Component 라고 생각하자
        &amp;lt;User user={user} key={user.id}&amp;gt;
      ))}
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;정의된 fetch 는 크게 신경쓰지 말자. 임의로 만든것들이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아주 간단한 예제이지만 여기서 &lt;code class=&quot;language-text&quot;&gt;useUserListControl&lt;/code&gt; 은 도메인 로직이며,&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;UserListContainer&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;Stateful&lt;/code&gt; 컴포넌트 이면서 내부에서 도메인로직을&lt;br&gt;
부르기 때문에 도메인 로직과 의존성이 생겼다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;UserListContainer&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;UI 로직에 대한 책임&lt;/code&gt;을 가지고, 도메인과 관련된&lt;br&gt;
비즈니스 로직에 대한 책임은 &lt;code class=&quot;language-text&quot;&gt;useUserListControl&lt;/code&gt; 훅(또는 서비스)으로 위임했다.&lt;/p&gt;
&lt;p&gt;이런식으로 &lt;code class=&quot;language-text&quot;&gt;DomainSide &amp;lt;-&gt; PresentationSide&lt;/code&gt; 로 확실히 분리시켜 두면&lt;br&gt;
코드를 이해하기 더 쉬울뿐만 아니라 UI 테스트와 비즈니스 로직의 테스트를 용이하게&lt;br&gt;
만들어준다.&lt;/p&gt;
&lt;p&gt;하지만 우리가 아는 실제 서비스들은 훨씬 복잡하겠지?&lt;/p&gt;
&lt;p&gt;실제로 위 방식은 비교적 간단한 Container 에서 사용하게 되고&lt;br&gt;
Depth가 깊어짐에 따라 더욱더 많은 상태를 조작하거나 추가 메소드가 필요해진다.&lt;/p&gt;
&lt;p&gt;여기서 CQS 를 결합할 수 있다.&lt;br&gt;
CQS 는 &lt;code class=&quot;language-text&quot;&gt;Command Query Separation&lt;/code&gt; 즉 읽기와 쓰기를 명확히 분리하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/af60fd6c03e1d740419f1752f65dec4b/5a6dd/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiUlEQVQoz6VSy07CQBTtP7n0J/wOt36FkYWuSViQACZGXq0S2NHERExsMVRSSu3DQitBHm0xpS3l2I6BBCFunOTOzJ2cOfeeM0PhH2O9Xu+dUb1eD6VSCeVyGZVKBdVqFY1GA4VCAcViERzHoVarIZ/PEwxN02QviiIhiKJoS54E1el0kEqlkE6nCUkmkyGXcrkcstksGIaBIAhQVRWDwQCj0Yisruse7JTSdQ23xRuwbDMOFvV6HfP5HEEQkOphGB6UFtPExAY8z9vt8C+PfN/fStoZ8ZEz96G8/XS94+HoU8VD9wq61cZs6sTSFAKSZRnNZhM8z5N8OBxCkiRo6jtelGu0+pd45loxXotVBFgsFqQ41Xg6R1k8Qr19hvGHDdueEcmO42C5XBJgktu2jclkiv5bF8zrCWjpGLzIYDJ2YVkmdF0n9lCy8Yh7/hSCcoeuIEHVlBhgwTAM8pIJ0DRN0mGyfi08cHIerHABx53tf5tkCvx901erFSHZmP7bwyjE9ttsHiSJb9ktl43EteSKAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;CQS&quot;
        title=&quot;CQS&quot;
        src=&quot;/static/af60fd6c03e1d740419f1752f65dec4b/fcda8/1.png&quot;
        srcset=&quot;/static/af60fd6c03e1d740419f1752f65dec4b/12f09/1.png 148w,
/static/af60fd6c03e1d740419f1752f65dec4b/e4a3f/1.png 295w,
/static/af60fd6c03e1d740419f1752f65dec4b/fcda8/1.png 590w,
/static/af60fd6c03e1d740419f1752f65dec4b/5a6dd/1.png 802w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;해당 패턴을 적용할때 주의할 점은 실제로 State 가 변경될때 자동으로 전파가 되어야 하며,&lt;br&gt;
해당 State 를 사용하는 &lt;code class=&quot;language-text&quot;&gt;Usecase&lt;/code&gt; 한테는 동일하게 공유되어야 한다는 것이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;code class=&quot;language-text&quot;&gt;ObservableState&lt;/code&gt; 를 만들어야 하는데, 적용 가능한 방법은&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Signal&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;rxjs&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;Relay&lt;/code&gt; 나 &lt;code class=&quot;language-text&quot;&gt;Apollo client&lt;/code&gt; 로 graphql 을 활용하는 방법 등이&lt;br&gt;
있겠다.&lt;br&gt;
아니면 상태관리 패키지를 사용해도 되고.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gql 을 사용하면 이런 패턴의 상당 부분을 압축 할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일단 여기서는 대중적인? &lt;code class=&quot;language-text&quot;&gt;Rxjs&lt;/code&gt; 로 작성을 해보겠다.&lt;br&gt;
간단한 TODO List 를 만든다고 생각해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import type { Observable } from &amp;#39;rxjs&amp;#39;;
import { BehaviorSubject, map } from &amp;#39;rxjs&amp;#39;;

type Todo = {
  id: number;
  title: string;
  completed: boolean;
};

export const TodoListStateService = () =&amp;gt; {
  const todos$ = new BehaviorSubject&amp;lt;Todo[]&amp;gt;([
    {
      id: 1,
      title: &amp;#39;first todo&amp;#39;,
      completed: false,
    },
  ]);

  const addTodo = (title: string) =&amp;gt; todos$.next([...todos$.value, {
    id: todos$.value + 1,
    title,
    completed: false,
  }]);

  const toggleCompleted = (id: Todo[&amp;#39;id&amp;#39;], completed: boolean) =&amp;gt; {
    todos$.next(todos$.value.map((todo) =&amp;gt; (todo.id === id ? { ...todo, completed } : todo)));
  };

  return {
    todos$: todos$.asObservable(),
    toggleCompleted,
    addTodo,
  } as const;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;간단하게 만든 TodoState 다.&lt;/p&gt;
&lt;p&gt;해당 서비스는 Todo 라는 State 의 상태를 관리하고&lt;br&gt;
업데이트 한다. 사실 react 와 조금 어울리지 않지만 일단 특정 State 의 상태를 책임지는&lt;br&gt;
서비스를 만들었다고 생각하자.&lt;/p&gt;
&lt;p&gt;그리고 해당 서비스를 이용한 Usecases 를 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; export const TodoListUsecase {
   const { todos$, toggleCompleted, addTodo } = TodoListStateService();


    // useObservableState 는 실제로 Observalbe 을 구독해
    // useState 에 저장하는 유틸함수라고 생각하자.

   const todoList = useObservableState({
     obs: todos$
   });

   const inCompletedTodoList = useMemo(() =&amp;gt; {
    return todoList.filter((todo) =&amp;gt; !todo.completed)
   }, [todoList]);

   const CompletedTodoList = useMemo(() =&amp;gt; {
    return todoList.filter((todo) =&amp;gt; todo.completed)
   }, [todoList]);

   const addTodoItem = (title: string) =&amp;gt; {
     addTodo(title);
   }

   const addTodoIfNotExist = (title: string) =&amp;gt; {
     const alreadyExists = todos.find((todo) =&amp;gt; todo.title === title);
     if (alreadyExists) {
        return;
     }
     addTodoItem(title);
   }

   const toggleTodoCompleted = (id: Todo[&amp;#39;id&amp;#39;], completed: boolean) =&amp;gt; {
     toggleCompleted(id, completed);
   }

   // 임의로 query 와 command 를 나눴다.
   return {
      query: {
        todoList,
        inCompletedTodoList,
        CompletedTodoList,
      },
      command: {
        addTodoItem,
        addTodoIfNotExist,
        toggleTodoCompleted
      }
   }
 }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 컴포넌트는 &lt;code class=&quot;language-text&quot;&gt;Usecase&lt;/code&gt; 에 의존하게 되며 TodoList 의 State 를 읽어오는 것과&lt;br&gt;
변경하는 명령어 역시 전부 &lt;code class=&quot;language-text&quot;&gt;Usecase&lt;/code&gt; 를 통해 이루어진다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Usecase&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;StateService&lt;/code&gt; 에 의존해 실제 state 를 변경하기전 추가적인 메소드와&lt;br&gt;
state 를 제공하며 &lt;code class=&quot;language-text&quot;&gt;Usecase&lt;/code&gt; 레이어의 주요목적은 &lt;code class=&quot;language-text&quot;&gt;StateService&lt;/code&gt;를 은폐하기 위함이다.&lt;/p&gt;
&lt;p&gt;도메인과 직접 연결되는 부분에 복잡한 로직과 메소드가 계속 추가 된다면 이해하기도 힘들어지고&lt;br&gt;
특정 메소드의 테스트에도 많은 부하가 생길 수 있다.&lt;br&gt;
알수없는 사이드 이펙트는 덤.&lt;/p&gt;
&lt;p&gt;추가로 &lt;code class=&quot;language-text&quot;&gt;확장성&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;재사용성&lt;/code&gt; 그리고 &lt;code class=&quot;language-text&quot;&gt;테스트 용이성&lt;/code&gt;을 위해 관심사를 확실히 분리한 것이다.&lt;br&gt;
해당 장점들은 왜 장점이 되는지 잘 생각해보자.&lt;/p&gt;
&lt;p&gt;이렇게 하면 도메인 테스트와 도메인 데이터를 이용한 조회,변경 테스트를 하기가 용이하다.&lt;/p&gt;
&lt;p&gt;추가로 &lt;code class=&quot;language-text&quot;&gt;CQS&lt;/code&gt; 원칙을 사용해 &lt;code class=&quot;language-text&quot;&gt;read&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;write&lt;/code&gt; 를 명확하게 분리하여 &lt;code class=&quot;language-text&quot;&gt;query/command&lt;/code&gt;를&lt;br&gt;
구분하기 쉽고 &lt;code class=&quot;language-text&quot;&gt;Query&lt;/code&gt;는 오로지 read 만 담당하기 때문에 혹시 모를 사이드 이펙트가&lt;br&gt;
생기지 않는다.&lt;/p&gt;
&lt;p&gt;그리고 문제가 생겼을 경우 &lt;code class=&quot;language-text&quot;&gt;Query&lt;/code&gt; 인지 &lt;code class=&quot;language-text&quot;&gt;Command&lt;/code&gt; 인지 디버깅 하기가 쉬워진다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  export function UserListContainer() {
    const { query } = TodoListUsecase();

    return (
      &amp;lt;div&amp;gt;
        {query.todoList.map((todo) =&amp;gt; &amp;lt;TodoItem key={todo.id} todo={todo}&amp;gt;)}
        &amp;lt;p&amp;gt;{query.inCompletedTodoList.length}&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function TodoInput() {
  const { command } = TodoListUsecase()
  const [title, setTitle] = useState&amp;lt;string&amp;gt;(&amp;quot;&amp;quot;);

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;input value={title} onChange={e =&amp;gt; setTitle(e.target.value)} /&amp;gt;
      &amp;lt;button type=&amp;quot;button&amp;quot; onClick={() =&amp;gt; command.addTodoItem(title)}&amp;gt;
        Add
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;사용한다면 대충 이런식으로 사용하지 않을까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;대략적으로 막 적은 코드라 오타나 type 오류가 있을 수 있다.&lt;br&gt;
그냥 흐름만 보자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위 코드들은 정말 기본적으로 막 사용한 것들이고 추가로 유명한 상태관리 패키지나&lt;br&gt;
다른 방식으로 충분히 더 훌륭하게 발전 시킬수 있을 것이다.&lt;/p&gt;
&lt;p&gt;위에 적기도 했지만 graphql 을 사용하고 있다면 위 패턴을&lt;br&gt;
더욱 짧고 쉽게 압축해서 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;워낙 요즘 패키지들이 이런 부분을 잘 지원해줘서 개념만 잘 익히고, 실제로 본인이 적용해보며&lt;br&gt;
이것저것 고쳐 보는게 좋을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고한 사이트들&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://martinfowler.com/bliki/CommandQuerySeparation.html&quot;&gt;CommandQuerySeparation&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://martinfowler.com/bliki/PresentationDomainSeparation.html&quot;&gt;PresentationDomainSeparation&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://www.apollographql.com/blog/client-side-architecture-basics&quot;&gt;ApolloClient&amp;#x26;client-side-architecture-basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;들어가서 한번씩 읽어보면 좋은 글들이다.&lt;br&gt;
시간이 된다면 꼭 읽어보자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[The New Generation of JavaScript]]></title><description><![CDATA[JS 는 간단한 장남감? 같은 언어로 시작하여 이렇게 큰 생태계를 가진 정말 대단한? 언어이다. 1997년 부터 약 2007년 까지 ES…]]></description><link>https://willowryu.github.io/2024-05-18/</link><guid isPermaLink="false">https://willowryu.github.io/2024-05-18/</guid><pubDate>Sat, 18 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JS 는 간단한 장남감? 같은 언어로 시작하여 이렇게 큰 생태계를 가진&lt;br&gt;
정말 대단한? 언어이다.&lt;/p&gt;
&lt;p&gt;1997년 부터 약 2007년 까지 ES4 까지의 진화를 거치며 그때 당시 주류에 있던&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;flash&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;actionScript&lt;/code&gt; 와 경쟁하며 승리해 왔다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ES5&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;NPM&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;NODE&lt;/code&gt; 가 활용되면서 급속도로 확장되던 생태계에&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Angular&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Vue&lt;/code&gt; 와 같은 UI 도구의 등장,&lt;br&gt;
그리고 2019 년에는 &lt;code class=&quot;language-text&quot;&gt;Svelt&lt;/code&gt; 와 같은 컴파일러 우선 프레임워크가 등장했다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Typescript&lt;/code&gt; 는 Javascript 를 완전히 잡아먹어 더욱 강하게 만들었으며,&lt;br&gt;
이제는 Mobile 과 Desktop 까지 확장되었고, JS 가 침투하지 않은 구간을&lt;br&gt;
찾기 힘든 판국이다.&lt;/p&gt;
&lt;p&gt;활용도가 높고 여기저기 많이 쓰이고 있다는 알겠는데,&lt;br&gt;
현재 생태계에서 쓰이는 JS 도구들을 잘 뜯어보면 특이점을 찾아 볼 수 있다.&lt;/p&gt;
&lt;p&gt;JS 의 도구들은 점진적으로 채택되고 변화해왔다.&lt;br&gt;
변화 한다는 건 개발자들의 DX에 더 좋은 경험을 준다던가, 최적화가 더 잘되었다던가&lt;br&gt;
메모리 사용량의 변화, 또는 속도와 관련된 업데이트 등이 있다.&lt;/p&gt;
&lt;p&gt;현재 JS 도구 중 널리 쓰이는 중요한 도구들을 살펴보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack -&gt; &lt;code class=&quot;language-text&quot;&gt;Vite&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Rspack&lt;/code&gt;&lt;br&gt;
babel -&gt; &lt;code class=&quot;language-text&quot;&gt;SWC&lt;/code&gt;&lt;br&gt;
Jest -&gt; &lt;code class=&quot;language-text&quot;&gt;vitest&lt;/code&gt;&lt;br&gt;
eslint -&gt; &lt;code class=&quot;language-text&quot;&gt;rslint&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;oxlint&lt;/code&gt;&lt;br&gt;
node -&gt; &lt;code class=&quot;language-text&quot;&gt;deno&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;bun&lt;/code&gt;&lt;br&gt;
prettier -&gt; &lt;code class=&quot;language-text&quot;&gt;dprint&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그외 monorepo 를 위한 &lt;code class=&quot;language-text&quot;&gt;turborepo&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nx&lt;/code&gt; 등이 있고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;biome&lt;/code&gt; 같은 formatter 도 있다.&lt;/p&gt;
&lt;p&gt;아마 아직 주류로 쓰이는 도구가 아닌 것도 있겠지만&lt;br&gt;
어쨋든 도구들은 점진적으로 더나은 방향으로 이동하고 있다.&lt;/p&gt;
&lt;p&gt;그럼 이제 해당 도구들의 변화를 봤을때 특이점이 보이는가?&lt;/p&gt;
&lt;p&gt;그들은 JS로 만들지 않은 JS 도구 들이다.&lt;br&gt;
대다수 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt;로 개발되었으며, 그외 &lt;code class=&quot;language-text&quot;&gt;Go&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Zig&lt;/code&gt; 가 포함되어 있다.&lt;/p&gt;
&lt;p&gt;JS 의 핵심도구들은 점점 JS 에서 떠나고 있다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;ES4&lt;/code&gt; 까지가 1세대, &lt;code class=&quot;language-text&quot;&gt;ES5 ~ 6&lt;/code&gt; 나오며 2세대가 되었다.&lt;br&gt;
이때 지금도 주류로 쓰이는 대다수 도구들이 나오게되며 JS의 가장 큰 부흥을 가져왔다.&lt;br&gt;
그리고 JS가 아닌 JS 도구들을 활용하는 새로운 3세대가 왔다.&lt;/p&gt;
&lt;p&gt;JS가 아닌 JS 도구들.&lt;br&gt;
이렇게 된 가장 큰 이유는 결국 성능으로 귀결된다.&lt;br&gt;
더작은 번들 사이즈, 더 빠른 속도, 더 빠른 빌드를 위해 결국 핵심 도구들은&lt;br&gt;
결국 JS 를 버릴수 밖에 없었다.&lt;/p&gt;
&lt;p&gt;그럼 JS 외 언어를 배워야 하나?&lt;br&gt;
배워두면 좋다. 배워서 나쁠건 없다.&lt;/p&gt;
&lt;p&gt;다만 &lt;code class=&quot;language-text&quot;&gt;성능&lt;/code&gt; 보다 &lt;code class=&quot;language-text&quot;&gt;접근성&lt;/code&gt;이 중요하다면 여전히 JS 또는 TS 로 개발은 계속 될 것이다.아마.&lt;br&gt;
접근성이 중요한 부분은 아마 UI 프레임워크를 이용한 개발이 되지 않을까?&lt;/p&gt;
&lt;p&gt;핵심도구들의 발전에 기여하고 싶다면 위 언급한 &lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 같은 언어를 배워두면 좋지만&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Rust&lt;/code&gt; 는 러닝커브가 꽤 높은 편이다.&lt;/p&gt;
&lt;p&gt;JS를 주로 활용한 UI 도구의 발전도 만만치 않고 그들을 익히고 응용하는데도 시간을&lt;br&gt;
많이 쏟아야 할 것 이다.&lt;br&gt;
왜냐면 우리의 일자리와 가장 많이 직결된 부분이기 때문이다.&lt;br&gt;
대부분의 사람들에게 직장은 중요하니깐 나역시도 🥲&lt;/p&gt;
&lt;p&gt;추가로 생각보다 주춤한 &lt;code class=&quot;language-text&quot;&gt;WASM&lt;/code&gt; 역시 큰 잠재력을 가지고 JS의 자리를 위협하고 있다.&lt;br&gt;
그리고 Flutter 를 내세운 &lt;code class=&quot;language-text&quot;&gt;Dart&lt;/code&gt; 도 존재하고.&lt;/p&gt;
&lt;p&gt;이런 생태계를 살펴보면 fe 에 입문한 사람들 또는 이제 어느정도 익숙해진 사람들은&lt;br&gt;
어떤걸 공부해야 하고 어떻게 가야 할지 혼란스러울 수 있다.&lt;/p&gt;
&lt;p&gt;워낙 많은 양의 내용과 기술들이 쏟아져 나오고, 추가로 이제는 &lt;code class=&quot;language-text&quot;&gt;A.I&lt;/code&gt;로 인한 로봇과의&lt;br&gt;
협력도 생각해야 한다.&lt;/p&gt;
&lt;p&gt;이제는 예전처럼 한개라도 잘하자는 마음가짐으로는 이런 생태계에서&lt;br&gt;
살아남기 힘들수도? 있다.&lt;/p&gt;
&lt;p&gt;모든 걸 공부할 필요는 없지만 알고는 있어야 한다.&lt;br&gt;
존재한다는 걸 알아야 선택지가 많아지고 응용할 수 있는 길이 많아질테니&lt;/p&gt;
&lt;p&gt;그래서 최신 기술의 트렌드나 변화와 관련된 뉴스레터 또는 유튜브를&lt;br&gt;
구독하고 살펴보기를 권장한다.&lt;/p&gt;
&lt;p&gt;살펴봐야 할 부분이 늘어난 부분도 있지만 기술의 발전으로 인해 장점도 굉장히 많다.&lt;br&gt;
메타프레임워크 의 활성화와 &lt;code class=&quot;language-text&quot;&gt;Vercel&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Netlify&lt;/code&gt; 와 같은&lt;br&gt;
CI/CD, CDN 의 통합서비스 제공업체들,&lt;br&gt;
그리고 클라우드 플랫폼의 발전 등으로 인해 이전에 비해 개발하기 너무 편해진건 또 장점이다.&lt;/p&gt;
&lt;p&gt;엔지니어적인 발상보다 현실세상에서 발휘할수 있는 창의적인 아이디어가 있다면&lt;br&gt;
이를 세상에 표현할 수 있는 방법도 쉬워졌다는 것이다.&lt;br&gt;
그뒤에도 당연히 많은 노력이 필요하지만 그래도 짐이 점점 덜어지니 이또한 좋다.&lt;/p&gt;
&lt;p&gt;적다보니 글의 흐름이 마음대로 갔는데 내 블로그는 원래그렇다.&lt;br&gt;
여튼 잘 살아남자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JS Quiz]]></title><description><![CDATA[원래 주제는 다른 글 이지만, 본론을 올리기 전 간단하게 JS Quiz 를 보며 refresh 를 해보자. Quiz.1 해당 console.log 의 output 을 어떤값일까? . . . . . . . . . . . . . . . . . Quiz…]]></description><link>https://willowryu.github.io/2024-05-13/</link><guid isPermaLink="false">https://willowryu.github.io/2024-05-13/</guid><pubDate>Tue, 14 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;원래 주제는 다른 글 이지만, 본론을 올리기 전 간단하게 JS Quiz 를 보며&lt;br&gt;
refresh 를 해보자.&lt;/p&gt;
&lt;h2&gt;Quiz.1&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(018 - 015)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
NaN
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
3
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
5
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
13
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 1 해설&lt;/h4&gt;
&lt;p&gt;다양한 생각이 있겠지만 JS 에서는 앞에 0이 붙으면 &lt;code class=&quot;language-text&quot;&gt;Oct(8진수)&lt;/code&gt; 로 계산이 된다.&lt;br&gt;
8진수는 각자리에서 8의 거듭제곱을 곱하고, 그 결과를 다 더해야 한다.&lt;/p&gt;
&lt;p&gt;이제 각 값을 10진수로 변환하면?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;018 은 8진수로 나타낼수 없다. 8진수는 0~7로만 이루어져 있다.&lt;br&gt;
결국 018 은 10진수 18이 된다.&lt;/li&gt;
&lt;li&gt;015 는 8진수로 변환시 각 자리에 8의 거듭제곱을 곱한 뒤 더하면 0 + 8 + 5 = 13 이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 각 결과를 더하면 18 - 13, 즉 정답은 5가 된다.&lt;br&gt;
답은 &lt;code class=&quot;language-text&quot;&gt;3번&lt;/code&gt;이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;js 에서 &lt;code class=&quot;language-text&quot;&gt;strict mode&lt;/code&gt; 일때는 0을 붙였을시 표기 오류가 난다.&lt;br&gt;
그때는 &lt;code class=&quot;language-text&quot;&gt;0o&lt;/code&gt;를 붙여 8진수를 표현 할수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Quiz. 2&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(typeof typeof 1)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
string
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
number
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
1
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
true
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 2 해설&lt;/h4&gt;
&lt;p&gt;이 어느정도 JS 를 해봤다면 아주 쉬울 것이다.&lt;br&gt;
JS 의 &lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 는 주어진 변수의 데이터 타입을 string 형식으로 반환하게 된다.&lt;/p&gt;
&lt;p&gt;그럼 해당 문제를 하나씩 뜯어보면 &lt;code class=&quot;language-text&quot;&gt;typeof 1&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;&quot;number&quot;&lt;/code&gt; 가 나오게 되고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;typeof &quot;number&quot;&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;&quot;string&quot;&lt;/code&gt; 이 된다.&lt;/p&gt;
&lt;p&gt;답은 &lt;code class=&quot;language-text&quot;&gt;1번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h2&gt;Quiz. 3&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const numbers = [33, 2, 8]
numbers.sort()
console.log(numbers[1])&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
33
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
2
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
8
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
1
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 3 해설&lt;/h4&gt;
&lt;p&gt;이 문제를 못 맞춘다면…&lt;br&gt;
Js를 다뤄봤다면 아주 쉬운 문제이다.&lt;/p&gt;
&lt;p&gt;정답은 &lt;code class=&quot;language-text&quot;&gt;1번&lt;/code&gt; 이다.&lt;br&gt;
해설은 따로 없다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Js 에서 sort 는 요소들을 문자열로 변경하여 정렬한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Quiz. 4&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(false == &amp;quot;0&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
false
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
true
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 4 해설&lt;/h4&gt;
&lt;p&gt;여기는 약간 헷갈릴수 있다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 의 차이를 생각하고 진행사항을 보자.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;==&lt;/code&gt; 는 값을 비교할때 자동으로 두 값의 형변환을 진행하게 된다.&lt;br&gt;
Number(false) 는 0 으로 변환되어 &lt;code class=&quot;language-text&quot;&gt;0 == &quot;0&quot;&lt;/code&gt; 이 된다.&lt;br&gt;
여기서 &lt;code class=&quot;language-text&quot;&gt;&quot;0&quot;&lt;/code&gt; 은 다시 형변환 되어 &lt;code class=&quot;language-text&quot;&gt;Number(&quot;0&quot;)&lt;/code&gt; 즉 0 이 된다.&lt;/p&gt;
&lt;p&gt;결론적으로 &lt;code class=&quot;language-text&quot;&gt;0 == 0&lt;/code&gt;이 되므로 결과값은 true 로 나오게 된다.&lt;br&gt;
답은 &lt;code class=&quot;language-text&quot;&gt;2번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 &lt;code class=&quot;language-text&quot;&gt;===&lt;/code&gt; 으로 비교한다면 값과 함께 유형검사도 하기 때문에 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 가 나온다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Quiz. 5&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(0.1 + 0.2 == 0.3)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
false
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
true
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 5 해설&lt;/h4&gt;
&lt;p&gt;이건 유명한 문제이며 원인은 부동소수점 숫자를 표현하는 데 &lt;code class=&quot;language-text&quot;&gt;IEEE 754&lt;/code&gt; 표준을 사용하기 때문이다.&lt;br&gt;
JS만 그렇지 않고 많은 언어들이 이를 따르고 있다.&lt;br&gt;
이 표준은 실수를 2진수로 정확히 표현하지 못하기 때문에 최대한 그에 근접한 값으로 변환하여 사용한다.&lt;/p&gt;
&lt;p&gt;그래서 0.1 + 0.2 는 0.3 이 아니고 (ex 0.30000000000004) 약간의 차이가 생기게 된다.&lt;br&gt;
하여 정답은 &lt;code class=&quot;language-text&quot;&gt;1번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JS 에서 이런 부분을 막기 위한 방법 중 한나로 &lt;code class=&quot;language-text&quot;&gt;Number.EPSILON&lt;/code&gt;을 활용하는 방법이 있다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Number.EPSILON&lt;/code&gt; 은 2의 -52승 의 값을 나타낸다.
해당 공식의 결과가 EPSILON 보다 작다면 이는 true 로 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Quiz. 6&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let array = [1, 2, 3]
array[6] = 9
console.log(array[5])&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
1
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
2
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
9
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
undefined
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz 6 해설&lt;/h4&gt;
&lt;p&gt;Js 에서 Array의 length 를 벗어나는 position 에 값을 할당할 경우&lt;br&gt;
Js 는 자동으로 빈부분을 채우게 된다.&lt;br&gt;
당연히 값이 없으니 undefined 로 채워지게 되고&lt;br&gt;
답은 &lt;code class=&quot;language-text&quot;&gt;4번&lt;/code&gt; 이 된다.&lt;/p&gt;
&lt;h2&gt;Quiz. 7&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const isTrue = true == []
const isFalse = true == ![]

console.log(isTrue + isFalse)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
1
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
0
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
&quot;true&quot;
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
true
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz. 7 해설&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;const isTrue&lt;/code&gt; 를 살펴보면&lt;br&gt;
빈배열은 형변환이 되며 ”[]” 이건 &quot;&quot; 이렇게 빈문자열로 변환된다.&lt;br&gt;
그리고 true 역시 형변환이 되며 true 는 숫자 1 이 된다.&lt;/p&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;1 == &quot;&quot;&lt;/code&gt; 이런식으로 되었는데 빈문자열은 false, 즉 형변환을 하게 되면 숫자 0이 된다.&lt;br&gt;
결국 &lt;code class=&quot;language-text&quot;&gt;1 == 0&lt;/code&gt; 이 되므로 isTrue 의 값은 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;const isFalse&lt;/code&gt; 를 살펴보면&lt;br&gt;
![] 이부분은 Js 에서 기본적으로 빈배열은 truthy 값으로 평가 되기 때문에&lt;br&gt;
true 를 ! 로 논리 부정을 적용하면 false 가 된다.&lt;/p&gt;
&lt;p&gt;false 는 형변환으로 숫자 0이 되고,&lt;br&gt;
true 는 위와 같이 숫자 1로 변환되기 때문에 결국 &lt;code class=&quot;language-text&quot;&gt;1 == 0&lt;/code&gt; 이 되고&lt;br&gt;
값은 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;p&gt;결국 isTrue 도 false 고 isFalse 도 false 가 되고,
isTrue + isFalse 는 false + false 가 되고 형변환이 이뤄지면&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;0 + 0&lt;/code&gt; 즉 결과는 0이 나오게 된다.&lt;/p&gt;
&lt;p&gt;정답은 &lt;code class=&quot;language-text&quot;&gt;2번&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Quiz. 8&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(1 + &amp;quot;2&amp;quot; + &amp;quot;2&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
122
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
32
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
NaN2
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
NaN
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz. 8 해설&lt;/h4&gt;
&lt;p&gt;Js 에서 ”+” operator 는 왼쪽에서 오른쪽으로 형변환을 시도하게 된다.&lt;br&gt;
1 + “2” 라는 건 “2” 의 타입이 string 이기 때문에 1은 “1” 로 변환되고&lt;br&gt;
결국 “1” + “2” 는 “12” 가 된다.&lt;/p&gt;
&lt;p&gt;여기서 “12” + “2” 를 하게 되면 string 을 그대로 합치기 떄문에&lt;br&gt;
“122” 가 결과로 나오게 된다.&lt;/p&gt;
&lt;p&gt;정답은 &lt;code class=&quot;language-text&quot;&gt;1번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h2&gt;Quiz. 9&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(String.raw`HelloTwitter\nworld`)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
&quot;HelloTwitter\nworld&quot;
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB; white-space:pre;&quot;&gt;
&quot;HelloTwitter
world&quot;
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
&quot;HelloTwitter world&quot;
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
&quot;Hello Twitter world&quot;
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz. 9 해설&lt;/h4&gt;
&lt;p&gt;String.raw 는 문자열 내부 이스케이프 시퀀스를 무시하고 원시 문자열 데이터를&lt;br&gt;
그대로 반환하게 된다.&lt;/p&gt;
&lt;p&gt;여기서 ‘\n’ 은 원래라면 new line 으로 해석되어야 하지만 String.raw 로 인해&lt;br&gt;
그대로 출력되어 정답은 HelloTwitter\nworld 그대로 값이 나오게 된다.&lt;/p&gt;
&lt;p&gt;답은 &lt;code class=&quot;language-text&quot;&gt;1번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h2&gt;Quiz. 10&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(&amp;quot;This is a string.&amp;quot; instanceof String)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 console.log 의 output 을 어떤값일까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
true
&lt;/span&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;span style=&quot;color:#87CEEB&quot;&gt;
false
&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;h4&gt;Quiz. 10 해설&lt;/h4&gt;
&lt;p&gt;instanceof 는 주어진 객체가 특정 클래스 또는 생성자의 인스턴스 인지 확인한다.&lt;br&gt;
해당 객체의 prototype 체인을 거슬러 올라가서 확인하기 떄문에&lt;br&gt;
“This is a string” 의 생성자를 생각해보자.&lt;/p&gt;
&lt;p&gt;String 객체일가? 과연&lt;br&gt;
“This is a string” 의 타입을 생각해보자. 원시타입 string 이다.&lt;br&gt;
원시타입 string 은 String 객체에 의해 생성되지 않았기 때문에&lt;br&gt;
결과값은 false 가 나온다.&lt;/p&gt;
&lt;p&gt;정답은 &lt;code class=&quot;language-text&quot;&gt;2번&lt;/code&gt; 이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;여기서 true 가 나오려면 &lt;code class=&quot;language-text&quot;&gt;new String(&quot;This is a string.&quot;)&lt;/code&gt; 이 되어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오늘 준비한건 여기까지, 크게 중요치 않지만&lt;br&gt;
그냥 갑자기 보여서 오랜만에 퀴즈를 풀어봤다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Tailwindcss with MFA]]></title><description><![CDATA[오늘은 MFA(feat.Module Federation)에서 tailwindcss…]]></description><link>https://willowryu.github.io/2023-11-25/</link><guid isPermaLink="false">https://willowryu.github.io/2023-11-25/</guid><pubDate>Sun, 26 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오늘은 MFA(feat.Module Federation)에서&lt;br&gt;
tailwindcss 를 좀더 자연스럽게 사용하는 팁을 적어본다.&lt;/p&gt;
&lt;p&gt;하나의 프로젝트를 여러 모듈로 나뉘어 개발할때 중요한 부분 중 하나는&lt;br&gt;
각 모듈이 하나의 기능을 가지고 독립적으로 실행 가능하도록 개발하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;module federation 역시 양방향으로 사용가능하기 때문에&lt;br&gt;
remote 로 내보내는 모듈들 역시 host 가 되었든 host 에서 사용하게 되든&lt;br&gt;
독립적인 실행이 가능해야 한다.&lt;/p&gt;
&lt;p&gt;비즈니스 로직이나 상태 관리는 js 로 컨트롤이 가능하기 때문에&lt;br&gt;
각 모듈별 요구사항을 충족하게 만드는데 어렵지는 않다.&lt;/p&gt;
&lt;p&gt;다만 style 은 조금 다르다.&lt;/p&gt;
&lt;p&gt;웹을 기준으로 보면 remote 모듈은 결국 하나의 browser 에서 실행되는데&lt;br&gt;
우리의 browser 에서 style 을 처리할때는&lt;br&gt;
css 라는 이름처럼 cascading 하게 처리하게 되는데 여기서 같은 Specificity 를&lt;br&gt;
가지게 되면 나중에 들어오는 style 이 앞의 style 을 덮어 쓰게 된다.&lt;/p&gt;
&lt;p&gt;이런 css의 알고리즘은 일반적으로는 문제가 되지 않지만 tailwind 에서는&lt;br&gt;
약간의 문제가 생긴다.&lt;/p&gt;
&lt;h2&gt;Tailwind 의 Specificity&lt;/h2&gt;
&lt;p&gt;예를 들어&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function CustomInput(props) {
  const className = `border rounded px-2 py-1 ${props.className || &amp;quot;&amp;quot;}`
  return &amp;lt;input {...props} className={className} /&amp;gt;
}

function MyInput(props) {
  return &amp;lt;CustomInput {...props} className=&amp;quot;p-3&amp;quot; /&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 예에서 MyInput 의 classname 은 &lt;code class=&quot;language-text&quot;&gt;border rounded px-2 py-1 p-3&lt;/code&gt; 이 생성된다.&lt;br&gt;
하지만 &lt;code class=&quot;language-text&quot;&gt;px-2&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;py-1&lt;/code&gt; 그리고 &lt;code class=&quot;language-text&quot;&gt;p-3&lt;/code&gt; 은 같은 특이성을 가진다.&lt;/p&gt;
&lt;p&gt;그리고 tailwind 에서 classname 을 생성할때 css 의 순서는 아래 순서대로 생성된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;className 에 적힌 class 의 순서는 아무의미 없다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.p-3 {
  padding: 0.75rem/* 12px */;
}

.px-2 {
  padding-left: 0.5rem/* 8px */;
  padding-right: 0.5rem/* 8px */;
}

.py-1 {
  padding-top: 0.25rem/* 4px */;
  padding-bottom: 0.25rem/* 4px */;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결국 &lt;code class=&quot;language-text&quot;&gt;px-2&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;py-1&lt;/code&gt; 이 적용되고 &lt;code class=&quot;language-text&quot;&gt;p-3&lt;/code&gt; 은 무시 되는 효과가 나타난다.&lt;br&gt;
이문제는 MFA 가 아닌 일반적인 프로젝트에서도 볼 수 있는 문제 중 하나이다.&lt;br&gt;
이 문제를 해결하기 위한 라이브러리가 존재한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dcastil/tailwind-merge&quot; target=&quot;_blank&quot;&gt;Tailwind-merge&lt;/a&gt;
라는 라이브러리를 사용하면 깔끔하게 충돌되는 className 을 제거해주고, 위 문제를 해결할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function CustomInput(props) {
  const className = twMerge(&amp;quot;border rounded px-2 py-1&amp;quot;, props.className)
  return &amp;lt;input {...props} className={className} /&amp;gt;
}
// -&amp;gt; className =&amp;gt; border rounded p3&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자세한 사용법은 해당 github 을 참조하자.
그럼 이제 2번째 문제로 가보자.&lt;/p&gt;
&lt;h2&gt;Utility className 의 독립성&lt;/h2&gt;
&lt;p&gt;Tailwind 의 장점 중 하나는 className 에 유틸리티 클래스를 사용하여 style 을&lt;br&gt;
빠르게 작성하고, 공유할 수 있다는 점이 존재한다.&lt;/p&gt;
&lt;p&gt;Tailwind 의 트리쉐이킹인 purge 동작은 해당 모듈에서 사용하지 않는 css 를 제거해주는&lt;br&gt;
아주 좋은 최적화 기능이다.&lt;br&gt;
하지만 이 부분이 결국 MFA 를 만들때 걸림돌이 된다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;Host&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Module A&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Module B&lt;/code&gt; 3개의 모듈이 존재한다고 할때,&lt;br&gt;
우리가 원하는건 각 모듈이 독립적인 style 을 가져가고, 어떤 모듈에서 remote 로 호출되어도&lt;br&gt;
style 을 유지하기를 바랄 것이다.&lt;/p&gt;
&lt;p&gt;만약 remote 에서 tailwind 가 없다면? remote 를 부르는 host 에서 해당 remote 모듈의&lt;br&gt;
style 을 가지고 있지 않는 한 remote 모듈의 style 을 정상적으로 적용되지 않는다.&lt;/p&gt;
&lt;p&gt;예를 들어,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Remote A
const RemoteA = () =&amp;gt; {
  ;&amp;lt;div className=&amp;quot;grid grid-cols-1&amp;quot;&amp;gt;RemoteA&amp;lt;/div&amp;gt;
}

// Remote B
const RemoteB = () =&amp;gt; {
  ;&amp;lt;div className=&amp;quot;grid grid-cols-2&amp;quot;&amp;gt;RemoteB&amp;lt;/div&amp;gt;
}

// Host
import &amp;quot;./styles.tw.css&amp;quot; // tailwindcss
const HostComponent = () =&amp;gt; {
  return (
    &amp;lt;&amp;gt;
      &amp;lt;div className=&amp;quot;flex items-center&amp;quot;&amp;gt;
        // Remote A 와 Remote B 를 가져온다.
        &amp;lt;RenderRemoteA /&amp;gt;
        &amp;lt;RenderRemoteB /&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;RemoteA&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;RemoteB&lt;/code&gt; 는 생성된 css style 없이 Host 로 가게 된다.&lt;br&gt;
하지만 Host 가 가지고 있는 class 는 tailwind 의 최적화로 인해 &lt;code class=&quot;language-text&quot;&gt;flex items-center&lt;/code&gt;&lt;br&gt;
두개의 css style 만 가지고 있으므로 remote 들은 style 이 적용되지 않는다.&lt;/p&gt;
&lt;p&gt;결국 Remote 들이 각자의 style 을 가지고 있기 위해서는 Host 처럼 각각
&lt;code class=&quot;language-text&quot;&gt;import &apos;./styles.tw.css&apos;&lt;/code&gt; 이런식으로 tailwind 를 가지고 있어야 한다.&lt;/p&gt;
&lt;p&gt;그럼 문제가 해결되었나? 해결 된듯 해 보이지만 아직도 문제가 존재한다.&lt;br&gt;
일반적인 classname 은 중복이 되어도 다른 모듈의 css 항목이 가지고 있기 때문에,&lt;br&gt;
문제가 되지 않지만 &lt;code class=&quot;language-text&quot;&gt;@media&lt;/code&gt; 와 같은 항목을 사용할때는 문제가 생긴다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;/* ModuleA CSS */
@media (min-width: 640px) {
  .sm\:hidden {
    display: none;
  }
}
@media (min-width: 768px) {
  .md\:block {
    display: block;
  }
}


/* ModuleB CSS */
@media (min-width: 640px) {
  .sm\:hidden {
    display: none;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 Module A, B 가 각각 &lt;code class=&quot;language-text&quot;&gt;@media&lt;/code&gt; 항목을 사용할때, 둘의 특이성은&lt;br&gt;
동일하기 때문에 뒤늦게 로드되는 style 이 먼저 로드된 style 을 덮어 버리게 된다.&lt;br&gt;
위 media 쿼리의 정렬 문제는 &lt;code class=&quot;language-text&quot;&gt;postcss-sort-media-queries&lt;/code&gt; 로 해결할 수는 있다.&lt;/p&gt;
&lt;p&gt;그럼 이제 모두 해결된건가? 해치웠나?&lt;br&gt;
아직 문제가 남아있다.&lt;/p&gt;
&lt;h2&gt;Utility className 의 중복&lt;/h2&gt;
&lt;p&gt;remote 모듈이 몇개 없을때는 문제가 되지 않지만, remote 모듈이 많아지면&lt;br&gt;
각 remote 모듈마다 동일한 classname 을 가진 stylesheet 가 생성되기 때문에&lt;br&gt;
같은 classname 의 중복이 무자비하게 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/370739be96250bf75f459eb88f3c9d1a/248b0/231126-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 22.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVQI14XOSw6DMAwE0FymQY2UJv7kg2jZtIKk9z9QB9YURvZunmyz9m+sE2tKSb331t6Gwd7/JISQ9vAe03ov03N+f8bXHCMRM9Y5d4gBaq2lFHgRMcvaHqIYTxKhTzEuw/DWIZTN0jqVkVhV5PJtAJzNOetWlx97AiyfKyGLXwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;classname&quot;
        title=&quot;classname&quot;
        src=&quot;/static/370739be96250bf75f459eb88f3c9d1a/fcda8/231126-1.png&quot;
        srcset=&quot;/static/370739be96250bf75f459eb88f3c9d1a/12f09/231126-1.png 148w,
/static/370739be96250bf75f459eb88f3c9d1a/e4a3f/231126-1.png 295w,
/static/370739be96250bf75f459eb88f3c9d1a/fcda8/231126-1.png 590w,
/static/370739be96250bf75f459eb88f3c9d1a/efc66/231126-1.png 885w,
/static/370739be96250bf75f459eb88f3c9d1a/c83ae/231126-1.png 1180w,
/static/370739be96250bf75f459eb88f3c9d1a/248b0/231126-1.png 1316w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이런식으로 쌓이게 된다.&lt;/p&gt;
&lt;p&gt;classname 이 계속 쌓이게 되면 이는 결국 성능저하를 가지고 오게 되며&lt;br&gt;
해당 Element 의 style 을 디버깅 할때 걸림돌이 될 수 있다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서 몇가지 방법이 존재한다.&lt;/p&gt;
&lt;h2&gt;해결법&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;첫번째는 &lt;code class=&quot;language-text&quot;&gt;Tailwind 를 Host 나 Root 에서 한번 포함한다.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;remote 모듈에서 각각 tailwind 를 불러오지 않고, root 에서 한번만 불러오거나,&lt;br&gt;
해당 remote 를 사용하는 Host 에서만 생성하면 이런 중복을 줄일 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;만약 root 에서 한번 불러온다면, 해당 Root 에는 모든 tailwind class 가 포함되어야&lt;br&gt;
하며, 이는 tailwind 의 최적화 기능을 사용할 수 없기 때문에 좋은 방법이 아니다.&lt;/p&gt;
&lt;p&gt;그럼 특정 Host 에서 불러온다면?&lt;br&gt;
style sheet 는 빌드 타임에 생성된다. 그런데 Host 에서는 자신이 불러오는 Remote 모듈에서&lt;br&gt;
사용되는 class 를 과연 알수 있을까?&lt;/p&gt;
&lt;p&gt;Host 의 tailwind content 설정에 사용하는 Remote 모듈의 path 를 등록한다면&lt;br&gt;
빌드타임에 알수는 있을 것이다.&lt;/p&gt;
&lt;p&gt;하지만 MFA 나 ModuleFederation 에서 remote 모듈은 독립적으로 개발하고 배포된다.&lt;br&gt;
만약 remote 의 style 이 변경되어 배포 된다면 그 변경사항을 Host 가 알수 있을까?&lt;/p&gt;
&lt;p&gt;Host 가 변경사항을 적용하기 위해서는 사용하는 remote 모듈이 변경될때 Host 본인도&lt;br&gt;
다시 빌드가 되어야 한다.&lt;/p&gt;
&lt;p&gt;이는 Host 와 Remote 에 거대한 의존성이 생기게 되고, MFA 와 개발원칙과 어울리지 않는&lt;br&gt;
방식으로 변하게 된다.&lt;br&gt;
추가로 해당 의존성은 어떻게 관리할 것인가?&lt;br&gt;
만약 해당 Host 도 또 다른 Host 에 연결되어 있다면?&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;두번째는 &lt;code class=&quot;language-text&quot;&gt;twin.macro 와 같은 css-in-Js 를 사용한다.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;css-in-js 는 여기서 좋은 해결법이 될 수 있다.&lt;br&gt;
런타임에 난독화된 classname 의 style 을 inject 하기때문에&lt;br&gt;
각 모듈간 classname 의 충돌도 없고&lt;br&gt;
twin.macro 같은 경우 tailwind 문법을 그대로 사용할 수 있기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 이를 위해선 className 에서 별도의 함수로 매번 감싸줘야 하는 불편함이 있고,&lt;br&gt;
추가로 css-in-js 의 동작방식으로 인한 추가 런타임 비용이 들어가게 된다.&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;세번째는 &lt;code class=&quot;language-text&quot;&gt;tailwind 자체적으로 prefix 를 붙여준다.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Tailwind 에서는 자체적으로 className 의 충돌을 막기 위해 prefix 옵션을 제공한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  prefix: &amp;quot;custom1-&amp;quot;,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 하면 실제로 개발 할때&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;div className=&amp;quot;custom1-grid custom1-grid-cols-1&amp;quot;&amp;gt;
  &amp;lt;span&amp;gt;Custom&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 prefix 를 제공할 수 있고, 생성되는 css 에서도 prefix 가 붙어 나오게 된다.&lt;br&gt;
추가로 vscode 같은 ide 에서도 자동완성 역시 지원된다.&lt;/p&gt;
&lt;p&gt;다만 이 방식의 단점은 가뜩이나 긴 classname 을 더 길게 만들어 DX 가 저하되고,&lt;br&gt;
classname 을 복사해서 다른 모듈에서 사용하기가 아주 불편해지는 점이 생긴다.&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;네번째는 &lt;code class=&quot;language-text&quot;&gt;ShaodwDom&lt;/code&gt; 을 사용해 dom 을 캡슐화 시킨다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ShaodwDom 을 활용해서 해당 모듈을 dom 트리에서 별도로 격리 시켜 버리면, 해당 모듈들은&lt;br&gt;
같은 className 이라도 독립적인 style 을 활용할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;하지만 이는 또다른 문제를 야기한다.&lt;br&gt;
말 그대로 격리되어 있기 때문에 디자인 시스템과 같은&lt;br&gt;
공유 컴포넌트를 사용하기 위해서는 해당 remote 모듈에서 공유 컴포넌트의 style 을&lt;br&gt;
전부 가지고 있어야 한다.&lt;br&gt;
배보다 배꼽이 커질 수 있는 방법이다.&lt;/p&gt;
&lt;p&gt;이 모든 해결법에는 모두 tradeoff 가 존재한다.&lt;br&gt;
실제로 moduleFederation 에서 알려진 큰 문제점 중 하나이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nrwl/nx/issues/9784#issuecomment-1095128433&quot; target=&quot;_blank&quot;&gt;Nx Git Issue&lt;/a&gt; 해당 링크를 살펴보면 Nx 의 개발자가 이 문제에 대해 설명을 잘 해준다.&lt;/p&gt;
&lt;h2&gt;새로운 해결법&lt;/h2&gt;
&lt;p&gt;결국 개발 할때는 기존 Tailwind 를 사용하듯이 일반적으로 사용하고,&lt;br&gt;
빌드 될때는 모든 classname 에 prefix 가 붙어서 빌드 된다면 이문제는 해결된다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해 몇가지 트릭을 사용했다.&lt;br&gt;
먼저 postcss 의 &lt;code class=&quot;language-text&quot;&gt;postcss-prefix&lt;/code&gt; plugin 을 사용해 빌드될때 styleSheet 의 모든&lt;br&gt;
className 에 고유 prefix 를 붙여준다.&lt;br&gt;
가장 좋은 prefix 는 해당 package 또는 모듈의 이름이다.&lt;/p&gt;
&lt;p&gt;prefix 가 붙은 styleSheet 의 style 을 적용하기 위해서는 실제 컴포넌트에서도&lt;br&gt;
해당 prefix 가 붙은 className 을 써야한다.&lt;/p&gt;
&lt;p&gt;예를들어 &lt;code class=&quot;language-text&quot;&gt;custom1-flex custom2-items-center&lt;/code&gt; 이런식으로 써야 하는데&lt;br&gt;
위에 적었듯이 개발할때는 일반적인 tailwind 를 사용하고&lt;br&gt;
빌드될때 해당 부분을 변경해줘야 한다.&lt;/p&gt;
&lt;p&gt;이를 위해 Webpack 의 &lt;code class=&quot;language-text&quot;&gt;string-replace-loader&lt;/code&gt; 를 사용해서 빌드타임때 dom 의 className에 있는 class 앞에 모두 prefix 를 붙여줄 것 이다.&lt;/p&gt;
&lt;p&gt;예를들면 이런식이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const twClassnameTransForm = prefix =&amp;gt; {
  return {
    test: /\.tsx$/,
    loader: &amp;quot;string-replace-loader&amp;quot;,
    options: {
      search: /className=[&amp;#39;&amp;quot;]([^&amp;#39;&amp;quot;]*)[&amp;#39;&amp;quot;]/g,
      replace(_, p1) {
        const classNames = p1.trim().split(&amp;quot; &amp;quot;)
        const prefixedClassNames = classNames.map(className =&amp;gt; {
          if (className.startsWith(prefix)) {
            return className
          } else {
            return `${prefix}-${className}`
          }
        })
        return `className=&amp;quot;${prefixedClassNames.join(&amp;quot; &amp;quot;)}&amp;quot;`
      },
    },
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 loader 를 사용하면 실제로 작성한 tailwind className 앞에 내가 원하는 prefix 가&lt;br&gt;
모두 붙어서 빌드 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;div className=&amp;quot;grid grid-cols-1&amp;quot;&amp;gt;
  &amp;lt;span&amp;gt;Custom&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

// 빌드 후

&amp;lt;div className=&amp;quot;custom1-grid custom1-grid-cols-1&amp;quot;&amp;gt;
  &amp;lt;span&amp;gt;Custom&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 추가된다.&lt;br&gt;
이제 각 모듈간 독립적으로 className 을 가지게 되며, 개발 할때는 일반적인&lt;br&gt;
tailwind 의 사용을 활용할 수 있게 된다.&lt;/p&gt;
&lt;h2&gt;TwMerge 를 포함한다면?&lt;/h2&gt;
&lt;p&gt;위 방법은 단순히 className 을 string 으로만 적었을때 적용할 수 있다.&lt;br&gt;
하지만 TwMerge 나 props 로 className 을 받아서 적용할때는 어떻게 해야 할까?&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;div className={twMerge(&amp;quot;grid grid-cols-1&amp;quot;, props)}&amp;gt;
  &amp;lt;span&amp;gt;Custom&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

// 또는

&amp;lt;div className={`grid grid-cols-1 ${props}`}&amp;gt;
  &amp;lt;span&amp;gt;Custom&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;string-replace-loader&lt;/code&gt; 는 단순하게 string 찾아서 변경시켜 주기 때문에
이런식의 className 은 변환 시킬 수 없다.&lt;/p&gt;
&lt;p&gt;이를 해결하기 위해서는 별도의 Util 이 필요하다.&lt;br&gt;
먼저 TwMerge 에서 옵션으로 prefix 설정을 추가하고 별도의 함수로 추출해야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const extendsTwMergeConfig = ... // twMerge theme 관련 custom 설정

const twMerge = (prefix: string) =&amp;gt; {
  return isDev
    ? extendTailwindMerge(extendsTwMergeConfig)
    : extendTailwindMerge({
        ...extendsTwMergeConfig,
        prefix: `${prefix}-`,
      });
};

export const twCombine = twMerge(packageName);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 twMerge 를 개발환경일때는 prefix 를 붙이지 않고 빌드 환경일때만 prefix 가 적용 되도록
하여 &lt;code class=&quot;language-text&quot;&gt;twCombine&lt;/code&gt; 이라는 함수를 유틸로 노출한다.&lt;/p&gt;
&lt;p&gt;그리고 이 역시 &lt;code class=&quot;language-text&quot;&gt;string-replace-loader&lt;/code&gt; 를 사용해서 변경해주는 loader 가 필요하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// transform util
const twMergeClassNameAddPrefix = (classNames, prefix) =&amp;gt; {
  const transCls = classNames.map(className =&amp;gt; {
    const pattern = /[\&amp;#39;\&amp;quot;]+/g
    if (!pattern.test(className)) {
      return className
    }

    const trimClassName = className.replace(pattern, &amp;quot;&amp;quot;)
    if (trimClassName.startsWith(prefix)) {
      return trimClassName
    } else {
      return `&amp;quot;${prefix}-${trimClassName}&amp;quot;`
    }
  })
  return transCls
}

// 실제 Loader
const twMergeClassnameTransForm = prefix =&amp;gt; {
  return {
    test: /\.tsx$/,
    loader: &amp;quot;string-replace-loader&amp;quot;,
    options: {
      search: /className={twCombine\((.*?)\)}/g,
      replace(_, p1) {
        const classNames = p1.trim().split(&amp;quot;,&amp;quot;)
        const prefixedClassNames = classNames.map(className =&amp;gt; {
          const trimed = className.trim()
          const splitClass = trimed.split(/\s+/)

          if (splitClass.length &amp;gt; 1) {
            return twMergeClassNameAddPrefix(splitClass, prefix)
          }

          const pattern = /[\&amp;#39;\&amp;quot;]+/g
          if (!pattern.test(trimed)) {
            return trimed
          }

          const trimClassName = trimed.replace(pattern, &amp;quot;&amp;quot;)
          if (trimClassName.startsWith(prefix)) {
            return trimClassName
          } else {
            return `&amp;quot;${prefix}-${trimClassName}&amp;quot;`
          }
        })
        return `className={twCombine(${prefixedClassNames.join(&amp;quot;, &amp;quot;)})}`
      },
    },
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;twCombine 의 변형은 조금 더 복잡하다.&lt;br&gt;
중첩되는 className 과 ’,’ 로 구분되는 className 으로 인해 로직이 더 생겼다.&lt;/p&gt;
&lt;p&gt;추가로 props 로 받는 className 에 대해서도 별도의 util 을 만들어서 자동으로 prefix 가&lt;br&gt;
들어가도록 수정한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const cxSet = (prefix: string) =&amp;gt; {
  return function (cls: string) {
    const result: string[] = []
    const clsDest = cls.split(&amp;quot; &amp;quot;)

    for (const className of clsDest) {
      if (className !== &amp;quot;undefined&amp;quot;) {
        result.push(`${prefix}-${className}`)
      }
    }

    return result.join(&amp;quot; &amp;quot;)
  }
}

const twProps = (pkgname: string) =&amp;gt; {
  const cx = cxSet(pkgname)
  return (className: string) =&amp;gt; (isDev ? className : cx(className))
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;twProps&lt;/code&gt; 같은 경우 &lt;code class=&quot;language-text&quot;&gt;twCombine&lt;/code&gt; 과 마찬가지로 개발환경에서는 일반 className 을&lt;br&gt;
return 하고 빌드타임때는 prefix 를 붙이도록 되어있다.&lt;br&gt;
실제로 사용할때는 이런식으로 사용이 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const className = &amp;quot;flex&amp;quot;
const App = () =&amp;gt; {
  const ref = false
  return (
    &amp;lt;div
      className={twCombine(
        &amp;quot;grid grid-cols-1&amp;quot;,
        twProps(ref ? &amp;quot; px-0&amp;quot; : &amp;quot;py-2&amp;quot;),
        twProps(&amp;quot;p-3&amp;quot;)
      )}
    &amp;gt;
      Template
    &amp;lt;/div&amp;gt;
  )
}

// 또는 TwProps With Combine
&amp;lt;div
  className={twCombine(
    twProps(&amp;quot;grid grid-cols-1&amp;quot;),
    twProps(ref ? &amp;quot; px-0&amp;quot; : &amp;quot;py-2&amp;quot;),
    twProps(&amp;quot;p-3&amp;quot;)
  )}
&amp;gt;
  twProps
&amp;lt;/div&amp;gt;

// 단순히 props 로 className 을 받았을때
&amp;lt;span className={twProps(`grid grid-cols-[1fr_1fr] ${className}`)}&amp;gt;
  Span
&amp;lt;/span&amp;gt;

// 일반적인 사용
&amp;lt;span className=&amp;quot;grid grid-cols-[1fr_1fr]&amp;quot;&amp;gt;Center&amp;lt;/span&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 위 모든 className 이 build 할때 지정한 prefix 가 들어가게 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;주의할 점은 &lt;code class=&quot;language-text&quot;&gt;twCombine&lt;/code&gt; 사용시 아래처럼 &lt;code class=&quot;language-text&quot;&gt;string className&lt;/code&gt; 이 twProps&lt;br&gt;
사이에 있으면 안된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;string className&lt;/code&gt;은 처음 시작되거나, 그게 아니면 twProps 로만&lt;br&gt;
사용되어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// OK
&amp;lt;div
  className={twCombine(
    twProps(&amp;quot;grid grid-cols-1&amp;quot;),
    twProps(ref ? &amp;quot; px-0&amp;quot; : &amp;quot;py-2&amp;quot;),
    twProps(&amp;quot;p-3&amp;quot;)
  )}
&amp;gt;
  twProps
&amp;lt;/div&amp;gt;


// OK
&amp;lt;div
  className={twCombine(
    &amp;quot;grid grid-cols-1&amp;quot;,
    twProps(ref ? &amp;quot; px-0&amp;quot; : &amp;quot;py-2&amp;quot;),
    twProps(&amp;quot;p-3&amp;quot;)
  )}
&amp;gt;
  twProps
&amp;lt;/div&amp;gt;


// FAIL!!
&amp;lt;div
  className={twCombine(
    twProps(&amp;quot;grid grid-cols-1&amp;quot;),
    &amp;quot;flex&amp;quot;,
    twProps(&amp;quot;p-3&amp;quot;)
  )}
&amp;gt;
  twProps
&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;외부 모듈끼리의 className 주입&lt;/h2&gt;
&lt;p&gt;추가로 만약 module 내에서가 아닌 remote module 끼리 className 을&lt;br&gt;
props 로 주고 받는다면?&lt;/p&gt;
&lt;p&gt;twProps 는 들어오는 className 을 받는다면 예외없이 해당 모듈의 prefix 가 붙게 된다.&lt;/p&gt;
&lt;p&gt;이러면 외부 모듈의 className 을 적용할 수 없기 때문에 외부 모듈의 className은&lt;br&gt;
twProps 내부가 아닌 별도로 className 을 받아야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그리고 외부 모듈에서는 반드시 twProps 로 className 을 감싸서 반드시 prefix 를&lt;br&gt;
붙여서 주입해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;밑의 예를 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// module A
const ModuleA = () =&amp;gt; {
  const externalClassName = twProps(&amp;quot;flex items-center&amp;quot;)
  // 이때 externalClassName 은 module A 의 prefix 를 적용하고 있다.
  // ex) moduleA-flex moduleA-items-center

  return (
    // ModuleB 로 moduleA 의 prefix 가 적용된 채로 className 을 주입한다.
    &amp;lt;ModuleB externalClassName={externalClassName} /&amp;gt;
  )
}

// module B
const ModuleB = ({ externalClassName }: { externalClassName: string }) =&amp;gt; {
  // twProps 외부에 externalClassName 을 배치한다.
  // 이렇게 하면 module B 의 최종 className 은
  // moduleB-grid moduleB-grid-cols-1 moduleA-flex moduleA-items-center
  // 이런식으로 양쪽 모듈의 css 를 모두 사용할 수 있다.
  return (
    &amp;lt;div
      className={`${twProps(&amp;quot;grid grid-cols-1&amp;quot;)}
      ${externalClassName ?? &amp;quot;&amp;quot;}`}
    &amp;gt;
      test
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;webpack 의 loader 와 별도의 util 함수를 활용해 DX 저하는 없애고,&lt;br&gt;
실제로 빌드된 모듈에서는 독립적인 className 을 갖도록 하여 className 의 중복과&lt;br&gt;
충돌을 없어지도록 만들었다.&lt;/p&gt;
&lt;p&gt;물론 여기서도 tradeoff 가 존재한다.&lt;/p&gt;
&lt;p&gt;twProps 라는 함수로 감싸야 하는 점과 별도의 공통 util 함수를 추출해야 하는점,&lt;br&gt;
webpack 을 사용해야 한다는점, 그리고 React 기준이라는 부분.&lt;br&gt;
twCombine 사용시 주의해야 할 부분 등.&lt;/p&gt;
&lt;p&gt;위 방법도 어디서 언제 문제가 생길지 모르고, 그냥 tailwind 를 moduleFederation 에&lt;br&gt;
적용하기 위한 또 하나의 방법이라고 봤으면 좋겠다.&lt;br&gt;
다행히 아직까지는 문제가 없다.&lt;/p&gt;
&lt;p&gt;다른 번들러에서도 &lt;code class=&quot;language-text&quot;&gt;string-replace-lorder&lt;/code&gt; 와 같은 플러그인이 있어서&lt;br&gt;
방법만 안다면 충분히 활용해볼만 하다.&lt;/p&gt;
&lt;p&gt;해당 방법을 사용하기 위한 함수와 설명은 충분히 한 것 같아, 별도의 디테일한 설정은&lt;br&gt;
따로 기술하지 않겠다.&lt;/p&gt;
&lt;p&gt;그리고 혹시 tailwind 를 module federation 에서 사용하고 있고,&lt;br&gt;
위와 같은 문제를 겪은 뒤 해결한 경험이 있다면 연락해줬으면 한다. 🥹&lt;/p&gt;
&lt;p&gt;다음 글은 아마 &lt;code class=&quot;language-text&quot;&gt;Signal&lt;/code&gt; 에 대한 글로.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Jotai 사용, 쉽고 빠른 Convention]]></title><description><![CDATA[바쁘다 바빠 오랜만에 글을 쓰는 것 같다. 일도 너무 바쁘고 현생사느라 바빠 글을 남기지 못했지만 그래도 중간중간 기록이 필요한 것 같아 급하게 글을 적는다. 현재 회사 프로젝트에서는 graphql 을 위해 apollo client…]]></description><link>https://willowryu.github.io/2023-09-19/</link><guid isPermaLink="false">https://willowryu.github.io/2023-09-19/</guid><pubDate>Tue, 19 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;바쁘다 바빠&lt;br&gt;
오랜만에 글을 쓰는 것 같다. 일도 너무 바쁘고 현생사느라 바빠 글을 남기지 못했지만&lt;br&gt;
그래도 중간중간 기록이 필요한 것 같아 급하게 글을 적는다.&lt;/p&gt;
&lt;p&gt;현재 회사 프로젝트에서는 graphql 을 위해 apollo client 를 사용하기 때문에&lt;br&gt;
별도의 state management 를 사용하지 않았다.&lt;/p&gt;
&lt;p&gt;state 관리가 필요할땐 rxjs 의 subject 를 활용하거나&lt;br&gt;
react 자체에서 제공하는 useReducer 를 활용해 간단한 reducer 를 만들어 사용했다.&lt;/p&gt;
&lt;p&gt;사실 현재 서비스 개발을 시작한지 오래되었고, 다양한 컨벤션이 존재하지만&lt;br&gt;
state 관리에 대해선..크게 신경쓰지 않았다.&lt;/p&gt;
&lt;p&gt;대부분의 데이터는 apollo client 의 cache 로 해결이 되고, 간단한건 위에 적었듯&lt;br&gt;
rx 또는 reducer 를 활용했다.&lt;/p&gt;
&lt;p&gt;하지만..팀원이 늘어나며 각각 자신의 코딩 스타일을 접목하여 state 를 처리하기 시작하니&lt;br&gt;
이게 서로 알아볼 순 있지만 일관성이 점점 사라지니 피로도가 증가하기 시작했다.&lt;/p&gt;
&lt;p&gt;각 팀원에게 자유도를 최대한 주고, 서로 피드백을 주고 받으며 점점 발전시켜가고 싶었지만&lt;br&gt;
이젠 결정을 해야 할때가 되었다.&lt;/p&gt;
&lt;p&gt;다양한 state management 라이브러리가 존재하지만&lt;br&gt;
일단 자유도가 높고, 쓰기 쉬우며, 작은 라이브러리가 필요했다.&lt;/p&gt;
&lt;p&gt;그래서 급하게 zustand, recoil, jotai 등을 살펴보고&lt;br&gt;
결국 jotai 를 일단 도입하게 되었다.&lt;/p&gt;
&lt;h2&gt;Jotai&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/655ae10550419d7bb29fa3e984fba205/d698c/230919-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 27.7027027027027%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA50lEQVQY03WQO2qGQBSFB3yA4jMkUfgLwV98iyaKjYuwE1yHNuJerO3sBV2MrZvIyUhACP9XXO7c4Zx7ZoggCGVZapomiqIsy7qua3+gf3sNbklVVfu+13XNcZyiKJZlBUHwpNi2/XHjnYLmk2KaJpmm6TzPYRh4nocYgi9KnudpmiZJEoZhHMdRFKFiWBSF67qO4xiGQY7j2Lat67orOcRZll36bwqOqJcMFXYPyq94nue+78dxXNe1bVu8BKtgjNjY4HmeewPWSI7MBoVIksSyrO/7y7I0TcMwDCIgv6qqyj8wvP/oD3GOPL6xJ3c1AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Jotai&quot;
        title=&quot;Jotai&quot;
        src=&quot;/static/655ae10550419d7bb29fa3e984fba205/fcda8/230919-1.png&quot;
        srcset=&quot;/static/655ae10550419d7bb29fa3e984fba205/12f09/230919-1.png 148w,
/static/655ae10550419d7bb29fa3e984fba205/e4a3f/230919-1.png 295w,
/static/655ae10550419d7bb29fa3e984fba205/fcda8/230919-1.png 590w,
/static/655ae10550419d7bb29fa3e984fba205/efc66/230919-1.png 885w,
/static/655ae10550419d7bb29fa3e984fba205/c83ae/230919-1.png 1180w,
/static/655ae10550419d7bb29fa3e984fba205/d698c/230919-1.png 1846w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이글에서 jotai 는 어떤 철학이 있고, 동작원리는 어떻고, 다른 라이브러리와 비교시&lt;br&gt;
어떤점이 좋다 ~~~ 라는 걸 설명하진 않는다.&lt;/p&gt;
&lt;p&gt;검색만 하면 그에 대한글이 아주 많으니 해당 글들을 참조하자.&lt;br&gt;
이글에서는 나처럼 빠르게 결정하고, 빠르게 컨벤션을 만들기 위한 사람에게 도움이 되길 원하며&lt;br&gt;
초기 컨벤션의 모습을 적어볼까 한다.&lt;/p&gt;
&lt;p&gt;Jotai 는 어떠한 프레임워크에도 종속되지 않고, 자유도가 높기 때문에&lt;br&gt;
초기 컨벤션을 정하려는 팀 또는 개인은 고민이 조금 될 수 있다.&lt;/p&gt;
&lt;p&gt;처음부터 완벽한 컨벤션은 없으니 차차 발전시켜 가면 좋을 것 같다.&lt;/p&gt;
&lt;h2&gt;Convention&lt;/h2&gt;
&lt;p&gt;미리 말하지만 Jotai 를 접한지 얼마 되지 않았기 때문에&lt;br&gt;
잘못된 점이 있다면 꼭 말해주면 좋겠다.&lt;/p&gt;
&lt;p&gt;특정 feature 또는 어떤 부분에 대해 store 를 활용하고자 한다면&lt;br&gt;
해당 store 의 범위를 제한 할 필요가 있다.&lt;/p&gt;
&lt;p&gt;특정 Modal, Component 또는 특정 Container 에게만 적용하고 싶다면&lt;br&gt;
Jotai 에서 제공해주는 Provider 를 사용하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { provider } from &amp;quot;jotai&amp;quot;

export const ProviderJotai = () =&amp;gt; {
  return &amp;lt;Provider&amp;gt;{children}&amp;lt;/Provider&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그냥 이렇게 감싸 주면 된다.&lt;br&gt;
Provider 는 react context 와 같이 Provider 내부의 Atom 은&lt;br&gt;
해당 부모 Provider 를 경계로 별도의 Atom 으로 작동하게 된다.&lt;/p&gt;
&lt;p&gt;이 부분은 곧 변경 할테니 Provider 가 이렇구나만 알면되고&lt;br&gt;
OK 그럼 Store 의 기본요소들, 즉 Store, Actions, Selector 를 적용해보자.&lt;/p&gt;
&lt;p&gt;특정 기능에서 사용 할 Container 주변에 Store 폴더를 하나 만든다.&lt;br&gt;
해당 Store 폴더 안 개별 store 폴더를 만들고 내부에 Config 폴더를 만든다.&lt;/p&gt;
&lt;p&gt;그리고 Config 폴더 안 selector, actions, store 이렇게 3개의 파일을 만든다.&lt;br&gt;
그리고 Store 폴더에서는 React 에서 사용하기 위한 커스텀훅을 만든다.&lt;/p&gt;
&lt;p&gt;대략적인 폴더 구조를 보면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 474px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 31.756756756756754%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0UlEQVQY03WQy26DMBBF8w0QHjY2ODwEdmzhCIySMSFpxRd000026ar//wWdZh2uNKvRmaO5O0opZwxun/5j1cfj5QLWWkJImqbklXQ7O0JpRqk5Df3olJTDMEgp96+EYRgEQZIkmzDuGGOcs6/HczzDyVrv/bquzrllWeZ5FkLEcfwexsmyjHPu4NpJ1TRN3/da66qqlFLGmDzPt+T/ZiSLovj++YXl7gHQPE0TygEAt1EUbcJYCXZWiIPURogDmuu6Lsuy67q2bfEjvIvyt/AfN0kvYDIgL9MAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Str&quot;
        title=&quot;Str&quot;
        src=&quot;/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png&quot;
        srcset=&quot;/static/0f26b20cd5f5437584b25cbca7ad4eeb/12f09/230919-3.png 148w,
/static/0f26b20cd5f5437584b25cbca7ad4eeb/e4a3f/230919-3.png 295w,
/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png 474w&quot;
        sizes=&quot;(max-width: 474px) 100vw, 474px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇개 사용할 Store 가 구분되고&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 462px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbUlEQVQoz4WSQU+DQBCFe/PSNBQK7S4sFKRABcoCpVQoWmtqTOylN2OMiYlXvfkn/NW+bnowatt32s3sl/dmZluUUoMZhq5P0vx85I+EHMcJggAHVAeH1UJ5OBxalrV9eimyvFksFk1TFMVKCCVN0w7CuhCjtGdaZLk2h7bv+3Ecw1lVVbwghByDDcYck5E4GX988iSGeVVVsEVZUZRjzrueDYNQncgdKbtv376OLCPhaZ7nEyHXdQ/xexj2RFWU+aZbbbNJWMxmZVmmaZplmed5yP9v+D1MAfe63XrbuXsLHAswsOl0iubDMDwRm+o6nOV8LZWbyB/NLyvEhjMXOgkbRJGk68f2w3sWBYCnQlghZkaEDsN056zwpcRXnmMnnF8IMcZkWe4J/R2bgJmJhnthefb85XrBVbNAq03T1HWNzrEzbA7X8Xj8i9/BWPVAU/uW2+U3puNynuCHgI+iCB8GA0MEkLZt9/v9n/A3VeZff8aw5goAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Str2&quot;
        title=&quot;Str2&quot;
        src=&quot;/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png&quot;
        srcset=&quot;/static/2e1e618df3c16d0fd15b5b56c7c7e863/12f09/230919-2.png 148w,
/static/2e1e618df3c16d0fd15b5b56c7c7e863/e4a3f/230919-2.png 295w,
/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png 462w&quot;
        sizes=&quot;(max-width: 462px) 100vw, 462px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;내부에는 설정과 사용할 react hook 이 존재한다.&lt;br&gt;
만약 React 가 아닌 다른 다른 프레임워크를 사용한다면&lt;br&gt;
해당 프레임워크에서 사용할 Store 시작점 함수를 만들어 두자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이렇게 하면 Config 내부는 다른 어떤&lt;br&gt;
프레임워크 에서든 사용가능하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여기서 간단한 Store 로 예를 만들면&lt;/p&gt;
&lt;p&gt;먼저 Store 파일을 보자.&lt;br&gt;
(모델의 타입이나 이름은 신경쓰지 말자)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// store.ts
import { atom } from &amp;quot;jotai&amp;quot;

export interface TestStoreModel {
  marker?: string;
  sheetShow: boolean;
  region: number;
}

const initialTestStoreProp: TestStoreModel = {
  sheetShow: false,
  region: 0,
  marker: &amp;quot;test&amp;quot;,
}

const TestStoreAtom = atom &amp;lt; TestStoreModel &amp;gt; initialTestStoreProp

export const TestStoreInfo = {
  store: TestStoreAtom,
  initialTestStoreProp,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Store 에서는 해당 Store의 Atom 과 초기 값을 정의해준다.&lt;br&gt;
다음으로 actions 을 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// actions.ts
import { TestStoreInfo } from &amp;quot;./store&amp;quot;
import { atom } from &amp;quot;jotai&amp;quot;

const onChangeRegion = atom(null, (_, set, region: number) =&amp;gt; {
  set(TestStoreInfo.store, prev =&amp;gt; ({
    ...prev,
    region,
  }))
})

const onChangeMarker = atom(null, (_, set, marker: string) =&amp;gt; {
  set(TestStoreInfo.store, prev =&amp;gt; ({
    ...prev,
    marker,
  }))
})

const onToggleBottomSheetShow = atom(null, (get, set) =&amp;gt; {
  set(TestStoreInfo.store, prev =&amp;gt; ({
    ...prev,
    sheetShow: !prev.sheetShow,
  }))
})

export const TestStoreActions = {
  onChangeMarker,
  onToggleBottomSheetShow,
  onChangeRegion,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 Store 에서 사용할 Action 들을 정의해둔다.&lt;br&gt;
마지막으로 selector 를 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { TestStoreModel } from &amp;quot;./store&amp;quot;

export const MainMapStoreSelector = {
  sheetShow: (store: TestStoreModel) =&amp;gt; store.sheetShow,
  region: (store: TestStoreModel) =&amp;gt; store.region,
  marker: (store: TestStoreModel) =&amp;gt; store.marker,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;store 에서 selector 로 사용할 부분을 정의한다.&lt;/p&gt;
&lt;p&gt;jotai 는 자유도가 아주 높기 때문에
actions 나 selecor 모두 다양하게 변형 시킬 수 있다.&lt;br&gt;
위 예제는 정말정말 간단한 부분만 정의했기 때문에&lt;br&gt;
사용할때는 각자 필요한 만큼 커스텀 해서 사용하자.&lt;/p&gt;
&lt;h2&gt;React 에서 사용할때?&lt;/h2&gt;
&lt;p&gt;이제 selector, store, actions 를 조합하여 React 에서 사용할 수 있도록&lt;br&gt;
커스텀 훅을 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// use-test-store-hook.ts
import { TestStoreActions } from &amp;quot;./config/actions&amp;quot;
import { TestStoreSelector } from &amp;quot;./config/selector&amp;quot;
import { TestStoreInfo } from &amp;quot;./config/store&amp;quot;

export const useTestStore = () =&amp;gt; {
  const { store, initialTestStoreProp } = TestStoreInfo

  return {
    store,
    actions: TestStoreActions,
    selector: TestStoreSelector,
    initialTestStoreProp,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 어떤 컴포넌트 에서도 useTestStore 를 활용하여 TestStore 에 접근이 가능하다.&lt;br&gt;
만약 여러 Store 를 만들어서 활용하고 싶다면?&lt;br&gt;
다른 Config 를 하나 더 만들어 해당 Hook 에 포함하면 된다.&lt;br&gt;
이런식으로&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const useTestContainerStore = () =&amp;gt; {
  const { store: testStore, initialTestStoreProp } = TestStoreInfo
  const { store: modalStore, initialModalStoreProp } = ModalStoreInfo

  return {
    store: {
      test: testStore,
      modal: modalStore,
    },
    actions: {
      test: TestStoreActions,
      modal: ModalStoreActions,
    },
    selector: {
      test: TestStoreSelector,
      modal: ModalStoreSelector,
    },
    initialTestStoreProp,
    initialModalStoreProp,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;계속 확장이 가능하다.&lt;br&gt;
실제로 사용할때는 어떤식으로 쓸까&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const TestComponent = () =&amp;gt; {
  const { store, actions, selector } = useTestStore()

  // Selector 예제
  const marker = useAtomValue(
    selectAtom(store.testStore, selector.testStore.marker)
  )
  const sheetShow = useAtomValue(
    selectAtom(store.modalStore, selector.modalStore.sheetShow)
  )

  // actions 예제
  const onToggleSheetShow = useSetAtom(
    actions.testStore.onToggleBottomSheetShow
  )
  const onChangeMarker = useSetAtom(actions.modalStore.onChangeMarker)

  return (
    &amp;lt;div&amp;gt;
      {marker}
      {sheetShow}

      &amp;lt;ContainedButton
        onClick={() =&amp;gt; onChangeMarker(&amp;quot;당근&amp;quot;)}
        children=&amp;quot;Marker Actions&amp;quot;
      /&amp;gt;
      &amp;lt;ContainedButton onClick={onToggleSheetShow} children=&amp;quot;sheetShow&amp;quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그냥 이렇게 원하는 Store 에서 원하는 selector 와 action 을 가져다&lt;br&gt;
사용하면 된다.&lt;/p&gt;
&lt;h2&gt;Provider 는?&lt;/h2&gt;
&lt;p&gt;이제 다시 Provider 를 살펴보자.&lt;br&gt;
어쨌든 Atom 은 React 의 life cycle 외부에 정의해야 하기 때문에&lt;br&gt;
기본적으로 Global 로 동작하게 된다.&lt;/p&gt;
&lt;p&gt;이렇게 되면 프로젝트가 커질수록 추적이 힘들고 공유 컴포넌트나 기능에서&lt;br&gt;
같은 Store 를 사용하기 힘들다.&lt;/p&gt;
&lt;p&gt;이제 Provider 로 경계를 맞춰주면 되긴 하는데, 이왕 감싸는거&lt;br&gt;
다양한 Store 와 초기 값을 넣어 줄 수 있도록 Util 을 만들어 보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { PropsWithChildren, ReactNode } from &amp;#39;react&amp;#39;;
import { Provider, WritableAtom } from &amp;#39;jotai&amp;#39;;
import { useHydrateAtoms } from &amp;#39;jotai/utils&amp;#39;;

type AnyWritableAtom = WritableAtom&amp;lt;unknown, any[], any&amp;gt;;
export type AtomTuple&amp;lt;A = AnyWritableAtom, V = unknown&amp;gt; = readonly [A, V];

interface ProviderByJotaiProps {
  store: AtomTuple[];
}

type HydrateAtomsWithInitial = {
  children: ReactNode;
};

export function ProviderByJotai({ store, children }: PropsWithChildren&amp;lt;ProviderByJotaiProps&amp;gt;) {
  const HydrateAtoms = ({ children }: HydrateAtomsWithInitial) =&amp;gt; {
    useHydrateAtoms([...store]);
    return children;
  };

  return (
    &amp;lt;Provider&amp;gt;
      &amp;lt;HydrateAtoms&amp;gt;{children}&amp;lt;/HydrateAtoms&amp;gt;
    &amp;lt;/Provider&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 Provider 를 만들며 사용하고 싶은 Store 를 주입 받는&lt;br&gt;
Provider Util 을 만들었다.&lt;/p&gt;
&lt;p&gt;실제로 사용하려면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const TestComponent = ({ children }: PropsWithChildren&amp;lt;unknown&amp;gt;) =&amp;gt; {
  const { store, initialTestStoreProp, initialModalStoreProp } = useTestStore()

  return (
    &amp;lt;ProviderByJotai
      store={[
        [store.testStore, initialTestStoreProp],
        [store.modalStore, initialModalStoreProp],
      ]}
    &amp;gt;
      {children}
    &amp;lt;/ProviderByJotai&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 Provider 에 원하는 Store 와 초기 값을 배열로 넣어 줄 수 있다.&lt;br&gt;
이제 testStore 와 modalStore 는 해당 children 안에서 global 이 아니고
별도로 작동하게 된다.&lt;/p&gt;
&lt;h2&gt;Util을 좀 더 만들어보자&lt;/h2&gt;
&lt;p&gt;여기서 몇가지 Util 을 추가 해보자.&lt;br&gt;
jotai 의 홈페이지에도 있는 useSelectAtom, useSplitAtom 을 추가하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// use-select-atom.ts
import { Atom, useAtomValue } from &amp;quot;jotai&amp;quot;
import { selectAtom } from &amp;quot;jotai/utils&amp;quot;

export const useSelectAtom = &amp;lt;T, Slice&amp;gt;(
  anAtom: Atom&amp;lt;T&amp;gt;,
  keyFn: (v: T, prevSlice?: Slice) =&amp;gt; Slice
) =&amp;gt; {
  return useAtomValue(selectAtom(anAtom, keyFn))
}

/// useAtomValue(selectAtom(store, selector.marker)) 해당 부분을
/// useSelectAtom(store, selector.marker) 이렇게 사용가능하다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;SplitAtom 은 배열 내부에 있는 값들을 별도의 Atom 으로 추출하여&lt;br&gt;
개별적으로 작동하도록 만드는 기능이다.&lt;br&gt;
배열 내부의 값 하나하나에 별도로 동작하는 렌더링을 주고 싶을때 아주 좋은 기능이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// use-split-atom.ts
import { PrimitiveAtom, useAtom } from &amp;quot;jotai&amp;quot;
import { splitAtom } from &amp;quot;jotai/utils&amp;quot;

export const useSplitAtom = &amp;lt;Item&amp;gt;(anAtom: PrimitiveAtom&amp;lt;Array&amp;lt;Item&amp;gt;&amp;gt;) =&amp;gt; {
  return useAtom(splitAtom(anAtom))
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 2개의 기능은 어짜피 Jotai 홈페이지에 나와있다.&lt;br&gt;
가져다 썼을 뿐이고..&lt;/p&gt;
&lt;p&gt;실제로 귀찮은 부분은 따로 있었다.&lt;br&gt;
action 을 사용할때&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// action 을 사용할때 useSetAtom 으로 감싸야 한다.
const onToggleSheetShow = useSetAtom(actions.testStore.onChangeMarker)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;action 사용시 useSetAtom 을 적어주기 힘들다. 아니 귀찮다.&lt;br&gt;
어짜피 hook 으로 사용된다면 actions 에 정의한 함수를 useTestStore 에서&lt;br&gt;
미리 지정해주면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;그래서 createActions 를 만들었다.🤡&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// jotai-create-actions
import { ExtractAtomArgs, WritableAtom, useSetAtom } from &amp;#39;jotai&amp;#39;;

type WithInitialValue&amp;lt;Value&amp;gt; = {
  init: Value;
};

type actionsType&amp;lt;T&amp;gt; = {
  [k in keyof T]: WritableAtom&amp;lt;null, ExtractAtomArgs&amp;lt;T&amp;gt;, void&amp;gt; &amp;amp; WithInitialValue&amp;lt;null&amp;gt;;
};

type WrappedActions&amp;lt;T&amp;gt; = {
  [K in keyof T]: ReturnType&amp;lt;typeof useSetAtom&amp;lt;null, ExtractAtomArgs&amp;lt;T[K]&amp;gt;, void&amp;gt;&amp;gt;;
};

export const jotaiCreateActions = &amp;lt;T&amp;gt;(actions: actionsType&amp;lt;T&amp;gt;) =&amp;gt; {
  return {
    ...(Object.fromEntries(
      Object.entries(actions).map(([key, action]) =&amp;gt; {
        return [
          key,
          useSetAtom(
            action as WritableAtom&amp;lt;null, ExtractAtomArgs&amp;lt;T&amp;gt;, void&amp;gt; &amp;amp; WithInitialValue&amp;lt;null&amp;gt;,
          ),
        ];
      }),
    ) as WrappedActions&amp;lt;T&amp;gt;),
  };
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;actions 를 돌면서 자동으로 함수를 useSetAtom 으로 감싸준다.
이제 useTestStore 훅에서 해당 함수를 사용해주자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ...
return {
  store: {
    test: testStore,
    modal: modalStore,
  },
  actions: {
    test: jotaiCreateActions &amp;lt; typeof TestStoreActions &amp;gt; TestStoreActions,
    modal: jotaiCreateActions &amp;lt; typeof ModalStoreActions &amp;gt; ModalStoreActions,
  },
  selector: {
    test: TestStoreSelector,
    modal: ModalStoreSelector,
  },
  initialTestStoreProp,
  initialModalStoreProp,
}
// ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 해두면 이제 사용할때 useSetAtom 으로 감쌀 필요가 없다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { actions } = useTestStore()
// actions 예제
const onToggleSheetShow = actions.testStore.onToggleBottomSheetShow()
const onChangeMarker = actions.modalStore.onChangeMarker()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아 귀찮은 부분을 조금씩 지워나가고 있으니 속이 시원하다.&lt;br&gt;
Jotai 의 장점이다. 자유도가 뛰어나기 때문에 util 이나 custom hook 을&lt;br&gt;
어떤식으로 만들지는 사용자의 손에 달려있다.&lt;/p&gt;
&lt;p&gt;추가로 살펴 볼 유용한 Util 은&lt;br&gt;
focusAtom 과 atomWithObservable 이다.&lt;/p&gt;
&lt;p&gt;그리고 중첩 Provider 사용시 유용한 jotai-molecules.&lt;br&gt;
모두 설명하기엔 힘드니, 사용법을 보고 꼭 적용시켜보길.&lt;/p&gt;
&lt;p&gt;위 컨벤션은 Jotai 를 처음 도입할때 도움이 되길 바라는 초기 컨벤션 이며,&lt;br&gt;
여기서 util 을 더 추가하고, 불편한 부분은 수정하면서&lt;br&gt;
각자의 프로젝트에 맞게 변형해서 더욱 효율적이고 편하게 활용해보면 된다.&lt;/p&gt;
&lt;p&gt;글을 짧게 쓰려 했는데 쓰다보니 많아졌다.&lt;br&gt;
하고 싶은 말이 더 많지만 이것도 줄이고 줄였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;혹시나 잘못된 부분이나 오타가 있다면 알려주면 감사하겠습니다.🥹&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그럼 손가락이 아파서 이만.🥹&lt;/p&gt;</content:encoded></item><item><title><![CDATA[MFE 로 프로젝트를 전환]]></title><description><![CDATA[이번에 회사에서 진행하던 프로젝트를 기존 모놀리식 에서 MFE 로 전환 하였다. 현재는 stable…]]></description><link>https://willowryu.github.io/2022-11-28/</link><guid isPermaLink="false">https://willowryu.github.io/2022-11-28/</guid><pubDate>Mon, 28 Nov 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이번에 회사에서 진행하던 프로젝트를 기존 모놀리식 에서 MFE 로 전환 하였다.&lt;br&gt;
현재는 stable 한 상태가 되었기에 간단하게 프로젝트를 전환 할때의 경험과&lt;br&gt;
필요한 부분을 적어본다.&lt;/p&gt;
&lt;p&gt;이 글은 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 을 이용한다는 가정하에 작성한다.&lt;br&gt;
사실 다른 라이브러리도 크게 다르진 않을 것이다.&lt;br&gt;
다만 &lt;code class=&quot;language-text&quot;&gt;module federation&lt;/code&gt; 을 지원하지 않는 번들러 라면&lt;br&gt;
차이가 있을 수 있다.&lt;/p&gt;
&lt;h2&gt;일단 전환을 해야 할까?&lt;/h2&gt;
&lt;p&gt;가장 먼저 생각해야 할 부분은 현재 프로젝트를 개발하면서 어떤 불편함이 있는지&lt;br&gt;
먼저 생각해야 한다.&lt;/p&gt;
&lt;p&gt;현재 체계적으로 리뷰가 이루어지고, 컨벤션이 명확하며 CI/CD 를 구성하는데 있어서&lt;br&gt;
큰 불편함이 없다고 생각 된다면, 굳이? 라고 말하고 싶다.&lt;/p&gt;
&lt;p&gt;왜냐하면 전환을 하기 위한 비용이 생각보다 많이 든다.&lt;br&gt;
CI/CD 구축에 있어서 많은 시행착오가 있을수도 있다.&lt;br&gt;
그리고 많이 복잡하며, 변경된 개발 방식이 낯설수도 있다.&lt;/p&gt;
&lt;p&gt;경험이 많은 구성원들이 많을수록 그나마 유리하며, 해당 방식에 익숙하지 않다면&lt;br&gt;
반발이 있을수도 있다. (팀원들을 설득해야 한다.)&lt;br&gt;
그 모든것을 감당하고 시간적 여유까지 있다면 전환 할 가치는 충분하다고 본다.&lt;/p&gt;
&lt;p&gt;본인은 현재 진행중인 프로젝트가 너무 커지고, 팀은 시니어가 부족한 상태 였으며&lt;br&gt;
빌드에 많은 시간이 소요되고, 동시에 너무 많은 기능개발이 시작되면서&lt;br&gt;
코드 병합에도 불편함을 느끼는 상태였다.&lt;/p&gt;
&lt;p&gt;시니어가 부족하다는 점 빼고는 전환 할 이유가 충분했다.&lt;br&gt;
지금이 아니면 일정에 치여서 계속 늦춰질 것 같았다.&lt;br&gt;
귀찮다고 힘들다고 현재에 만족하면 안된다.&lt;/p&gt;
&lt;h2&gt;monorepo&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/c44c876a03eb21813371919b0ea9601d/97a96/1128-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.02702702702703%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAACS0lEQVQozx3IW0/aAACG4f7C3cy4U6ZbopRDHB4oYFtoSwVFQKcI4lrBjVIRQTbDqRgISGupQMBMdDMgKtGxbC5GFy+2m3Umz8X7fUDb/+SUftwNDfxIQXcJ8A+n+cup7qP995FHv0N9J5Dnq3G1bWO7VKqzED/3JS6o1CEarCk9NbUXOFl4fuB6VX4LdT+M32yMfWORCwa7o/tvqb4b37O67l3NEKwjwc/22NFioulOCo5EYWwtp6LyGho4tb8skpDotH5fM106X4hWXZuavg1M/Jp7+nNukIf8hfGggEUOqdwxK8g4zy6jj21rAtsj74EzcqiNDfYWx66j7q5N0Zt6fbduu/bjPXLg0qrI6JmkPrJP5S8L1eamcBQRrgqVgjcfHl0Pa1mgg6g6sKqJjJ9ib87kJieOCegMVZ6jyjY6sgmF40Sy5BcacaEc2iuzYjVaytE8a9peHd0ETnRaQU9kkMWWhWihxh2DvWRxt2DjlwltE4LWDFuMJZtdFRvxCh+u7Iakxqdqmt4L4Gmv7iNQ18KiGjmecvQ21hsQXtZMdmm64/HV1PqK1rwMJ93oTnR5r85JWVbiGPEgK8nTjWTdMAfwaguvJEStbR928GqSVxEVeHbfOMMr8aLG6kJ3Zkz5ebIYWJKYlSqzUgt4pDmyaEdzs6Y8kAGdGdCVUjhTQ4406JI7PTSbHnZwoCOpnCfNBQznMXOJwPlpmygj8BJm3sWwkgyIKTz/gQ8eegv0xkDv1vBSBPQhmGDApUm8LDNgosyIy8rGh+cf9Ad3hINO+XwAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;monorepo&quot;
        title=&quot;monorepo&quot;
        src=&quot;/static/c44c876a03eb21813371919b0ea9601d/fcda8/1128-1.png&quot;
        srcset=&quot;/static/c44c876a03eb21813371919b0ea9601d/12f09/1128-1.png 148w,
/static/c44c876a03eb21813371919b0ea9601d/e4a3f/1128-1.png 295w,
/static/c44c876a03eb21813371919b0ea9601d/fcda8/1128-1.png 590w,
/static/c44c876a03eb21813371919b0ea9601d/efc66/1128-1.png 885w,
/static/c44c876a03eb21813371919b0ea9601d/c83ae/1128-1.png 1180w,
/static/c44c876a03eb21813371919b0ea9601d/97a96/1128-1.png 2400w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MFE 의 목적은 한덩어리로 뭉쳐진 개발코드를 별도의 module 또는 package 로&lt;br&gt;
분리하여 독립적으로 개발하도록 하는 것 이다.&lt;/p&gt;
&lt;p&gt;이렇게 되면 각각의 모듈은 빌드와 테스트, 개발에 있어서 완전히 독립적으로 진행되고&lt;br&gt;
모듈 간의 의존성이 아주 얕아지기 때문에 충돌이 현저히 줄어든다.&lt;/p&gt;
&lt;p&gt;변경된 모듈의 빌드와 배포만 이루어지기 때문에,&lt;br&gt;
한덩어리로 개발 할때와는 다르게 빌드,배포,TEST 등의 시간이 현저히 줄어든다.&lt;br&gt;
내가 조그만 부분을 변경한다고 현재 프로젝트 전체를 다시 빌드 할 필요가 없는 것이다.&lt;/p&gt;
&lt;p&gt;여기서 monorepo 를 추천하는 이유는 공유 모듈과 설정을 사용하기 쉽고,&lt;br&gt;
각각의 모듈을 한눈에 보기 편하다.&lt;/p&gt;
&lt;p&gt;아무리 모듈을 독립적으로 개발한다고 해도 분명히 공유해야 할 기능, 디자인,&lt;br&gt;
assets, 그리고 각종 type, gql 을 사용한다면 fragment, schema 등&lt;br&gt;
shared 한 부분이 생각보다 상당히 많다.&lt;/p&gt;
&lt;p&gt;그리고 monorepo 를 적극적으로 추천하는 또 한가지 큰 이유는 버전 관리 때문이다.&lt;br&gt;
각각의 모듈은 각자의 package.json 즉 패키지 관리자를 가지고 있다.&lt;br&gt;
여기서 어떤 모듈은 react v17 을 쓰고 어디는 react v18 을 쓰고 있다면?&lt;br&gt;
만약 버전을 최신 버전으로 모두 올려주고 싶다면 모든 모듈에서 update 를 진행해야 한다?&lt;/p&gt;
&lt;p&gt;그러고 싶은 개발자는 없으리라 본다.&lt;br&gt;
monorepo 가 정상적으로 돌아가기 위해선 package 의 버전 불일치를 해결하고,&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;single version policy&lt;/code&gt; 를 최대한 준수 해야 한다.&lt;/p&gt;
&lt;p&gt;monorepo 의 루트 에서 모든 모듈이 공통으로 사용하는 패키지를 정의하고,&lt;br&gt;
그 외엔 각각이 모듈이 각자 필요한 package 를 설치하면 된다.&lt;/p&gt;
&lt;p&gt;버전 불일치에 대한 걱정을 덜어내고, 그외 eslint, prettier, tsconig 등&lt;br&gt;
개발 시 필요한 설정을 모든 모듈이 같은 규칙을 사용하도록 쉽게 공유 할 수 있다.&lt;br&gt;
monorepo 를 택하지 않을 이유가 없다.&lt;/p&gt;
&lt;p&gt;monorepo 로 전환하기로 결정했다면 일단 기존의 npm, yarn 은 버리고&lt;br&gt;
pnpm 으로 이동하는 걸 추천한다.&lt;br&gt;
yarn berry pnp 는 아직 불안정하기 때문에 현재로선 추천하지 않는다.
만약 본인이 고통을 즐기고 싶다면 도전해보면 된다.&lt;/p&gt;
&lt;h2&gt;Module federation&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b62373facaca54dc9e2100802b7478d9/e5166/1128-2.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 65.54054054054055%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQL/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQP/2gAMAwEAAhADEAAAAZ2o7edBhF//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIREBL/2gAIAQEAAQUClnomnkcS0//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/AYf/xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CIv8A/8QAHBABAQAABwAAAAAAAAAAAAAAAQARITFBUbHB/9oACAEBAAE/IWJbuIWQlpL15chML//aAAwDAQACAAMAAAAQXy//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAEDAQE/EE8Kf//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQIBAT8QeiI//8QAHxABAAIBBAMBAAAAAAAAAAAAAQARITGBwfBBYZGh/9oACAEBAAE/ECCpqaDGUb+QOInouXOOqd/IlHXlxBDqFYd+a2n/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;federation&quot;
        title=&quot;federation&quot;
        src=&quot;/static/b62373facaca54dc9e2100802b7478d9/1c72d/1128-2.jpg&quot;
        srcset=&quot;/static/b62373facaca54dc9e2100802b7478d9/a80bd/1128-2.jpg 148w,
/static/b62373facaca54dc9e2100802b7478d9/1c91a/1128-2.jpg 295w,
/static/b62373facaca54dc9e2100802b7478d9/1c72d/1128-2.jpg 590w,
/static/b62373facaca54dc9e2100802b7478d9/a8a14/1128-2.jpg 885w,
/static/b62373facaca54dc9e2100802b7478d9/fbd2c/1128-2.jpg 1180w,
/static/b62373facaca54dc9e2100802b7478d9/e5166/1128-2.jpg 1200w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;각각의 Module 을 개발한 뒤 host app 에서 이들을 workspace 형식으로&lt;br&gt;
설치해서 개발 할 수 있다.&lt;br&gt;
그렇게 해도 되지만 그러기엔 굉장히 불편한 점이 있다.&lt;/p&gt;
&lt;p&gt;monorepo 로 인해 각각의 모듈을 충돌없이 각자 개발할 수 있도록 변경했다.&lt;br&gt;
하지만 내가 개발한 모듈을 host app 에서 적용 시키기 위해서는?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;개발은 각각의 모듈이 따로 개발되지만, 실제로 변경사항이&lt;br&gt;
host app에 적용되려면 host를 또 다시 빌드를 해줘야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기서 host 를 다시 빌드 하지 않고, 변경된 모듈이 자동으로 적용될 수 있다면?&lt;br&gt;
host 가 런타임일때 동적으로 변경된 모듈만 알아서 적용할 수 있도록 해주는 기능이&lt;br&gt;
Module federation 이다.&lt;/p&gt;
&lt;p&gt;변경된 모듈만 빌드하고, 배포하고 적용하고 host 는 실시간으로 이런 변경사항을&lt;br&gt;
가져올 수 있다.&lt;br&gt;
module federation 은 webpack 에서 유명한 기능으로 알고 있지만,&lt;br&gt;
vite.js 에서도 이를 지원하며, 심지어 서로 호환도 가능하다.&lt;/p&gt;
&lt;h2&gt;Nx, Turborepo&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/10443613606829b3490ccab4f4016811/07f3a/1128-4.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAgAF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAP/2gAMAwEAAhADEAAAAc8irNRj/8QAGRAAAgMBAAAAAAAAAAAAAAAAAQIAEBEh/9oACAEBAAEFAlTVC7Dw3//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABsQAQABBQEAAAAAAAAAAAAAAAEAEiAyUWFx/9oACAEBAAY/AlqDkyD2bs//xAAbEAABBAMAAAAAAAAAAAAAAAABABEgQSExYf/aAAgBAQABPyED7ha0LdIGBx0If//aAAwDAQACAAMAAAAQ6C//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAgEFAQAAAAAAAAAAAAABACEREFFxkaGx/9oACAEBAAE/EF41bcIqzvyZil3J8JniQ4GOv//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nxturborepo&quot;
        title=&quot;nxturborepo&quot;
        src=&quot;/static/10443613606829b3490ccab4f4016811/1c72d/1128-4.jpg&quot;
        srcset=&quot;/static/10443613606829b3490ccab4f4016811/a80bd/1128-4.jpg 148w,
/static/10443613606829b3490ccab4f4016811/1c91a/1128-4.jpg 295w,
/static/10443613606829b3490ccab4f4016811/1c72d/1128-4.jpg 590w,
/static/10443613606829b3490ccab4f4016811/07f3a/1128-4.jpg 740w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;monorepo 와 module federation 을 적용한다면 이제 각각의 모듈을&lt;br&gt;
독립적으로 개발할 준비가 되었다.&lt;br&gt;
오 이제 체계적으로 모듈을 독립적으로 개발하고 빌드하고 배포하고 해피합니다 라고&lt;br&gt;
말하기에는 아직 넘어야 할 산이 있다.&lt;/p&gt;
&lt;p&gt;그래서 빌드와 배포는 어떻게 할 것인가?&lt;br&gt;
만약 모듈 A, 모둘 B, host 모듈 이렇게 3개의 모듈이 있을때&lt;br&gt;
모듈 A 를 수정하고 빌드, 배포를 하고 싶다고 한다면 CI 를 어떻게 구축해야 할까?&lt;/p&gt;
&lt;p&gt;아니 그전에 CI 에서 내가 모듈 A만 변경했어요 라고 알수 있을까?&lt;br&gt;
모듈별로 ci 를 만들어야 할까 아니면 커밋 메시지나 태그등 별도의 표시로&lt;br&gt;
해당 모듈만 빌드하고 배포 할수 있도록 해야하나?&lt;/p&gt;
&lt;p&gt;다 불완전하고 좋지 않은 방법이다.&lt;br&gt;
우리가 원하는 방법은 간단한 명령어만으로 특정 모듈의 변경을 감지하고&lt;br&gt;
해당 모듈에 대해서만 명령을 실행하고&lt;br&gt;
추가로 변경되지 않은 모듈은 빌드된 파일을 미리 캐시 해두고&lt;br&gt;
불러올 수 있으면 좋을 것 같다.&lt;/p&gt;
&lt;p&gt;저런게 어딨냐고 할수 있겠지만, 이미 해당 기능을 장착한 라이브러리가 존재한다.&lt;br&gt;
그 중 유명한 2개가 바로 Nx 와 Turborepo 이다.&lt;/p&gt;
&lt;p&gt;이 라이브러리들은 위에서 말한 기능을 전부 지원한다.&lt;br&gt;
추가로 remote cache 까지 해주기 때문에 내가 어느 pc에서 작업한다고 해도&lt;br&gt;
이전에 빌드 된 모듈이라면 빌드 된 파일을 아주 빠르게 불러올 수 있다.&lt;/p&gt;
&lt;p&gt;자세한 설정을 적기엔 너무 길기때문에 해당 도구들의 홈페이지에서 직접 살펴 보길 바란다.&lt;/p&gt;
&lt;h2&gt;MFE 환경 구축 완성?&lt;/h2&gt;
&lt;p&gt;이제 큰 틀은 잡혔다.&lt;br&gt;
monorepo 로 손쉬운 버전관리와 공유모듈을 쉽게 사용할 수 있고,&lt;br&gt;
module federation 이 합쳐지면서 모듈이 독립적으로 빌드,배포 되면서&lt;br&gt;
작동 할 수 있도록 전환되었고,&lt;br&gt;
turborepo, nx 로 ci 구축 시 변경된 모듈에서만 원하는 명령을 실행 할 수 있다.&lt;/p&gt;
&lt;p&gt;사실 말로는 쉽게 적었지만 위 환경을 구축하는데 수많은 시행착오가 있을 것이다.&lt;br&gt;
env 의 설정과 각각 다른 stage 환경에 관한 배포 방법, 공유 모듈과 설정의 사용,&lt;br&gt;
그리고 ci/cd 를 설정 할때 어떤 규칙을 적용할 것인지 등등&lt;/p&gt;
&lt;p&gt;이 수많은 문제는 팀원들과 충분히 논의하고 연구하여 각자의 팀에 맞는 환경을 구축하길 빈다.&lt;/p&gt;
&lt;p&gt;그럼 여기서 보너스로 사실 이정도 환경만 구축 해두어도 기본적인 MFE 환경을
사용하는데 크게 무리는 없을 것이다.&lt;/p&gt;
&lt;p&gt;여기서 MFE 구축과 같이 추천하는 전략이 있는데 바로 &lt;code class=&quot;language-text&quot;&gt;TBD&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h2&gt;trunk based development&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b61ba0f327082712aa4e75364dba4629/f8067/1128-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3ElEQVQoz1VSS4/SUBTuPxtBFxr9J+o8dOfG2epiEnDp3lk4yTiYEAMESAyQ2YA42F5a+hhKebQ8+qSF3tv6DcjCk9OT73xfz+k955ZLkhQWhuF0OjUP1u12O5026fctazabPfCOvRqPx+12GxLP87Zto4rD46zTiRUwukUjxhiYle1O5iGAMfO8IAJvmD7aQKWU7t95KP5+S7/+pOZyzRKKQ+zOkVrWoveHEIEQUZEVTZbVxcrbbDbpwdAOzv1SmGmjZJPsB/insblp6PeyNRsZuuo6yxStWZz+b9znH/TTTfDhi3VxZV9cOTsHWOW/+eDh+Ws3d+18vDQPkp0vxLmb+LbPuOfn26fvrMwxnz3tZ8/EzAl5/Gbw6HUve0oyx0L2TDp69TtzIhy97Dx5qwDAX5xHz95HuULMGfNYHLpDE9FTJ5FuUW260U0q6QFRHeDBaC0OfUgD3R+MAnUcjheYlGFMbjfilsah760AkEVhgJWmCQt8e7fYhG4DkLttxgD7bSPhlsuloqgDWZYVxTCM0cgQJQmppt0jqppGCOF54e6uhyiKEi4ZuiAQ3BwXRRFq8AO0Wq1isVitVpvNZqPRKBQK9Xq9XC5XKpVSqQRcq9WgAuBDkiS5rvsX71YDkZf0LNIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tbd&quot;
        title=&quot;tbd&quot;
        src=&quot;/static/b61ba0f327082712aa4e75364dba4629/fcda8/1128-3.png&quot;
        srcset=&quot;/static/b61ba0f327082712aa4e75364dba4629/12f09/1128-3.png 148w,
/static/b61ba0f327082712aa4e75364dba4629/e4a3f/1128-3.png 295w,
/static/b61ba0f327082712aa4e75364dba4629/fcda8/1128-3.png 590w,
/static/b61ba0f327082712aa4e75364dba4629/f8067/1128-3.png 726w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;들어본 사람도 있겠지만 google 에서 한다는 그 TBD 이다.&lt;br&gt;
간단하게 별도의 기능 브랜치 생성이 아닌 하나의 main repo 로 운영하는 방법이다.&lt;br&gt;
그리고 그 main repo 는 언제든지 릴리즈 할 준비가 되어 있어야 한다.&lt;/p&gt;
&lt;p&gt;TBD 운영에 있어서는 많은 원칙이 있지만&lt;br&gt;
main 이 아닌 branch 의 수명이 짧아야 하고,&lt;br&gt;
내가 개발중인 기능을 작게 조각내어 커밋을 자주 해야 한다.&lt;/p&gt;
&lt;p&gt;짧은 주기의 커밋은 컨플릭트의 발생을 없애고, 타 팀원들이 내 코드를&lt;br&gt;
리뷰하기 쉬우며, 코드 실수의 위험성을 줄일 수 있다.&lt;/p&gt;
&lt;p&gt;그외 자세한 원칙은 &lt;a href=&quot;https://trunkbaseddevelopment.com/&quot;&gt;TBD&lt;/a&gt; 여기서 확인해보자.&lt;br&gt;
구글이 직접 적은 메뉴얼이다.&lt;/p&gt;
&lt;p&gt;그리고 언제든지 release 가 가능하도록 main repo 를 유지 해야 한다는게 가장&lt;br&gt;
중요한데 이를 위해서는 현재 개발중인 기능과 배포 할 기능을 분리 할 필요가 있다.&lt;br&gt;
그걸 위한 기능이 &lt;code class=&quot;language-text&quot;&gt;feature flag&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;말그대로 flag 를 이용하여 배포할 때 개발중인 기능을 숨기고 배포 할수 있도록 한다.&lt;br&gt;
당연히 feature flag 를 운영에도 많은 원칙이 있다.&lt;br&gt;
해당 부분도 위 TBD 메뉴얼에 있으니 꼭 함께 보길 추천한다.&lt;/p&gt;
&lt;h2&gt;모든 부분을 통과했다면?&lt;/h2&gt;
&lt;p&gt;축하한다. 이제는 빠른 CI/CD 와 더불어 컨플릭트 지옥에서 벗어나고,&lt;br&gt;
각 모듈의 독립적인 개발로 충돌이 사라지고,&lt;br&gt;
원하는대로 프로젝트를 안전하게 확장 할수있다.&lt;/p&gt;
&lt;p&gt;이상적으로 잘 진행되면 좋겠지만 여기서 내가 구축하며 생긴 의문들을 정리해본다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;각 모듈별로 다른 fe 프레임워크를 사용가능한가?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;가능하다. 하지만 추천하지 않는다. 꼭 써야하는 상황에서만 추천한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 모듈은 federation 으로 하는게 좋을까? 아니면 workspace 방식이 좋을까?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;이건 환경에 따라 다르지만, 개인적으로 디자인 시스템과 같은 공유 모듈은 workspace 방식으로 하는게 안정적이다. (자주 변경되지 않으니)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;module 을 나누는 기준은 어떻게 되야 할까? page? 도메인? 기능?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;이부분은 정확히 vertical 로 나눌지 horizontal 방식으로 할지 팀에서&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;충분히 의논하고 결정해야 한다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;기존에 react-router 나 next js 를 사용했다면 page 별로 나누는 것이&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;익숙 할 것이다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;하지만 당장은 힘들어도 큰 프로젝트를 생각하면 mfe 를 원한다면&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;도메인 또는 기능 별로 나누는 걸 추천한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;feature flag 의 구축은? 관련 lib 는?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;feature flag 를 여유가 된다면 직접 구축 할 수 있지만&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;lib 를 쓰는 것이 편하긴 하다. launch darkly 를 추천한다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;공유 설정 정의와 폴더 구조는?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;eslint, prttier, test 관련 설정과 webpack, tsconfig 의 base 를&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;기본적으로 만들고 추가로, tailwind 나 다른것을 추가하자.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;이건 뭐 lib 나 config 폴더를 만들어서 추가하면 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;module federation 에서 왜 hmr 이 작동하지 않는가?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;module federation 을 처음 개발하면 아마 당황할 것이다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;특히 react 로 진행 했었다면, hmr 이 작동하지 않는걸 볼수있다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;정확히는 remote app 을 사용하는 host 에서는 작동하지 않는다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;공식적으로는 그렇다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;host app 은 설계를 잘한다면, 많이 수정되는 부분이 아니기 때문에&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;상관 없을 수 있지만, 기존의 큰 코드베이스에서 전환하고 있다면&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;이는 문제가 될 수있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;여기서 host 와 remote 모두 hmr 을 작동시키는 트릭이 존재한다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;그 트릭은 설명하려면 조금 길어서 다음 글에 적어보려 한다.&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;일단은 안된다면 host app 을 빈 shell 로 만들고 기존 코드 베이스를&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;remote 로 만들어 개발을 시작하자&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그 외 style 관련 부분과 디자인 시스템, host app 과 연관되지 않는&lt;br&gt;
모듈들의 배포 진행, ci/cd 의 구축방법 등등.
설명해야할 부분이 아주 많다.&lt;br&gt;
monorepo 나아가서 mfe 로의 전환은 쉽지 않은 일이다.&lt;/p&gt;
&lt;p&gt;특히나 TBD 까지 구축한다면 험난한 길이 될 수도 있다.&lt;br&gt;
난 TBD 방식을 아주 좋아하지만, 현재 환경을 구축할 여유가 되지 않는다면,&lt;br&gt;
TBD가 아니어도 상관없다.&lt;br&gt;
TBD가 아니라도 충분히 MFE 의 이점을 누릴 수 있다.&lt;/p&gt;
&lt;p&gt;나머지 기술적인 부분은 당신의 팀이 충분히 설정하고 이겨낼 수 있으리라 생각한다.&lt;/p&gt;
&lt;p&gt;기회가 된다면 다음번에 federation 에서의 hmr 설정과&lt;br&gt;
그외 실제로 사용한 팁이나 코드에 대하여 적어볼까 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Rxjs in React]]></title><description><![CDATA[예전에 운영하던 블로그에서 react 에서 rxjs 를 이용한 간단한 state managenet 기법을 소개한 적 있다. 그 후 몇년이 지난 지금 조금 더 업데이트 된 좋은 패턴을 소개하려 한다. 참고로 현재 프로젝트에서 사용하는 패턴이다. rxjs…]]></description><link>https://willowryu.github.io/2022-05-31/</link><guid isPermaLink="false">https://willowryu.github.io/2022-05-31/</guid><pubDate>Tue, 31 May 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;예전에 운영하던 블로그에서 react 에서 rxjs 를 이용한&lt;br&gt;
간단한 state managenet 기법을 소개한 적 있다.&lt;/p&gt;
&lt;p&gt;그 후 몇년이 지난 지금 조금 더 업데이트 된 좋은 패턴을&lt;br&gt;
소개하려 한다. 참고로 현재 프로젝트에서 사용하는 패턴이다.&lt;/p&gt;
&lt;p&gt;rxjs 를 아예 모른다면 이해하기 힘들 수 있으니, 모른다면&lt;br&gt;
조금은 공부하고 봤음 한다.&lt;/p&gt;
&lt;h2&gt;rxjs 로 react 에서 무엇을 할 수 있을까?&lt;/h2&gt;
&lt;p&gt;이에 대한 답은 거의 모든 것을 할 수 있다.&lt;br&gt;
state management 는 물론, dom event, 손위운 web socket 제어,&lt;br&gt;
동기 또는 비동기 이벤트 작성 등 프로젝트에서 작성하는 모든 이벤트를&lt;br&gt;
rxjs 를 이용해 쉽게 작성이 가능하다.&lt;/p&gt;
&lt;p&gt;물론 rxjs 가 없어도 가능하겠지만, 중요한 부분은 &lt;strong&gt;쉽게&lt;/strong&gt; 라는 점이다.&lt;br&gt;
이 글에선 이전과 마찬가지로 상태관리로 사용하는 방법에 중점을 둔다.&lt;/p&gt;
&lt;h2&gt;기본적인 state management 는 뭘 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;redux, mobx, recoil, react context 등 기본적으로 많이 사용하는&lt;br&gt;
state management 라이브러리 들이 존재하지만, 본인은 현재 진행하는 프로젝트에선&lt;br&gt;
상태 관리 라이브러리는 아예 찾아보지도 않았다.&lt;br&gt;
그 많은 보일러플레이트 코드를 사용하기도 싫고, 사용 할 이유도 없었다.&lt;/p&gt;
&lt;p&gt;rest 가 아닌 graphql 을 사용하면, 보통 client 에서 사용하는 라이브러리 에선&lt;br&gt;
query 로 받아오는 데이터는 캐싱을 활용하게 된다.&lt;br&gt;
이로 인해 server 와 연결된 데이터는 별도의 state management 를&lt;br&gt;
사용 할 이유가 없다.&lt;/p&gt;
&lt;p&gt;남아있는 local storage 데이터들을 제외하고, global ui state 와&lt;br&gt;
메모리에 남겨야 할 state 들을 어떻게 관리 할 것인가? 간단하게 rxjs 로 해보자.&lt;/p&gt;
&lt;h2&gt;간단한 counter 예제&lt;/h2&gt;
&lt;p&gt;먼저 간단한 counter 예제를 생각해보자.&lt;br&gt;
increment, decrement 기능이 있고,&lt;br&gt;
view 에선 counter state 를 표시한다.&lt;/p&gt;
&lt;p&gt;가장 기본적으로 코드를 보면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function Counter() {
  const [count, setCount] = useState(0)
  const handleCounter = {
    increment: () =&amp;gt; setCount(count + 1),
    decrement: () =&amp;gt; setCount(count - 1),
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;button onClick={handleCounter.increment}&amp;gt;++++++&amp;lt;/button&amp;gt;
      &amp;lt;button onClick={handleCounter.decrement}&amp;gt;------&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 children 을 더 늘려보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface CounterButtonProps {
  onClick: () =&amp;gt; void;
}

export function IncrementButton({ onClick }: CounterButtonProps) {
  return &amp;lt;button onClick={onClick}&amp;gt;++++&amp;lt;/button&amp;gt;
}

export function DecrementButton({ onClick }: CounterButtonProps) {
  return &amp;lt;button onClick={onClick}&amp;gt;++++&amp;lt;/button&amp;gt;
}

export function Counter() {
  const [count, setCount] = useState(0)
  const handleCounter = {
    increment: () =&amp;gt; setCount(count + 1),
    decrement: () =&amp;gt; setCount(count - 1),
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton onClick={handleCounter.increment} /&amp;gt;
      &amp;lt;DecrementButton onClick={handleCounter.decrement} /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기까진 괜찮다.&lt;br&gt;
다만 이런 상황에서 children 이 더욱 늘어난다면?&lt;br&gt;
또는 해당 버튼이 하나씩만 존재하는게 아니고, 여러 부분에 있어야 한다면?&lt;br&gt;
다들 싫어하는 props drilling 현상이 나타나게 된다.&lt;/p&gt;
&lt;p&gt;이를 방지하기 위한 방법은 여러가지가 있다.&lt;br&gt;
다만 rxjs 는 이를 더 쉽고 우아하게 해결한다.&lt;br&gt;
(위 코드는 단순히 예제로 만든 것이니, 저기서 굳이 쓸 필요 없다는 말은 하지말자.)&lt;/p&gt;
&lt;h2&gt;event 를 만들자&lt;/h2&gt;
&lt;p&gt;위 예제에서 버튼이 onClick 을 props 받지 않고 실행할 수 있는 방법을 생각해보자.&lt;br&gt;
context ? context 는 말그대로 context 의 사용처를 어디서 사용할지 명확하게&lt;br&gt;
제한한다는 점에서 굉장히 좋지만 장황하다.&lt;br&gt;
그리고 만약 처음엔 괜찮지만, 나중에 counter state 를 프로젝트의 여러곳에서 사용한다면?&lt;/p&gt;
&lt;p&gt;redux, recoil ? 등의 global state management 를 사용하는 방법도 있다.&lt;br&gt;
그걸 사용해도 된다. 다만 이후 설명 할 side effect 를 관리하는 방법에선&lt;br&gt;
굉장히 불편하다.&lt;/p&gt;
&lt;p&gt;자 이제 rxjs 로 어떻게 해결하는지 살펴보자.&lt;/p&gt;
&lt;h2&gt;counter service 의 작성&lt;/h2&gt;
&lt;p&gt;counter service 를 만들 것 이다.&lt;br&gt;
해당 서비스는 어디서든 접근 가능하고, 어디서든 조작 가능한 global service 이며,&lt;br&gt;
state 가 없고 단순히 버튼의 이벤트를 처리하는 service 다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const counter$ = new Subject&amp;lt;string&amp;gt;();

export const CounterService = {
  // observable
  onCounter$: () =&amp;gt; counter$.asObservable(),

  // set
  increment: () =&amp;gt; counter$.next(&amp;#39;increment&amp;#39;),
  decrement: () =&amp;gt; counter$.next(&amp;#39;decrement&amp;#39;),
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;counter$ 는 subject 타입으로 우리는 counter$ 를 구독하여,&lt;br&gt;
이벤트를 수신 받을 것이다.&lt;br&gt;
(asObservable 은 subject 를 observable 로만 사용하게 된다.&lt;br&gt;
이는 counter$ 에 접근하여 직접적으로 이벤트를 사용하지 않도록 하기위함이다.)&lt;/p&gt;
&lt;p&gt;위 서비스를 적용해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function IncrementButton() {
  return &amp;lt;button onClick={CounterService.increment}&amp;gt;++++&amp;lt;/button&amp;gt;
}

export function DecrementButton() {
  return &amp;lt;button onClick={CounterService.decrement}&amp;gt;++++&amp;lt;/button&amp;gt;
}

export function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() =&amp;gt; {
    const counter$ = CounterService.onCounter$().subscribe(event =&amp;gt; {
      if (event === &amp;quot;increment&amp;quot;) setCount(prev =&amp;gt; prev + 1)
      if (event === &amp;quot;decrement&amp;quot;) setCount(prev =&amp;gt; prev - 1)
    })

    return () =&amp;gt; counter$.unsubscribe()
  }, [])

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton /&amp;gt;
      &amp;lt;DecrementButton /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;useEffect 에서 우리는 이전에 만든 counterService 의 counter$ 를 구독하게 된다.&lt;br&gt;
버튼을 누르게 되면 increment 또는 decrement 이벤트를 counter$ 로 보내게 되고&lt;br&gt;
counter$ 를 구독 하고 있는 counter 컴포넌트는 해당 이벤트를 받아&lt;br&gt;
counter state 를 변경 하게 된다.&lt;/p&gt;
&lt;p&gt;이제 IncrementButton 과 DecrementButton 은 어디에서 사용해도 되는 독립적인&lt;br&gt;
컴포넌트가 되었다.&lt;/p&gt;
&lt;h2&gt;Event 는 해결 되었다. 그럼 state 는?&lt;/h2&gt;
&lt;p&gt;button 의 독립은 이루어졌지만, state 의 독립은 아직이다.&lt;br&gt;
counter 를 한 곳이 아닌 여러곳에서 사용한다면?&lt;br&gt;
counter state 를 공통으로 사용하도록 해야 한다.&lt;br&gt;
이를 위해서 counter service 를 변경해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const counter$ = new BehaviorSubject() &amp;lt; number &amp;gt; 0

export const CounterService = {
  // observable
  onCounter$: () =&amp;gt; counter$.asObservable(),

  // set
  increment: () =&amp;gt; counter$.next(counter$.value + 1),
  decrement: () =&amp;gt; counter$.next(counter$.value - 1),
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;subject 를 BehaviorSubject 로 변경 하였다.&lt;br&gt;
behavior subject 는 subject 와 다르게 값을 저장하는 기능을 가지고 있다.&lt;br&gt;
BehaviorSubject&lt;number&gt;(0); 여기서 0은 해당 state 의 초기 값이다.&lt;/p&gt;
&lt;p&gt;counter$ 에 새로운 구독이 일어나면 마지막으로 저장된 값을 방출한다.&lt;/p&gt;
&lt;p&gt;이제 counter$ 는 본인의 value를 가지고 있는
하나의 global state 가 되었다.&lt;/p&gt;
&lt;p&gt;(이렇게 하나의 stream 에서 구독자에게 동일한 값을 방출 하는 것을 hot observable 이라고 한다.)&lt;/p&gt;
&lt;p&gt;(반대로 cold observable 은 각 구독자에게 별도의 stream 을 할당한다.&lt;br&gt;
custom hook 과 같이 별도의 state 가 존재하는 것이다.)&lt;/p&gt;
&lt;p&gt;이를 실제로 적용해 본다면&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function Counter() {
  const [count, setCount] = useState(0)
  useEffect(() =&amp;gt; {
    const counter$ = CounterService.onCounter$().subscribe(setCount)

    return () =&amp;gt; counter$.unsubscribe()
  }, [])

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton /&amp;gt;
      &amp;lt;DecrementButton /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;버튼들은 변경 할 필요가 없다.&lt;br&gt;
이미 버튼은 단순히 클릭으로 인한 이벤트를 보낼 뿐, 그 뒤에 어떤일이 일어날지는&lt;br&gt;
알지 못하는 멍청한 컴포넌트가 되었다.&lt;/p&gt;
&lt;p&gt;counter$ 구독으로 얻는 값을 setCount 에 바로 적용하여,&lt;br&gt;
새롭게 렌더링을 하게 되었다.&lt;/p&gt;
&lt;p&gt;이제 원하는 곳에서 onCounter$ 를 구독하여 사용하면 global state 의&lt;br&gt;
역할을 하게 된다.&lt;/p&gt;
&lt;p&gt;그러나, 아직 옵션이 남아있다.&lt;/p&gt;
&lt;h2&gt;Custom hook 과 결합하자.&lt;/h2&gt;
&lt;p&gt;위 예제에서 거슬리는 부분이 2가지가 있다.&lt;br&gt;
useEffect 와 useState 다.&lt;br&gt;
counter 를 쓰는 모든곳에 해당 로직을 넣어주기에는 귀찮은 일이다.&lt;/p&gt;
&lt;p&gt;우리가 counter 를 globalState 로 사용하려고 마음 먹은 이상&lt;br&gt;
counter 를 customHook 으로 만들어 재사용해야 한다.&lt;/p&gt;
&lt;p&gt;그럼 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const useCountState = () =&amp;gt; {
  const [count, setCount] = useState &amp;lt; number &amp;gt; 0
  useEffect(() =&amp;gt; {
    const counter$ = CounterService.onCounter$().subscribe(setCount)

    return () =&amp;gt; counter$.unsubscribe()
  }, [])

  return {
    count,
  }
}

export function Counter() {
  const { count } = useCountState()

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton /&amp;gt;
      &amp;lt;DecrementButton /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;오 아주 깔끔해 진것 같다.&lt;br&gt;
이제 count state 를 사용하고 싶은 곳에선 어디서든&lt;br&gt;
useCountState 를 사용하면 된다.&lt;/p&gt;
&lt;p&gt;하지만 난 아직도 거슬린다.&lt;br&gt;
customHook 을 사용한 건 좋지만, 이왕 rxjs 를 사용한다면&lt;br&gt;
좀더 편한 customHook 이 있으면 좋겠다.&lt;/p&gt;
&lt;p&gt;저기서 countState 를 customHook 으로 만들지 말고,&lt;br&gt;
stream 으로 받는 데이터를 그대로 state 로 쓸 수 있는&lt;br&gt;
hook 을 만들면 좋지 않을까?&lt;/p&gt;
&lt;p&gt;그래서 만들었다.&lt;/p&gt;
&lt;h2&gt;useObservableState Hook&lt;/h2&gt;
&lt;p&gt;useEffect 에 observable 과 관련된 로직을 넣게 되면,&lt;br&gt;
해당 컴포넌트가 리렌더링 될때, unsubscribe 와 subscribe 가 반복된다.&lt;br&gt;
그리고 지금은 괜찮지만, 만약 useEffect 로직이 길어지게 된다면?&lt;/p&gt;
&lt;p&gt;그걸 방지 하기 위해 prop 으로 stream 을 받고 해당 stream 의 값을&lt;br&gt;
state 로 만들어주는 간단한 hook 을 만들어 보았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { useEffect, useState } from &amp;quot;react&amp;quot;
import { Observable, Subscription } from &amp;quot;rxjs&amp;quot;

interface ObservableState {
  &amp;lt;T, K = T&amp;gt;(
    props: ObservableStateProps&amp;lt;T, K&amp;gt; &amp;amp; { initialState?: undefined }
  ): T | K | undefined;
  &amp;lt;T, K = T&amp;gt;(props: ObservableStateProps&amp;lt;T, K&amp;gt;): T | K;
}

interface ObservableStateProps&amp;lt;T, K&amp;gt; {
  obs$: Observable&amp;lt;T&amp;gt;;
  input$?: (input$: Observable&amp;lt;T&amp;gt;) =&amp;gt; Observable&amp;lt;K&amp;gt;;
  initialState?: T | (() =&amp;gt; T);
}

export const useObservableState: ObservableState = &amp;lt;T, K&amp;gt;({
  obs$,
  input$,
  initialState,
}: ObservableStateProps&amp;lt;T, K&amp;gt;) =&amp;gt; {
  const [state, setState] =
    (useState &amp;lt; T) |
    K |
    (undefined &amp;gt;
      (initialState instanceof Function ? initialState() : initialState))

  useEffect(() =&amp;gt; {
    let observableState$: Subscription
    if (input$) {
      observableState$ = obs$.pipe(input$).subscribe(setState)
    } else {
      observableState$ = obs$.subscribe(setState)
    }
    return () =&amp;gt; observableState$ &amp;amp;&amp;amp; observableState$.unsubscribe()
  }, [obs$, input$])

  return state
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;실제로 프로젝트에서 사용하는 hook 이다.&lt;br&gt;
observable 과 pipe, iniitalState 를 받고, 해당 observable 로&lt;br&gt;
받은 데이터를 state 로 return 하며, 자동으로 unsubscribe 까지 해준다.&lt;/p&gt;
&lt;p&gt;사실상 react 에서 rxjs 를 더욱 간편하게 사용하기 위해서&lt;br&gt;
subscribe 와 unsubscribe, 그리고 렌더링을 위한 state 작업을 모아둔&lt;br&gt;
custom hook 이다.&lt;/p&gt;
&lt;p&gt;해당 hook 을 사용하여 다시 정리해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function Counter() {
  const count = useObservableState({
    obs$: CounterService.onCounter$(),
  })

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton /&amp;gt;
      &amp;lt;DecrementButton /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;어마어마 하지 않은가?&lt;br&gt;
이제 global service 로 만드는 모든 state 는 useObservableState 로&lt;br&gt;
가져와서 간단하게 사용이 가능하다.&lt;/p&gt;
&lt;p&gt;거기다 해당 service 에는 어떠한 이벤트도 추가 가능하다.&lt;br&gt;
예를 들어 일반적인 count 뿐만 아니라, count 에서 * 2가 된 값도&lt;br&gt;
같이 보고 싶다면 input$ 에 pipe 를 추가해도 되고,&lt;br&gt;
service 에 추가해도 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type inputType = { count: number, multi: number }

export const CounterService = {
  // observable
  onCounter$: () =&amp;gt; counter$.asObservable(),
  onCounterWithMulti: () =&amp;gt;
    counter$.pipe(map(count =&amp;gt; ({ count, multi: count * 2 }))),

  // set
  increment: () =&amp;gt; counter$.next(counter$.value + 1),
  decrement: () =&amp;gt; counter$.next(counter$.value - 1),
}

export function Counter() {
  const count =
    useObservableState &amp;lt;
    inputType &amp;gt;
    {
      obs$: CounterService.onCounterWithMulti$(),
    }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;span&amp;gt;{count?.count}&amp;lt;/span&amp;gt;
      &amp;lt;span&amp;gt;{count?.multi}&amp;lt;/span&amp;gt;
      &amp;lt;IncrementButton /&amp;gt;
      &amp;lt;DecrementButton /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 하나의 state 로 count * 2 한 값을 같이 볼 수 있다.&lt;br&gt;
이는 count state 가 변경 될때 마다 계속 유지되며,&lt;br&gt;
원본 state 는 변경하지 않고 손쉽게 값을 변경하고 표현 가능하다.&lt;/p&gt;
&lt;p&gt;이런 패턴의 장점은 해당 로직을 어디서든 사용이 가능하다는 것이다.&lt;br&gt;
심지어 service 는 react 가 아닌 다른 프레임워크, 라이브러리 에서도&lt;br&gt;
재사용 가능하다. (rxjs 만 있다면.)&lt;/p&gt;
&lt;h3&gt;결론&lt;/h3&gt;
&lt;p&gt;간단하게 정말, 아주 간단하게 rxjs 를 react 에서 사용하는 패턴을 보았다.&lt;br&gt;
위에 적힌 예는 정말 빙산의 일각이며 실제로 더욱 많은 기능을 손 쉽게&lt;br&gt;
작성이 가능하다.&lt;br&gt;
특히 dom event 를 다룰때 rxjs 를 사용한다면 다신 기본 event 를&lt;br&gt;
사용하기 싫을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReactiveX&lt;/strong&gt; 는 새로운 것도 아니고, 비인기 개념도 아니다.&lt;/p&gt;
&lt;p&gt;ReactiveX: &lt;a href=&quot;https://reactivex.io/languages.html&quot; target=&quot;_blank&quot;&gt;https://reactivex.io/languages.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;홈페이지를 보면 알겠지만, 수많은 주류 언어에서 사용되고 있으며&lt;br&gt;
observable stream 을 이해하기 시작하면, 어떠한 언어에서도 활용이&lt;br&gt;
가능하고, reactive programming (feat. functional programming)&lt;br&gt;
를 이해하는데 많은 도움이 될 것이다.&lt;/p&gt;
&lt;p&gt;사실 더욱 많은 응용 예제를 올리고 싶지만&lt;br&gt;
글이 너무 길어지기 때문에 시간이 된다면 나중에 더 올리겠다.&lt;br&gt;
새로운 응용과 패턴의 사용은 이 글을 보는 사람들이 충분히 재밌고 쉽게&lt;br&gt;
사용할 수 있으리라 믿는다.&lt;/p&gt;
&lt;p&gt;—&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SPA 는 죽어가는가]]></title><description><![CDATA[최근? 이라고 하기도 그렇고, 1~2년 전 부터 SinglePageApp (SPA) 에 대한 비난이 커지고 있다. C# 을 이용한 웹개발에서 angular.js 를 시작으로 fe 프레임워크를 접한 나에게 좋은 얘기는 아닌 것 같다. 도데체 SPA…]]></description><link>https://willowryu.github.io/2022-05-24/</link><guid isPermaLink="false">https://willowryu.github.io/2022-05-24/</guid><pubDate>Tue, 24 May 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;최근? 이라고 하기도 그렇고, 1~2년 전 부터 SinglePageApp (SPA) 에&lt;br&gt;
대한 비난이 커지고 있다.&lt;/p&gt;
&lt;p&gt;C# 을 이용한 웹개발에서 angular.js 를 시작으로 fe 프레임워크를 접한 나에게&lt;br&gt;
좋은 얘기는 아닌 것 같다.&lt;/p&gt;
&lt;p&gt;도데체 SPA가 뭘 잘못했길래 이렇게 비난을 받고 있는가?&lt;br&gt;
과연 SPA는 잘못된 방향으로 가고 있고, MPA가 웹 서비스와 관련된 올바른 방향일까?&lt;/p&gt;
&lt;h2&gt;MPA의 장점은 뭘까&lt;/h2&gt;
&lt;h3&gt;전통적인 방식&lt;/h3&gt;
&lt;p&gt;브라우저와 웹의 역사를 되돌아보면 전통적으로&lt;br&gt;
MPA 방식이 웹페이지의 시초 이며&lt;br&gt;
데이터가 이미 입력된, 미리 만들어진 html 파일을&lt;br&gt;
서버에서 받아 브라우저는 단순히 html 을 파싱하여 보여주는 방식이었다.&lt;/p&gt;
&lt;p&gt;지금처럼 사용자와의 상호작용을 위한 거대한 js 파일을 다운로드 할 필요가 없었다.&lt;br&gt;
ajax 가 나오기 전에는 새로운 데이터를 받거나, 보낼때도 모든 부분을 서버에서&lt;br&gt;
처리하기 때문에 브라우저는 그냥 단순히 폼데이터를 보내거나, 새로운 페이지를 요청하는 등의 단순한 행동만이 필요했다.&lt;/p&gt;
&lt;p&gt;단순한 행동만을 한다, 그리고 추가 리소스가 매우 적다는 건 일단 속도가&lt;br&gt;
당연히 빠를 것이다.&lt;/p&gt;
&lt;h3&gt;빠른속도, SEO&lt;/h3&gt;
&lt;p&gt;MPA 의 가장 큰 장점인 초기 페이지 로딩 속도와 SEO.&lt;br&gt;
지금도 SSR 방식의 장점 중 하나가 초기 페이지 로딩이 빠르다는 점은 빠지지 않고&lt;br&gt;
나오고 있다.&lt;/p&gt;
&lt;p&gt;그래, SPA 보다 속도가 빠르다는 건 알았다.(과연?)&lt;br&gt;
추가로 나오는 장점 중 SEO 에 좋다는 부분?&lt;/p&gt;
&lt;p&gt;알다싶이 SPA는 모든 것을 Javascript 로 처리하기 때문에&lt;br&gt;
html 파일에는 대부분 해당 웹을 작동시키기 위한 js 파일만 포함되고&lt;br&gt;
나머지 컨텐츠는 텅 비어 있다.&lt;/p&gt;
&lt;p&gt;반대로 MPA 방식은 모든 컨텐츠가 꽉꽉 채워져 있기 때문에&lt;br&gt;
당연히 SPA 보다 검색엔진에 더 노출되기 쉽다.&lt;/p&gt;
&lt;p&gt;내가 사용자에게 많은 서비스를 제공하는 쇼핑몰, SNS 서비스는&lt;br&gt;
이런 장점이 크게 다가온다.&lt;br&gt;
쇼핑몰의 특정 상품링크를 받아 페이지를 오픈할때&lt;br&gt;
텅빈 화면과 함께 오랜 로딩 시간이 지속되면 사용자가 떠날 확률이 높다.&lt;/p&gt;
&lt;p&gt;이제 장점보다는 SPA 가 비난 받는 이유를 보자.&lt;/p&gt;
&lt;h2&gt;SPA는 왜 그래?&lt;/h2&gt;
&lt;p&gt;윗 글에 적은대로 초기페이지 속도가 느리다는 점.&lt;br&gt;
SEO 에 최적화 되지 않았다는 점.&lt;br&gt;
라우팅을 처리 할때 너무 많은 wrapper 가 있다는 점.&lt;/p&gt;
&lt;h3&gt;Route 에선?&lt;/h3&gt;
&lt;p&gt;SPA 는 브라우저의 라우팅 방식을 해킹?하여 사용한다.&lt;br&gt;
뒤로가기, 또는 앞으로 가기, 특정 주소에 다이렉트로 접근 등&lt;br&gt;
기본적으로 브라우저는 해당 URL 이 들어왔을때 해당 URL의 서버에 접근해서&lt;br&gt;
내가 파싱할 document 를 달라고 요청한다.&lt;br&gt;
전통적으로 그렇다.&lt;/p&gt;
&lt;p&gt;하지만 SPA 는 이 모든 걸 wrapping 하여 javascript 로 처리하게 된다.&lt;br&gt;
SPA 의 시작점은 index.html 이고, 빌드한 파일을 서버에 올렸을때,&lt;br&gt;
해당 도메인의 뒷 부분이 어떻게 되든 모든 시작점은 index.html 로 들어가게 된다.&lt;br&gt;
아니, 정확히는 그렇게 하도록 설정을 해둔다.&lt;/p&gt;
&lt;p&gt;특정 URL 의 document 가 아닌, index.html 과 index.html 에 포함된&lt;br&gt;
거대한 js 파일을 다운로드 하면, 이제부터 라우팅 해킹이 시작된다.&lt;/p&gt;
&lt;p&gt;모든건 js 에서 처리한다.&lt;br&gt;
browser histroy 를 가져와서 입맛대로 변경시키고, url 이 변경될때&lt;br&gt;
단순히 history 에 push 만 하고, url이 변경만 될뿐, 서버에 요청하지 않는다.&lt;br&gt;
그리고 변경된 url 을 감지하여 우리가 원하는 컨텐츠를 렌더링 하도록 만들게 된다.&lt;br&gt;
vanila js 가 아니라면&lt;br&gt;
대부분 router 와 관련된 라이브러리에서 이를 처리하게 될 것이다.&lt;/p&gt;
&lt;p&gt;말그대로 single page app 이다.&lt;br&gt;
이러한 방식의 문제점은 seo 가 힘들다는 점으로 이어진다.&lt;br&gt;
어떤 url 을 가도 무조건 시작점인 index.html 로 이어지기 때문.&lt;/p&gt;
&lt;h3&gt;할게 많다, 지친다.&lt;/h3&gt;
&lt;p&gt;또 다른 단점으로는 클라이언트에서 처리해야 할 문제가 굉장히 많아진다.&lt;br&gt;
점점 많아지고 있다.&lt;br&gt;
웹이 점점 발전함에 따라 브라우저에서 할 수 있는 일들이 너무 많이 생겼다.&lt;br&gt;
수많은 style 작성과 ui 를 위한 state 관리, 사용자와 상호작용을 위한&lt;br&gt;
코드, 추가로 서버와 통신하여 데이터를 요청하고,&lt;br&gt;
그 데이터를 또 관리하고..&lt;/p&gt;
&lt;p&gt;MPA 는 그런 측면에서 클라이언트의 부담을 많이 줄여준다.&lt;br&gt;
&lt;strong&gt;클라이언트의 고통을 나눠가진다는 것.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;그래서 이제 SPA 보다 MPA 를 선호해야 하나?&lt;/h2&gt;
&lt;p&gt;그전에 왜 SPA 가 나타나고, 더욱 발전하게 되었는지 생각해 보았다.&lt;br&gt;
아마도 모바일 사용자의 엄청난 증가가 시발점이 된게 아닐까?&lt;/p&gt;
&lt;p&gt;모든 웹 페이지는 이제 모바일 퍼스트로 제작되고, 모바일 용 레이아웃이 없는&lt;br&gt;
사이트는 사용자가 더 이상 찾지 않을 것이다.&lt;/p&gt;
&lt;p&gt;MPA가 모바일 사용자에게 적합할까?&lt;br&gt;
모바일은 데스크톱과 다르게 앱으로 서비스를 제공하는 것에 특화되어 있다.&lt;br&gt;
사용자는 앱사용에 익숙해져 있다.&lt;br&gt;
앱과 같은 사용성과 상호작용을 원한다.&lt;/p&gt;
&lt;p&gt;SPA 의 가장 큰 장점인 부드러운 상호작용과 끊김없는 컨텐츠 이동이&lt;br&gt;
아마도 모바일에서 사용하기에 어울리지 않을까?&lt;/p&gt;
&lt;p&gt;pwa 와 service worker 의 사용으로 웹을 앱처럼 설치하고&lt;br&gt;
오프라인에서도 이용하며, push 까지 받을 수 있게 되었다.&lt;/p&gt;
&lt;h3&gt;점진적으로 발전하는 웹&lt;/h3&gt;
&lt;p&gt;웹 api 는 모바일에서 할수 있는 native api 를 점점 따라가고 있다.&lt;br&gt;
결국 웹이 가고자 하는 방향은 웹이 아닌 응용프로그램이 되는 것이다.&lt;/p&gt;
&lt;p&gt;SPA 의 특징인 라우팅을 wrapping 하여 url 변경으로 인한 서버의 요청을&lt;br&gt;
막는다는 건 웹 페이지가 새로운 document 로 인해 refresh 되지 않는다는 점이고,&lt;br&gt;
이는 웹을 앱처럼 사용할 수 있도록 하는 가장 중요한 부분이다.&lt;/p&gt;
&lt;p&gt;SPA 는 웹에서 앱처럼 여러 작업을 끊김없이 할 수 있는 최상의 UX,UI 를 만들 수 있다.&lt;br&gt;
MPA 에서 비디오를 켜고, 음악을 들으며 다른 페이지로 이동할 수 있을까? 불가능하다.&lt;br&gt;
iframe 을 사용하면 가능하긴 하다. 그런데 쓰고 싶은가?&lt;br&gt;
수많은 MPA 에서 수많은 ui state 를 유지하며, 페이지를 이동 할 수 있을까?&lt;br&gt;
쉽지 않다.&lt;/p&gt;
&lt;p&gt;또 하나의 SPA를 위한 방어룰 해보자면 code spliting, lazy load, preload,&lt;br&gt;
tree shaking 등&lt;br&gt;
SPA 의 단점?인 속도를 커버 할 수 있는 기술이 상당히 많다.&lt;br&gt;
이들은 이미 우리가 익숙한 webpack, parcel 등의 번들러에 포함되어 있다.&lt;/p&gt;
&lt;p&gt;통신속도는 점점 빨라지고, pc 와 모바일의 성능도 점점 좋아지고 있다.&lt;br&gt;
지금은 90년대가 아니다.&lt;br&gt;
사용자들이 1mb, 2mb 의 컨텐츠를 다운로드 받기위해 수초가 걸리는 그런 시대는&lt;br&gt;
이미 지나갔다.&lt;/p&gt;
&lt;h2&gt;결론은&lt;/h2&gt;
&lt;p&gt;위에 적었듯이 MPA 는 클라이언트의 부담을 줄여준다.&lt;br&gt;
대신에 서버에 부담을 늘린다. 결국 그 부담의 양은 줄어들지 않는다.&lt;/p&gt;
&lt;p&gt;나는 점점 더 클라이언트와 서버의 역할이 확실하게 나뉘는 방향으로&lt;br&gt;
가는게 옳다고 생각한다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 해야할, 해줘야 할 일들이 너무 많이 늘어났다.&lt;br&gt;
웹은 예전의 신문처럼 보는 그런 웹이 더이상 아니다.&lt;br&gt;
이제는 빠르고 쉽게 접속이 가능한 instant app 수준까지 도달했다.&lt;br&gt;
특정 사이트는 그를 뛰어 넘었고.&lt;/p&gt;
&lt;p&gt;그렇다고 MPA 가 안좋다는 말은 또 아니다.&lt;br&gt;
SPA로 할수밖에 없는 사이트들, figma, google map 또는 채팅 앱 등,&lt;br&gt;
사용자들과 끊임없이 상호작용을 하는 사이트 들이 있다.&lt;/p&gt;
&lt;p&gt;readonly 사이트들, 뉴스, 블로그, 상호작용이 거의 없는 페이지,&lt;br&gt;
그리고 seo 에 민감한 서비스들은 여전히 MPA 로 가져가는 이득이&lt;br&gt;
SPA 보다 더 크다고 생각한다.&lt;/p&gt;
&lt;p&gt;무조건 이걸로 해야한다는 정답은 없다.&lt;br&gt;
결국 서비스와 엔지니어들의 역량에 따라 SPA를 선택할지, MPA를 선택할지&lt;br&gt;
갈리게 된다.&lt;/p&gt;
&lt;p&gt;SPA 는 죽어가는게 아니다. 오히려 웹이 더욱 응용프로그램에&lt;br&gt;
가깝도록 발전을 촉진시키는 역할을 하고 있다.  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Frame Timing]]></title><description><![CDATA[HTTP 203 시리즈에 관한 견해와 내용을 정리 하려 한다. Frame Timing API 모바일 과 다양한 장치에서 사용자 경험을 최적화 하기 위해 , ,  등 Browser 가 행하는 UI 의 변화에 대해 60fps…]]></description><link>https://willowryu.github.io/2022-01-09/</link><guid isPermaLink="false">https://willowryu.github.io/2022-01-09/</guid><pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;HTTP 203 시리즈에 관한 견해와 내용을 정리 하려 한다.&lt;/p&gt;
&lt;h3&gt;Frame Timing API&lt;/h3&gt;
&lt;p&gt;모바일 과 다양한 장치에서 사용자 경험을 최적화 하기 위해&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Transition&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Animation&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Scrolling&lt;/code&gt; 등 Browser 가 행하는&lt;br&gt;
UI 의 변화에 대해 60fps 를 유지 할 필요가 있다.&lt;/p&gt;
&lt;p&gt;2022 년 현재는 각종 디바이스의 전체적인 고급화로 대부분의 디바이스에서&lt;br&gt;
60fps 를 유지하는게 어렵지 않다.&lt;br&gt;
(물론 충분히 정석적으로 코드를 사용했을때 얘기이다.)&lt;/p&gt;
&lt;p&gt;Ep3 해당 시즌은 2014 년 기준.&lt;br&gt;
60fps 도달을 위해 사용자가 다양한 기기에서 테스트 하고 수정 할 수 있도록&lt;br&gt;
새로운 API 를 W3C 에 제안하기 시작했다.&lt;/p&gt;
&lt;p&gt;Frame Timeing API 로 얻을 수 있는 점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Javascript 및 CSS Animation 의 fps 를 정보를 추적한다.&lt;/li&gt;
&lt;li&gt;페이지 Scrolling 의 프레임을 추적한다.&lt;/li&gt;
&lt;li&gt;장치가 현재 가지고 있는 부하에 따라 자동으로 frame 을 조정한다.&lt;/li&gt;
&lt;li&gt;런타임 성능에 관한 테스팅&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;해당 API 의 사용법을 간단히 살펴보자. (renderer = main thread)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var rendererEvents = window.performance.getEntriesByType(&amp;quot;renderer&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결과는 다음과 같이 나온다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  sourceFrameNumber: 120,
  startTime: 1342.549374253
  cpuTime: 6.454313323
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;설명으론 각 &lt;code class=&quot;language-text&quot;&gt;sourceFrameNumber&lt;/code&gt; 는 해당 record 의 고유 넘버,&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;startTime&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;High Resolution Time&lt;/code&gt; (= performance.now()) 을 나타내고&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;cpuTime&lt;/code&gt; 은 말그대로 사용된 cpu 시간을 나타낸다.&lt;/p&gt;
&lt;p&gt;해당 배열을 사용하여 각 frame 에 관하여 60fps 로 진행되고 있는지 체크가 가능하다.&lt;br&gt;
추가로 &lt;code class=&quot;language-text&quot;&gt;cpuTime&lt;/code&gt; 을 보고, 현재 cpu 사용량이 16ms 안에서 잘 사용되고 있는지&lt;br&gt;
체크도 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;cpuTime&lt;/code&gt;이 프레임당 16ms 와 가까워지면 garbage collection 작업에&lt;br&gt;
영향을 주기 시작하며 배터리 소모가 크게 늘어날 수 있다.&lt;/p&gt;
&lt;p&gt;추가로 renderer 외, 브라우저에서 화면에 표시하는 단계인 &lt;code class=&quot;language-text&quot;&gt;composite&lt;/code&gt; 단계를&lt;br&gt;
체크하는 API 도 제안되었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var compositeThreadEvents = window.performance.getEntriesByTyp(&amp;quot;composite&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;sourceFrameNumber&amp;quot;: 120,
  &amp;quot;startTime&amp;quot;: 1352.343235321
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이들의 frameNumber 를 연결하여 각종 합성 단계와 프레임과 관련된&lt;br&gt;
문제를 신속히 테스트 할 수 있다는 점이 해당 API의 이점이다.&lt;/p&gt;
&lt;p&gt;결론적으로 해당 API는 위에서 말했듯이 결국 60fps 를 유지하는데 나타난 문제점들을&lt;br&gt;
신속하게 모니터링 하고 테스트 하기 위해 제안되었다.&lt;/p&gt;
&lt;p&gt;제안 될 당시 개발자들의 피드백을 받았고 (2014년…)&lt;br&gt;
현재 찾아보니 해당 제안은 아직 채택되지 않았다.(?)&lt;/p&gt;
&lt;p&gt;마지막으로 제안한 스펙에선&lt;br&gt;
설정이 본문과는 조금 다른버전이 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var observer = new PerformanceObserver(function (list) {
  var perfEntries = list.getEntries()
  for (var i = 0; i &amp;lt; perfEntries.length; i++) {
    console.log(&amp;quot;Uh oh, slow frame: &amp;quot;, perfEntries[i])
  }
})
observer.observe({ entryTypes: [&amp;quot;frame&amp;quot;] })&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 entryType 을 지정 할수 있고&lt;br&gt;
cpuTime 은 빠지고 대신 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;entryTime&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;startTime&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;duration&lt;/code&gt; 이 포함된&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;PerformanceFrameTiming&lt;/code&gt; 객체가 리턴되는 것으로 변경되었다.&lt;/p&gt;
&lt;p&gt;해당 제안이 더 진행되지 않는 이유를 보자면&lt;/p&gt;
&lt;h4&gt;Problem 1&lt;/h4&gt;
&lt;p&gt;HTML spec 에서 해당 Time 을 가져오기 위한 적절한 hook 이 없다.&lt;/p&gt;
&lt;p&gt;startTime 을 가져오기 위해서 &lt;code class=&quot;language-text&quot;&gt;performance.now()&lt;/code&gt; 메소드를 이용해서 가져와야 한다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;code class=&quot;language-text&quot;&gt;PerformanceFrameTiming&lt;/code&gt; 객체 값을 구하기 위해&lt;br&gt;
endTime 역시 &lt;code class=&quot;language-text&quot;&gt;perfoemance.now()&lt;/code&gt; 를 사용하게 되고, startTime - endTime 으로&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;duration&lt;/code&gt; 을 구하게 된다.&lt;/p&gt;
&lt;p&gt;해당 값 들을 구할때 사용자의 디바이스 성능, 전력 소비, 주사율 등&lt;br&gt;
프레임과 관련된 시간에 영향을 받는 정보들을 별도로 요구하고 있지 않다.&lt;br&gt;
테스트와 모니터링을 위한 정보라면, 개발자에게 잘못된 시간을 보고하지 않아야 하므로,&lt;br&gt;
프레임계산에 필요한 정보를 받아서 해당 사양에 맞는 임계값 또는 설정을 해야한다.&lt;/p&gt;
&lt;p&gt;그 많은 디바이스와 사용자의 런타임 사양에 대하여, 별도의 설정을 하려면..어휴..&lt;br&gt;
포기한 이유가 보이기 시작한다.&lt;/p&gt;
&lt;h4&gt;Problem 2&lt;/h4&gt;
&lt;p&gt;두번째로는 정보가 많이 부족하다는 것 이다.&lt;br&gt;
현재로선 프레임과 관련된 정보만 줄 뿐, 느려진 원인에 대한 이유를 판별하기 위한&lt;br&gt;
메커니즘이 없다.&lt;br&gt;
별도로 event, raf, paint 작업에 관한 캡쳐링이 필요하다고 판단된다.&lt;/p&gt;
&lt;p&gt;해당 2가지 문제가 나와있는데..&lt;br&gt;
문제 해결을 위한 작업이 만만치 않아 보인다.&lt;br&gt;
이로 인해 현재로선 아예 진행이 되지 않는다고 나와있는 걸로 보아 포기한 듯 싶다.&lt;/p&gt;
&lt;p&gt;조금 과한 API 라는 지적도 있고, raf 로 충분하다는 지적도 있다.&lt;br&gt;
그리고 생각보다 많은 개발자들이 피드백을 안준 것(?) 같기도 하다.&lt;/p&gt;
&lt;p&gt;어쨌든 첫번째는 이걸로 끝.&lt;br&gt;
사용 할 수 없는 API라..허무하기도 함.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[함수의 색상]]></title><description><![CDATA[algebraic effects 를 조사하다가 좋은 글을 찾게 되었다. 해당 주제를 보기 전 일단 What Color is Your Function: https://journal.stuffwithstuff.com/2015/02/01/what-color…]]></description><link>https://willowryu.github.io/2021-05-21/</link><guid isPermaLink="false">https://willowryu.github.io/2021-05-21/</guid><pubDate>Fri, 21 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;algebraic effects 를 조사하다가 좋은 글을 찾게 되었다.&lt;br&gt;
해당 주제를 보기 전 일단&lt;/p&gt;
&lt;p&gt;[What Color is Your Function]: &lt;a href=&quot;https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/&quot; target=&quot;_blank&quot;&gt;https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;이 글을 읽고 진행하길 바란다.&lt;/p&gt;
&lt;p&gt;.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;br&gt;
.&lt;/p&gt;
&lt;p&gt;해당 글은 비동기 함수의 전염성에 관한 불평 글이다.&lt;br&gt;
동기함수는 Blue, 비동기 함수는 Red 로 표현하였다.&lt;/p&gt;
&lt;p&gt;우리가 함수를 작성할때 동기함수 즉 Blue 색상의 함수에서는&lt;br&gt;
비동기함수 (=Red) 를 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;시용할 수 없다는 말은 비동기 함수의 결과를 가지고 어떠한 처리를 하거나 비동기함수를 실행할 수 없다는 뜻이다.&lt;/p&gt;
&lt;h2&gt;Promise&lt;/h2&gt;
&lt;p&gt;Promise 가 있지 않은가?&lt;br&gt;
오 Promise 는 비동기 함수를 await 하여 동기적으로 실행순서를 맞춰준다.&lt;/p&gt;
&lt;p&gt;하지만 event loop 설계방식의 js 에서는 await 된 함수는 microtask 로 들어가게 된다.
실행순서로 보면 이미 함수 내부 다른 프로세스가 끝난 뒤, 해당 함수들을 실행한다.&lt;/p&gt;
&lt;p&gt;만약 promise 의 결과값을 받아서 처리하고 싶다면?&lt;br&gt;
순간 async await 가 떠올랐을 것 이다.&lt;br&gt;
await 하여 비동기 함수의 결과 값을 받아 그 뒤를 진행 할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;async function logName() {
  const user = await fetchUser(&amp;quot;something api&amp;quot;)
  if (user.name) {
    console.log(user.name)
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;확실히 순서를 보면 동기적으로 작동하는 함수다.&lt;br&gt;
하지만 function 앞에 있는 async 지시문을 보자.&lt;/p&gt;
&lt;p&gt;해당 함수는 비동기함수 입니다. 라고 떡하니 적혀있다.&lt;br&gt;
결국 비동기함수는 동기함수 내부에서 사용할 수 없다!&lt;/p&gt;
&lt;p&gt;비동기 함수를 사용하기 위해서는 해당함수도 비동기 함수가 되어야 한다.&lt;br&gt;
이는 async 뿐만 아니라 generate 도 똑같다.&lt;/p&gt;
&lt;p&gt;이로 인해 비동기 함수가 중간에 들어오면 해당 함수를 사용하는 모든 함수는&lt;br&gt;
비동기가 되어야 한다. 이것이 비동기 함수의 전염성이다.&lt;/p&gt;
&lt;h2&gt;HighOrder Function&lt;/h2&gt;
&lt;p&gt;위 글에서는 이런 문제가 더욱 불거진 이유가 (=전염성이 문제가 되는 경우) 함수형 프로그래밍의 사용으로 보고 있다.&lt;/p&gt;
&lt;p&gt;단일값을 반환하는 함수만 존재한다면 전염성은 큰 문제가 되지 않는다.&lt;br&gt;
하지만 고차 함수는 함수를 반환한다.&lt;/p&gt;
&lt;p&gt;여기서 해당 함수에 비동기가 있다면?&lt;br&gt;
이제 모든 함수는 async 로 변해야 한다.&lt;br&gt;
전염성은 프로그램 모든곳으로 급격히 퍼져 나갈 것 이다.&lt;/p&gt;
&lt;h2&gt;색상이 없는 언어&lt;/h2&gt;
&lt;p&gt;결국 이 전염성을 해결하기 위해서는 Multi Thread 를 이용해야 한다.&lt;br&gt;
모든 함수의 실행이 병렬로 진행되고 결과값을 가지고 Thread 끼리 통신해야 한다.&lt;/p&gt;
&lt;p&gt;이런 부분을 가장 적절하게 사용하는 언어가 구글에서 만든 Go 언어다.&lt;br&gt;
(본인은 go 언어를 해본적은 없다…)&lt;br&gt;
Go 는 수많은 green thread 를 생성하여 모든 작업이 비동기로 흘러간다.&lt;/p&gt;
&lt;p&gt;그리고 GoRoutine 을 이용하여 모든 함수에서 이를 제어 할 수 있다.&lt;br&gt;
모든 함수에서 동기함수와 비동기 함수 실행이 가능하다.&lt;/p&gt;
&lt;p&gt;go 는 내부적으로 모든 i/o 관련 라이브러리들이 thread 에서 await 하고 있다.&lt;br&gt;
다른 thread (=작업) 에서 메시지를 보내면 해당 메시지를 받기위해 대기하게 된다.&lt;br&gt;
이는 go 가 실제로 모든 작업은 비동기 지만 동기처럼 보이는 방식이 된다.&lt;/p&gt;
&lt;h2&gt;또다른 색상&lt;/h2&gt;
&lt;p&gt;red, blue 와 같이 동기, 비동기를 나누는 것 외에&lt;br&gt;
해당 함수의 args, return type, 사용하는 프레임워크, 라이브러리의&lt;br&gt;
전용함수 등 2가지 색상이 아닌 수많은 색상이 나올 것이다.&lt;/p&gt;
&lt;p&gt;하지만 가장 실제 제품을 개발할때 가장 성가신 것은 동기와 비동기를 나누게 되는 red, blue 임은 확실하다.&lt;/p&gt;
&lt;h2&gt;그래서 지금은?&lt;/h2&gt;
&lt;p&gt;현재 개발되는 새로운 언어들은 이런 문제를 해결하기 위해&lt;br&gt;
내부적으로 async await 를 심어두고, 외부에서는 이를 노출하지 않는 방식으로 만들어&lt;br&gt;
실제로 multi thread 방식으로 작동하는 것 처럼 보이고 있지만..&lt;/p&gt;
&lt;p&gt;multi thread 가 아니라면 결국 우리는 해당 비동기함수의 작업을 다시 실행할때&lt;br&gt;
해당 함수의 call stack 전부를 가져와야 한다.&lt;/p&gt;
&lt;p&gt;최근에는 pc 나 모바일의 성능이 평균적으로 상향되었기 때문에 성능의 큰 문제는&lt;br&gt;
없으리라 보지만 그래도 여전히 엔진 내부에서는 call stack 을 찾기 위한 여정을&lt;br&gt;
하고 있다는 건 기억하길 바란다.&lt;/p&gt;
&lt;p&gt;그리고 여전히 색상을 구분지어 작성해야 하는 부분도 존재한다는 것도.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FLIP 방식의 Animation 처리]]></title><description><![CDATA[오늘은 google 2014 Google Chrome Dev Summit 에서 소개된 FLIP 방식으로 Animation 을 처리하는 기법을 살펴보자. FLIP 방식은 Animation…]]></description><link>https://willowryu.github.io/2021-04-22/</link><guid isPermaLink="false">https://willowryu.github.io/2021-04-22/</guid><pubDate>Thu, 22 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오늘은 google 2014 Google Chrome Dev Summit 에서 소개된 FLIP 방식으로&lt;br&gt;
Animation 을 처리하는 기법을 살펴보자.&lt;/p&gt;
&lt;p&gt;FLIP 방식은 Animation 처리 시 미리 최종값을 계산 하여
애니메이션 진행 중 무거운 계산을 하지 않도록 만들어, 빠르게 처리 하는 방식이며 element 의 크기, 위치, 불투명도 (즉 scale, transform, opacity) 를 이용한 애니메이션에서&lt;br&gt;
더욱 훌륭한 성능을 가져다준다.&lt;/p&gt;
&lt;p&gt;글로만 보면 이해가 되지 않을 수 있다.&lt;br&gt;
실제로 어떤식으로 처리하는지 보자.&lt;/p&gt;
&lt;h3&gt;FLIP 의 정의&lt;/h3&gt;
&lt;p&gt;FLIP 일련의 방식의 줄임말이다.&lt;/p&gt;
&lt;p&gt;F: first&lt;br&gt;
L: last&lt;br&gt;
I: Invert&lt;br&gt;
P: Play&lt;/p&gt;
&lt;p&gt;대상이 되는 element 의 초기 값을 계산하고,&lt;br&gt;
해당 element 의 최종 지점의 값을 계산한다.&lt;/p&gt;
&lt;p&gt;그리고 현재 invert 를 적용하여 현재 element 의 위치로
invert 값을 부여한 뒤,&lt;br&gt;
최종 지점의 값으로 되돌린다.&lt;/p&gt;
&lt;h3&gt;Code&lt;/h3&gt;
&lt;p&gt;간단하게 코드로 살펴보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;div class=&amp;quot;content-wrap&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;example-card&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 구조의 html 이 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 179.05405405405406%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAkCAIAAAAGkY33AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbklEQVRIx+3SwQqAIAyA4d7/UYr0hWLlvQg6VMxtZZcgMS8hdNj43ckPPFgdH6ZSrFhxYSyEvM/JRCiDJRxaHELje/vMhM3bdF97wwN2tQfjoY3ibSyLHXYNgkUwUflnX8OEfp2TCZP+MMWK/4xPy/9WKkP9alcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;sc1&quot;
        title=&quot;sc1&quot;
        src=&quot;/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png&quot;
        srcset=&quot;/static/d38bf457dea426e48130e57dc0e670e1/12f09/2021-04-22-1.png 148w,
/static/d38bf457dea426e48130e57dc0e670e1/e4a3f/2021-04-22-1.png 295w,
/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png 362w&quot;
        sizes=&quot;(max-width: 362px) 100vw, 362px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위 그림 같이 생긴 간단한 구조다.&lt;br&gt;
여기서 중앙에 있는 card 를 확장 시키는 애니메이션을 만들고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/e01024a57f49bc258b05d025642ce982/2021-04-22-2.gif&quot; alt=&quot;sc2&quot;&gt;&lt;/p&gt;
&lt;p&gt;요런식으로 말이다.&lt;/p&gt;
&lt;p&gt;그럼 FLIP 방식을 사용해서 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;.full-card {
  width: 100%;
  height: 100%;
  margin: 0;
  border-radius: 0;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const card = document.querySelector(&amp;quot;.example-card&amp;quot;)

// F: 초기 위치 값을 계산한다.
const first = card.getBoundingClientRect()

// 대상 element 의 최종 상태로 적용시킨다.
card.classList.add(&amp;quot;full-card&amp;quot;)

// L: 마지막 위치 값을 계산한다.
const last = card.getBoundingClientRect()

// I: Invert 즉 초기 값에서 마지막 값을 뺀다.
const invert = {
  scaleX: first.width / last.width,
  scaleY: first.height / last.height,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;코드를 간단히 정리하자면&lt;br&gt;
먼저 현재 card element 의 초기 위치 값을 가져온다.&lt;br&gt;
그리고 그 즉시 card element 를 우리가 원하는 최종 상태로 변환 시킨다.&lt;/p&gt;
&lt;p&gt;이제 element 는 현재 화면에 꽉 차있는 위치가 되었다.&lt;br&gt;
여기서 현재 element 의 값을 가져온다.&lt;/p&gt;
&lt;p&gt;이제 invert 값을 계산해보자.&lt;br&gt;
현재 애니메이션에서 우리가 원하는 건 크기의 변경이다.&lt;/p&gt;
&lt;p&gt;dom 트리의 리플로우가 발생하지 않도록&lt;br&gt;
컴포지터 스레드를 활용한 애니메이션을 사용한다면&lt;br&gt;
여기선 크기와 관련된 scale 이 될 것 이다.&lt;/p&gt;
&lt;p&gt;scale 값 계산을 위해서 초기 값에서 마지막 값을 나눠준다.&lt;br&gt;
이제 이 값을 가지고 animation 을 실행 해보자.&lt;/p&gt;
&lt;h3&gt;Animation Play&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const animation = card.animate(
  [
    {
      transform: `scale(${invert.scaleX}, ${invert.scaleY})`,
    },
    {
      transform: &amp;quot;scale(1, 1)&amp;quot;,
    },
  ],
  {
    duration: 300,
    easing: &amp;quot;ease-in-out&amp;quot;,
  }
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;animate 함수를 보면 초기값이 계산된 invert 값이고,&lt;br&gt;
최종값은 우리가 원하는 기본상태이다.&lt;/p&gt;
&lt;p&gt;이제 실행해보면 우리가 원하는 Animation 이 매끄럽게 작동한다.&lt;/p&gt;
&lt;h3&gt;Why FLIP&lt;/h3&gt;
&lt;p&gt;그럼 왜 FLIP 방식을 사용하는가?&lt;br&gt;
일반적으로 브라우저의 레이아웃을 변경하는 트리거가 발생되었을때 (크기, 위치)등&lt;br&gt;
브라우저는 주위 다른요소의 레이아웃이 변경되었는지 재귀적으로 계속 계산하게 된다.&lt;/p&gt;
&lt;p&gt;이때 그 계산 이 16.7ms 보다 오래 걸린다면 해당 프레임을 건너뛰기 때문에&lt;br&gt;
우리가 일반적으로 보는 끊김 현상이 나타난다.&lt;/p&gt;
&lt;p&gt;이런 현상을 없애기 위해 FLIP 에서는 애니메이션이 실행되기전 미리 최종 위치를 계산하고 애니메이션만 실행하게 된다.&lt;br&gt;
이는 애니메이션 실행 도중 진행되는 브라우저의 부담을 확실히 줄이는 일이 된다.&lt;/p&gt;
&lt;p&gt;F 단계에서 초기 값을 얻고, 즉시 최종위치로 전환할때 브라우저는 해당 element의 최종위치 와 전체 레이아웃 값을 다 계산이 완료 된 상태다.&lt;/p&gt;
&lt;p&gt;여기서 우리는 이제 composite 단계에서만 애니메이션을 실행시켜&lt;br&gt;
사용자에게 보여주면 된다.&lt;/p&gt;
&lt;h3&gt;주의점?&lt;/h3&gt;
&lt;p&gt;위에서 서술 했듯이 브라우저가 최종값을 계산하는 그 시간이 100ms 를 넘기면 안된다.&lt;/p&gt;
&lt;p&gt;RAIL 가이드에 따르면 사용자가 서비스와 상호작용 할때&lt;br&gt;
반응이 일어나기까지 100ms 의 시간이 주어진다.&lt;/p&gt;
&lt;p&gt;이 시간을 이용하여 FLIP 은 최종 계산을 마치고 애니메이션을 실행하게 되는데&lt;br&gt;
반대로 초기 계산이 100ms 를 넘어가면 이는 끔찍한 애니메이션 경험이&lt;br&gt;
될 것이다.&lt;/p&gt;
&lt;p&gt;상식적으로 아직 계산이 되지도 얺은 값을 가지고 애니메이션을 진행할 수는 없지 않은가?&lt;/p&gt;
&lt;p&gt;그리고 해당 FLIP 을 진행 할때 오로지 composite 레이어 에서 작동하는 속성으로 진행 해야 한다.&lt;br&gt;
translate, opacity, scale, rotate 등이 그 예가 될 것이다.&lt;/p&gt;
&lt;p&gt;composite 레이어에서 작동하는 다른 속성을 찾고 싶다면&lt;br&gt;
&lt;a href=&quot;https://csstriggers.com/&quot; target=&quot;_blank&quot;&gt;https://csstriggers.com/&lt;/a&gt; 여기서 검색해보면 된다.&lt;/p&gt;
&lt;p&gt;그외 주의점 과 자세한 설명은&lt;br&gt;
Dev summit: &lt;a href=&quot;https://youtu.be/RCFQu0hK6bU&quot; target=&quot;_blank&quot;&gt;Youtube&lt;/a&gt;&lt;br&gt;
해당 영상을 참고하자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react lazyload => preload]]></title><description><![CDATA[우리의 서비스가 커져갈때 마다 js 파일의 용량은 커져간다. 특히나 별도의 폰트, 이미지와 같은 리소스가 포함되어 있을 경우 사용자가 처음 접속 했을때 받아야 하는 데이터 양은 점점 부담스러워 질 것이다. 아무리 5g…]]></description><link>https://willowryu.github.io/2021-02-21/</link><guid isPermaLink="false">https://willowryu.github.io/2021-02-21/</guid><pubDate>Sun, 21 Feb 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;우리의 서비스가 커져갈때 마다 js 파일의 용량은 커져간다.&lt;br&gt;
특히나 별도의 폰트, 이미지와 같은 리소스가 포함되어 있을 경우 사용자가 처음 접속 했을때 받아야 하는 데이터 양은 점점 부담스러워 질 것이다.&lt;/p&gt;
&lt;p&gt;아무리 5g 시대(일단은 겉보기라도..) 가 오고 있다고 해도 모든 사용자가 초고속 인터넷을&lt;br&gt;
사용하진 않는다. 그리고 사용자의 주위환경에 의해 인터넷 속도는 매우 변동적이다.&lt;/p&gt;
&lt;p&gt;이런 다양한 인터넷 환경에 대처하여 사용자에게 최대한 빠른 응답을 줄수 있는 최적화 방법이 무엇이 있을까?&lt;/p&gt;
&lt;p&gt;여러가지 최적화 전략이 있겠지만 그중 가장 오늘은 lazyload 와 preload 를 이용한&lt;br&gt;
사이트 최적화 방법을 다뤄보자,&lt;/p&gt;
&lt;h3&gt;Lazyload&lt;/h3&gt;
&lt;p&gt;Lazyload 는 말그대로 불러오는 행동을 지연시키는 것이다.&lt;br&gt;
왜 지연시켜야 할까?&lt;/p&gt;
&lt;p&gt;우리가 사용하는 서비스, 예를 들어 요새 핫한 쿠팡에 접속했다고 생각해보자.&lt;br&gt;
쿠팡의 메인화면이 당신을 반겨 줄 것이다. 메인화면에는 수많은 카테고리와 이벤트,&lt;br&gt;
광고 페이지로 가득 차있다.&lt;/p&gt;
&lt;p&gt;하지만 사용자가 보는 메인 화면에서 해당 이벤트의 자세한 내용을 볼 수 있을가?&lt;br&gt;
배너에 떠 있는 상품의 자세한 내용을 볼 수 있을까?&lt;br&gt;
광고를 클릭하기 전 해당 광고의 내용을 볼 수 있을까?&lt;/p&gt;
&lt;p&gt;우리는 해당 내용을 클릭하기 전까지는 그 자세한 내용을 볼 수 없다.&lt;br&gt;
여기서 굳이 사용자가 해당 이벤트 또는 상품, 광고를 클릭하기 전 해당 내용들을 전부&lt;br&gt;
다운로드 받아야 할 이유가 있을까?&lt;/p&gt;
&lt;p&gt;만약 그렇게 된다면 글쎄 쿠팡의 배송만 로켓이 되어버리는 사태가 일어날 수 있다.&lt;br&gt;
사용자는 내부적으로, 또는 통신적으로 해당 사이트가 어떻게 돌아가는지 반드시 알아야 할&lt;br&gt;
이유도 없고 알고 싶지도 않을 것이다.&lt;br&gt;
그냥 화면이 빠르게 나오고 빠르게 반응하면 그걸로 된 거다.&lt;/p&gt;
&lt;p&gt;결론적으로 우리는 접속 했을때 메인화면에서 필요한 기능을 포함한 데이터 외에는 굳이&lt;br&gt;
다른 모든 데이터를 다운로드하며 사이트의 속도를 느리게 만들 필요가 없는 것 이다.&lt;/p&gt;
&lt;p&gt;이때 등장하는 개념이 lazyload 이다.&lt;br&gt;
사용자가 필요로 할때까지 해당 데이터의 다운로드를 보류하여 반응속도를 높이는 것이다.&lt;/p&gt;
&lt;p&gt;lazyload 를 적용하기 전 먼저 선행되어야 할 것이 있다.&lt;br&gt;
최신 모던 웹 서비스는 webpack, parcel 등의 bundler 를 사용하여 실제 제품버전으로&lt;br&gt;
배포하기 전 작성한 js 코드를 하나로 묶는 번들링을 실행하게 된다.&lt;/p&gt;
&lt;p&gt;lazyload 는 사용자가 필요할때 데이터를 다운로드 받는다고 했다.&lt;br&gt;
그렇다면 그전에 특정 기준으로 코드를 잘라 번들링이 실행 될때 여러개의 번들링된 js 파일로 만들어 둬야 하지 않을까?&lt;/p&gt;
&lt;p&gt;그러기 위해 code splitting (코드분할) 을 먼저 적용한다.&lt;/p&gt;
&lt;h3&gt;Code Splitting&lt;/h3&gt;
&lt;p&gt;위에서 말한대로 Code Splitting 을 실행하기 위해 현재 가장 많이 쓰이는&lt;br&gt;
webpack 기준으로 설명을 할텐데, 아마 다른 bundler 들도 동일하게 작동 할 거라&lt;br&gt;
예상된다.&lt;/p&gt;
&lt;p&gt;splitting 의 기준이 되는 부분을 정할 때 별도의 모듈이나 계산적으로 큰 함수 등&lt;br&gt;
개발자가 적절히 기준을 정할 수 있지만, 사실 기능별로 lazy 하기엔 기준이 굉장히&lt;br&gt;
애매할 수 있다.&lt;/p&gt;
&lt;p&gt;가장 좋은 방법은 Route Page 별로 분할 하는 것이다. 아마 대부분 특수한 경우가 아니고는 page 별 분할을 사용하는 중일 것이다.&lt;/p&gt;
&lt;h3&gt;Dynamic Import&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import SomeModule from &amp;quot;./someModule&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;우리는 기본적으로 위와 같이 대부분 정적으로 module 을 가져 왔을 것 이다.
lazy 하다는 건 내가 필요할 때 해당 데이터를 가져와야 하기 때문에 우리는 import 를 동적으로 가져 올 것 이다.&lt;/p&gt;
&lt;p&gt;dynamic import 는&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import(&amp;quot;./somePage&amp;quot;).then(page =&amp;gt; {
  page.default()
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와같이 import 사용 시 promise 를 반환한다. 고로&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const somePage = await import(&amp;quot;./somePage&amp;quot;)

somePage.default()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위처럼 async/await 를 사용하여 사용이 가능하다.
dynamic import 를 이용하면 자동적으로 bundler 에서 해당 항목을 분할하게 된다.&lt;br&gt;
여기서 react 에서는 import 된 컴포넌트를 동적으로 렌더링 가능케 해주는&lt;br&gt;
Lazy 와 Suspense 가 존재한다.&lt;br&gt;
이를 이용하여 실제 React 에서 page 별 코드 분할을 해보자.&lt;/p&gt;
&lt;h3&gt;Lazy, Suspense&lt;/h3&gt;
&lt;p&gt;Lazy 를 이용하여 import 된 컴포넌트를 동적으로 렌더링 하게 되는데,&lt;br&gt;
여기서 lazy 로 가져오는 모듈은 반드시 suspense 아래에 위치해야 한다.&lt;br&gt;
suspense 는 lazy 된 모듈들이 전부 불러오기까지 필요한 loading 화면등을 제공하는 것도 가능하다.&lt;/p&gt;
&lt;p&gt;실제로 기본적인 page를 가진 정말 정말 간단한 앱을 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;quot;./App.css&amp;quot;
import { 
  BrowserRouter as Router,
  Switch,
  Route,
  Link 
} from &amp;quot;react-router-dom&amp;quot;
import { MainPage, Menu1Page, Menu2Page } from &amp;quot;./pages&amp;quot;
import React from &amp;quot;react&amp;quot;

function App() {
  return (
    &amp;lt;Router&amp;gt;
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu1&amp;quot;&amp;gt;Menu1&amp;lt;/Link&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu2&amp;quot;&amp;gt;Menu2&amp;lt;/Link&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;Switch&amp;gt;
          &amp;lt;Route path=&amp;quot;/menu1&amp;quot; component={Menu1Page} /&amp;gt;
          &amp;lt;Route path=&amp;quot;/menu2&amp;quot; component={Menu2Page} /&amp;gt;
          &amp;lt;Route path=&amp;quot;/&amp;quot;&amp;gt;
            &amp;lt;MainPage /&amp;gt;
          &amp;lt;/Route&amp;gt;
        &amp;lt;/Switch&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Router&amp;gt;
  )
}

export default App&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;참고로 react 에서 lazy 를 사용할때는 default 만 지원한다.&lt;br&gt;
이를 named export 시키고 싶다면 별도 파일을 만들어서 로드해야 한다.&lt;br&gt;
자세한건&lt;br&gt;
&lt;a href=&quot;https://ko.reactjs.org/docs/code-splitting.html  &quot; target=&quot;_blank&quot;&gt;https://ko.reactjs.org/docs/code-splitting.html&lt;/a&gt;&lt;br&gt;
위를 참고하자.  &lt;/p&gt;
&lt;p&gt;code splitting 이 되지 않은 순수한 페이지 이다.&lt;br&gt;
해당 코드의 제품을 빌드 해보자. bundle 파일은 어떻게 될까?&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 504px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/04e2525f2ae6ee1a457560632bbc7944/08115/2021-02-21-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 79.72972972972973%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLUlEQVQoz11S24rUQBDNg1/gZddlEWY2yUzSl/S9c5vc0CfBCyjIKuy+iC+KKOyLi/+w4Bd7ksbZcTpFUXS66pw6VZEx2Z/bx8YpW/e76UXTT77t625SrnZ1Z6vWli1X7mJD4i29t2z2UcE3l2/XnG6FUNZarZQQwmjDGZdCwpRSjLEkTlJ8yeLjZA7SNFpR/+D9HeGyqqphmHa7rqpqeGMsgqqsyrIM8ThOsGEcm6a11sVxEnG+ffmuyikDAh7BlNIayLzAWbzgnFMaLByW5yRNN5Eu4u8fHlpFnK/HYWzbnfflgmyapqnrBpjee9x0XY+EOF64z6w3UcHSH9dnRlEhtJQSyKAEZOAL9CwhgQQWnmZZDn9okVXJ7y9PpCDeV845wMKQH6rMF74khK5Wa2AeJxuZfL18KgtqrT9ItgCHBRYw8IcPbO+TKUk/vTo3MgdlaBbQ0DCe/hNPQzPcIz5Odjq+u3lkNGsaSOWB0PcD5AkioQQEK0vMsQb5I+aR5MnVm3NGCQoDAQaRkBMCjAoeMf4iGZptt9lBzyK5uT5xhrZtj26xAOM49v0cwy/rMU8LjBAHUnvy86i+fTwTPGMM5efBMIbNwI5K+GVmKswM90j4H1kmvz6fKEGN9eVy8A5NAtkYB0BwQQwVUWi9voAdzFnGP69OC07QKSYEbgAMewq5UWUR34a1gcfNHjwiefr6+TOjiNZYDINBgSQGg0Jh4fA6jH0podH/PvkvkE24b1vPLxUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/04e2525f2ae6ee1a457560632bbc7944/08115/2021-02-21-1.png&quot;
        srcset=&quot;/static/04e2525f2ae6ee1a457560632bbc7944/12f09/2021-02-21-1.png 148w,
/static/04e2525f2ae6ee1a457560632bbc7944/e4a3f/2021-02-21-1.png 295w,
/static/04e2525f2ae6ee1a457560632bbc7944/08115/2021-02-21-1.png 504w&quot;
        sizes=&quot;(max-width: 504px) 100vw, 504px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;몇개의 파일로 번들링이 되어있는지 확인 할 수 있다.&lt;br&gt;
여기서 메뉴1이나 메뉴2로 라우팅을 변경해도 추가로 다운로드 되는 건 없다.&lt;br&gt;
이미 해당 메뉴 페이지에 관한 정보는 모두 다운로드 받았기 때문이다.&lt;/p&gt;
&lt;p&gt;지금은 서비스의 크기가 작으니 문제가 전혀 없지만 서비스가 커지고 외부 라이브러리들이&lt;br&gt;
점점 포함되기 시작하면 bundle 의 크기가 커질 것이고&lt;br&gt;
이는 추후 초기 페이지로드가 점점 느려지게 될 것이다.&lt;br&gt;
그리고 거기에 포함되는 리소스들까지 더한다면..&lt;/p&gt;
&lt;p&gt;자 그럼 이제 lazyload 를 한번 적용 해보자.&lt;/p&gt;
&lt;h3&gt;Lazyload 적용&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;quot;./App.css&amp;quot;
import { 
  BrowserRouter as Router,
  Switch,
  Route,
  Link 
} from &amp;quot;react-router-dom&amp;quot;
import { MainPage } from &amp;quot;./pages&amp;quot;
import React from &amp;quot;react&amp;quot;

const menu1 = React.lazy(() =&amp;gt; import(&amp;quot;./pages/lazy/menu1&amp;quot;))
const menu2 = React.lazy(() =&amp;gt; import(&amp;quot;./pages/lazy/menu2&amp;quot;))

function App() {
  return (
    &amp;lt;Router&amp;gt;
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu1&amp;quot;&amp;gt;Menu1&amp;lt;/Link&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu2&amp;quot;&amp;gt;Menu2&amp;lt;/Link&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;React.Suspense fallback={&amp;quot;loading&amp;quot;}&amp;gt;
          &amp;lt;Switch&amp;gt;
            &amp;lt;Route path=&amp;quot;/menu1&amp;quot; component={menu1} /&amp;gt;
            &amp;lt;Route path=&amp;quot;/menu2&amp;quot; component={menu2} /&amp;gt;
            &amp;lt;Route path=&amp;quot;/&amp;quot;&amp;gt;
              &amp;lt;MainPage /&amp;gt;
            &amp;lt;/Route&amp;gt;
          &amp;lt;/Switch&amp;gt;
        &amp;lt;/React.Suspense&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Router&amp;gt;
  )
}

export default App&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;React 의 Lazy 와 suspense 를 적용하면 이제 menu1 과 menu2 의 번들은&lt;br&gt;
별도로 분리된다. 이 상태에서 한번 빌드를 해보자.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 498px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/482d1307f86a78b2194f82ca520dc58d/79e1b/2021-02-21-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 86.48648648648648%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAACNElEQVQ4y22TW2/TQBCF8wvggSI1QEhsJ/HdTtb3W+y0RCgVgYcCqYDHIrUIeEC8IyTe+NN89oJFo4xG67PrnT1nZ2YHu/Xo5/U90w6KokjTLE3TsqzKsgzDKEnSzjLP81VVm05nmjbVtL/jbDYfPA3OTjbXrjEXQShEgAdBGEWx63qLxXK5FIxgQBwnOL98f8EKZw3UYPVod+vZlvwRRRFUYM6QUyRwIsEA+QvAtA2+3Dz+/u4+sssizzJkZ0VRVtUqDEP2oZytaAHEcawoaqe59VZ2LLTL7VjXbSSih+vBKaUyBeCe57UXEAEB87mOA9rgV5vx728PTEusqirP25zVdZMkWZ8tgGXZk4lCzmRM74PzUnmzHc3mjhAw+xAiEn7HccEARsuyDMPUdeMweFMpH18PTXtRdLTwcGGZWKYYaWOxadaskKQ7wU2ufv1walp+nyGYyY0sUmcC2Ww9wvy8Vr68HxqmT1V6QjDpIc9dtWLbdrizzPCd4Bdn409Xp7rhw5ZlVCuHHAFChEiQRcY5EXwoOwu1/cUTy/ZF21wtF1R8qJPUzDKYVUp4GLw7H//6fGLaIvnHXBT0dkVQJ4HeSLj88VI1ufL2YqSbnkwO5GxlhE32jGyY46XaNpOb/anjhXmede+pwuq6Jh4VWNfPMe+sbhqO+F/5oErUm/1QNxx4aIz+JUlm2SeYbbtEHjK/fDb5cfvQdsP1ek2VqtUKBjoUVh5ImuV4i4uSg7pi6b3/Acmmw3yfkVvzAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/482d1307f86a78b2194f82ca520dc58d/79e1b/2021-02-21-2.png&quot;
        srcset=&quot;/static/482d1307f86a78b2194f82ca520dc58d/12f09/2021-02-21-2.png 148w,
/static/482d1307f86a78b2194f82ca520dc58d/e4a3f/2021-02-21-2.png 295w,
/static/482d1307f86a78b2194f82ca520dc58d/79e1b/2021-02-21-2.png 498w&quot;
        sizes=&quot;(max-width: 498px) 100vw, 498px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여러개의 chunk 로 나뉘어진 것을 볼 수가 있다.&lt;br&gt;
이제 실제로 mainPage 에서 menu1 과 menu2 를 들어가 보면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/149d0a33acc7b6de62b07625e0433305/1e093/2021-02-21-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 8.108108108108107%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbUlEQVQI1x3LUQ6DIBAEUC/DLqyuhWpaYYEa0xKjifc/TjfOx3xM5nUDsyOyFkN4TtNsAKTUJDkmYeZa1+O8tm9DtBrnyBij/4cPr3fsqO8RUCfvg2JETLlEyUtMzKPk8mv7Z91uqYoAQNvf+A+F0hcm50DRTAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/149d0a33acc7b6de62b07625e0433305/fcda8/2021-02-21-3.png&quot;
        srcset=&quot;/static/149d0a33acc7b6de62b07625e0433305/12f09/2021-02-21-3.png 148w,
/static/149d0a33acc7b6de62b07625e0433305/e4a3f/2021-02-21-3.png 295w,
/static/149d0a33acc7b6de62b07625e0433305/fcda8/2021-02-21-3.png 590w,
/static/149d0a33acc7b6de62b07625e0433305/efc66/2021-02-21-3.png 885w,
/static/149d0a33acc7b6de62b07625e0433305/c83ae/2021-02-21-3.png 1180w,
/static/149d0a33acc7b6de62b07625e0433305/1e093/2021-02-21-3.png 1376w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;해당 메뉴에 들어갈때 데이터를 받는 것을 확인 할 수 있다.&lt;br&gt;
이제 Route 기준으로 Lazyload 를 구현 했으니 초기 페이지에서는 필요한 부분만&lt;br&gt;
다운로드 받고 사용자가 다른 페이지로 이동할때 필요한 데이터를 받을 것이다.  &lt;/p&gt;
&lt;p&gt;초기페이지의 최적화는 끝냈다. 하지만 여기서 또 중요한 문제가 있다.&lt;br&gt;
lazy load 로 진행했을때 페이지에 접속 할때마다 우리는 또 데이터의 다운로드를&lt;br&gt;
기다려야 한다.&lt;/p&gt;
&lt;p&gt;짧은 시간이지만 이 또한 서비스의 사용성을 해칠 수 있다.&lt;br&gt;
만약 초기데이터를 다운로드 받고, 초기 페이지를 나타낸 뒤&lt;br&gt;
사용자가 다른 페이지로 접근 전에 백그라운드에서 미리 페이지 데이터를 받을 수 있다면&lt;br&gt;
서비스 사용에 더욱 좋지 않을까?&lt;/p&gt;
&lt;p&gt;여기서 preload 가 적용된다.&lt;/p&gt;
&lt;h3&gt;Preload&lt;/h3&gt;
&lt;p&gt;lazyload 가 적용된 뒤, 사용자가 해당 페이지에 접근 하기 전&lt;br&gt;
미리 데이터를 받아서 TTI (Time to Interactive) 까지의 시간을 줄여보자.&lt;/p&gt;
&lt;p&gt;Route 가 변경되기 전 미리 데이터를 받아오려면 (뷰를 보여주려면) 해당 페이지 데이터의&lt;br&gt;
chunk 에서 메서드를 실행해야 한다.  &lt;/p&gt;
&lt;p&gt;react lazy 에서는 내부 메소드를 실행시킬 기능이 없다. 우리는 임의로 해당 기능을&lt;br&gt;
넣어줘야 할 것이다.&lt;/p&gt;
&lt;p&gt;react lazy 는&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  React.lazy(() =&amp;gt; Promise&amp;lt;{default: MyComponent}&amp;gt;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위처럼 Promise 를 반환합니다.&lt;br&gt;
suspense 는 위에서 말했듯이 lazy 된 컴포넌트를 불러오며 해당 promise 가&lt;br&gt;
실행될때까지 유지 시키고 응답에 따라 메서드를 실행시키는 역활을 한다.&lt;/p&gt;
&lt;p&gt;여기서 preload 를 적용하려면 단순히 해당 promise 를 먼저 실행시켜 버리면 된다.&lt;br&gt;
먼저 import 를 선언하고 해당 component 를 app 이 실행될때 실행해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;quot;./App.css&amp;quot;
import { 
  BrowserRouter as Router,
  Switch,
  Route,
  Link 
} from &amp;quot;react-router-dom&amp;quot;
import { MainPage } from &amp;quot;./pages&amp;quot;
import React, { useEffect } from &amp;quot;react&amp;quot;

const menu1 = import(&amp;quot;./pages/lazy/menu1&amp;quot;)
const menu2 = import(&amp;quot;./pages/lazy/menu2&amp;quot;)

function App() {
  const preloadMenu1 = React.lazy(() =&amp;gt; menu1)
  const preloadMenu2 = React.lazy(() =&amp;gt; menu2)

  return (
    &amp;lt;Router&amp;gt;
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu1&amp;quot;&amp;gt;Menu1&amp;lt;/Link&amp;gt;
          &amp;lt;Link to=&amp;quot;/menu2&amp;quot;&amp;gt;Menu2&amp;lt;/Link&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;React.Suspense fallback={&amp;quot;loading&amp;quot;}&amp;gt;
          &amp;lt;Switch&amp;gt;
            &amp;lt;Route path=&amp;quot;/menu1&amp;quot; component={preloadMenu1} /&amp;gt;
            &amp;lt;Route path=&amp;quot;/menu2&amp;quot; component={preloadMenu2} /&amp;gt;
            &amp;lt;Route path=&amp;quot;/&amp;quot;&amp;gt;
              &amp;lt;MainPage /&amp;gt;
            &amp;lt;/Route&amp;gt;
          &amp;lt;/Switch&amp;gt;
        &amp;lt;/React.Suspense&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Router&amp;gt;
  )
}

export default App&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 하면 처음 진입시 main page 를 로드하고, route 가 변경되지 않아도&lt;br&gt;
추가로 menu1, menu2 의 chunk 파일을 미리 가져온다.&lt;/p&gt;
&lt;p&gt;첫 페이지 진입 TTI 는 빨리지고, 추가로 다른 페이지를 들어갈 때 preload 한 데이터로&lt;br&gt;
인하여 접속이 더 빨라 질 것이다.&lt;/p&gt;
&lt;p&gt;여기까지만 하면 어느정도 최적화는 완료되었다.&lt;br&gt;
하지만 추가로 한가지 더 생각해보자.&lt;br&gt;
만약 사용자가 해당 서비스의 모든 페이지를 탐색 할 생각이 없다면?&lt;br&gt;
굳이 모든 페이지의 데이터를 미리 받을 이유는 없을 것 이다.&lt;br&gt;
이는 사용자의 데이터 소모량만 늘리는 일이 된다.&lt;/p&gt;
&lt;p&gt;그래서 우리는 Router 에 한가지 장치를 더할 것 이다. 해당 링크를 가려고 할때&lt;br&gt;
미리 preload 시키는 전략이다.&lt;/p&gt;
&lt;h3&gt;preload with router&lt;/h3&gt;
&lt;p&gt;React router 에는 match path 라는 유틸함수가 존재한다.&lt;br&gt;
이는 주어진 경로와 일치하는 route 가 존재한다면 해당 컴포넌트를 반환하게 된다.&lt;/p&gt;
&lt;p&gt;그럼 Link 에 사용자가 hover 했을때 해당 Link 의 route 와 현재 설정 되어있는&lt;br&gt;
Route 들을 비교하여 일치하는 Component 를 찾은 뒤&lt;br&gt;
아까 했던 것 처럼 promise 를 실행시켜 버리면&lt;br&gt;
사용자가 진입하고자 하는 페이지만 미리 로드 할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;그럼 일단 현재 Route 들의 정보를 모아두기 위해 코드를 조금 변경하자.&lt;br&gt;
각 route 에는 preload 를 위한 추가 import state 를 따로 저장해둔다.&lt;/p&gt;
&lt;p&gt;우리는 매칭되는 컴포넌트를 찾아지면 각 route 에 맞는 import 를 실행시킬 것이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type importStateType = {
  importState?: () =&amp;gt; any,
}

const menu1 = {
  importState: () =&amp;gt; import(&amp;quot;./pages/lazy/menu1&amp;quot;),
  lazy: lazy(() =&amp;gt; import(&amp;quot;./pages/lazy/menu1&amp;quot;)),
}

const menu2 = {
  importState: () =&amp;gt; import(&amp;quot;./pages/lazy/menu2&amp;quot;),
  lazy: lazy(() =&amp;gt; import(&amp;quot;./pages/lazy/menu2&amp;quot;)),
}

const routes: Array&amp;lt;RouteProps &amp;amp; importStateType&amp;gt; = [
  { path: &amp;quot;/&amp;quot;, exact: true, component: MainPage },
  {
    path: &amp;quot;/menu1&amp;quot;,
    exact: true,
    component: menu1.lazy,
    importState: menu1.importState,
  },
  {
    path: &amp;quot;/menu2&amp;quot;,
    exact: true,
    component: menu2.lazy,
    importState: menu2.importState,
  },
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;importState 는 preload 를 위해 추가된 항목이다.&lt;br&gt;
이제 추가로 matching 되는 컴포넌트를 찾는 함수를 정의하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const findRouteComponent = (
  routes: Array&amp;lt;RouteProps &amp;amp; importStateType&amp;gt;,
  path: string
) =&amp;gt; {
  const matchComponent = routes.find(route =&amp;gt;
    matchPath(path, {
      path: route.path,
      exact: route.exact,
    })
  )

  return matchComponent ? matchComponent : null
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;routes 배열과 link 의 path 를 받아서 일치하는 컴포넌트를 받아서 반환한다.&lt;br&gt;
이는 곧 우리가 지정한 lazy component 가 될것이다.&lt;br&gt;
이제 반환받은 lazy component 를 이전과 같이 실행시켜주면 된다.&lt;/p&gt;
&lt;p&gt;반환된 컴포넌트를 preload 시키는 함수를 만들어보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const preloadComponent = (path: string) =&amp;gt; {
  const cmp = findRouteComponent(routes, path)
  if (cmp &amp;amp;&amp;amp; cmp.importState) {
    cmp.importState()
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 함수는 우리가 설정해둔 import state 를 실행하여 해당 컴포넌트를 미리 import 하게 된다.&lt;/p&gt;
&lt;p&gt;자 이제 마지막으로 Link 컴포넌트에 mouse hover 시 위 함수를 실행하도록 만들자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const LinkWithPreload = ({
  to,
  ...props
}: {
  to: string,
  children?: ReactNode,
}) =&amp;gt; {
  return &amp;lt;Link to={to} onMouseEnter={() =&amp;gt; preloadComponent(to)} {...props} /&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;준비는 다 되었다.&lt;br&gt;
전체코드는 아래와 같다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;#39;./App.css&amp;#39;;
import { 
  BrowserRouter as Router,
  Switch,
  Route,
  Link 
} from &amp;quot;react-router-dom&amp;quot;
import { MainPage } from &amp;#39;./pages&amp;#39;;
import React, { lazy, ReactNode } from &amp;#39;react&amp;#39;;

type importStateType = {
  importState?: () =&amp;gt; any
}

const menu1 = {
  importState: () =&amp;gt; import(
    /* webpackChunkName: &amp;quot;menu1&amp;quot; */
  &amp;#39;./pages/lazy/menu1&amp;#39;
  ),
  lazy: lazy(() =&amp;gt; import(
    /* webpackChunkName: &amp;quot;menu1&amp;quot; */
    &amp;#39;./pages/lazy/menu1&amp;#39;)
  ),
};

const menu2 = {
  importState: () =&amp;gt; import(
    /* webpackChunkName: &amp;quot;menu2&amp;quot; */
    &amp;#39;./pages/lazy/menu2&amp;#39;
   ),
  lazy: lazy(() =&amp;gt; import(
    /* webpackChunkName: &amp;quot;menu2&amp;quot; */
    &amp;#39;./pages/lazy/menu2&amp;#39;
   ),
  ),
};

const routes: Array&amp;lt;RouteProps &amp;amp; importStateType&amp;gt;  = [
  { path: &amp;#39;/&amp;#39;, exact: true, component: MainPage },
  { path: &amp;#39;/menu1&amp;#39;,
    exact: true,
    component: menu1.lazy,
    importState: menu1.importState 
  },
  { path: &amp;#39;/menu2&amp;#39;,
    exact: true,
    component: menu2.lazy,
    importState: menu2.importState 
  },
]

const findRouteComponent = (
  routes: Array&amp;lt;RouteProps &amp;amp; importStateType&amp;gt;,
  path: string
) =&amp;gt; {
  const matchComponent = routes.find((route) =&amp;gt; matchPath(path, {
    path: route.path,
    exact: route.exact,
  }));

  return matchComponent ? matchComponent : null;
}

const preloadComponent = (path: string) =&amp;gt; {
  const cmp = findRouteComponent(routes, path);
  if (cmp &amp;amp;&amp;amp; cmp.importState) {
    cmp.importState();
  }
}

const LinkWithPreload = ({ to, ...props }: { to: string, children?: ReactNode }) =&amp;gt; {
  return (
    &amp;lt;Link
      to={to}
      onMouseEnter={() =&amp;gt; preloadComponent(to)}
      {...props}
    /&amp;gt;
  )
}

function App() {

  return (
    &amp;lt;Router&amp;gt;
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
          &amp;lt;LinkWithPreload to=&amp;quot;/menu1&amp;quot;&amp;gt;Menu1&amp;lt;/LinkWithPreload&amp;gt;
          &amp;lt;LinkWithPreload to=&amp;quot;/menu2&amp;quot;&amp;gt;Menu2&amp;lt;/LinkWithPreload&amp;gt;
        &amp;lt;/header&amp;gt;
        &amp;lt;React.Suspense fallback={&amp;#39;loading&amp;#39;}&amp;gt;
          &amp;lt;Switch&amp;gt;
            {routes.map((route) =&amp;gt;
              &amp;lt;Route
                key={route.path as string}
                component={route.component}
                path={route.path}
                exact={route.exact}
              /&amp;gt;
            )}
          &amp;lt;/Switch&amp;gt;
        &amp;lt;/React.Suspense&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/Router&amp;gt;
  );
}

export default App;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;초기 mainPage 진입시 network 를 보자.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 547px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9a833bb97c7f5f785cd425a91503b103/977f7/2021-02-21-4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 59.45945945945946%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQElEQVQoz2MIjYgrq6ybPnNuTV1LSVnNlGmzevomJ6flhEclRMYkIVB0YnRcSmBwhI2xmamphZmjmYGBMcP///9//Pjx9u3bz58/v3r16suXL0Du379//6MCiMjlS5dddfQtLGyMjcxNzSxBmu/duzd//vyVK1du3Lhx2bJlixcv/v79O1D8379/GJovGRkZ2to62tg4WFvbM8ClIUp/g8F/DADRfPXKJWtjbWNjM0srG6DjGZB1IluFVfOVK1c0NLU0dLS0dXU1NDQY/hMHIJovXbqkqqqioaWhoqKiqqpKsmZlZVV1dQ11NXUNDU3SNF+9es3JxcPc3FpPz1BbW480zTdv3gwOCXHz9DIzt1BWUiJZc1BwiJOLq7WNrbmFJcmaQ8PCXN08XdzcLa2sSdN8/fp1d3cPYCQDbdbW1gYAIP00j+L450kAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/9a833bb97c7f5f785cd425a91503b103/977f7/2021-02-21-4.png&quot;
        srcset=&quot;/static/9a833bb97c7f5f785cd425a91503b103/12f09/2021-02-21-4.png 148w,
/static/9a833bb97c7f5f785cd425a91503b103/e4a3f/2021-02-21-4.png 295w,
/static/9a833bb97c7f5f785cd425a91503b103/977f7/2021-02-21-4.png 547w&quot;
        sizes=&quot;(max-width: 547px) 100vw, 547px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;main.chunk.js 파일만 로드 된 걸 볼수 있다.&lt;br&gt;
여기서 마우스로 menu link 를 hover 하게 되면 해당 페이지의 chunk 파일을&lt;br&gt;
미리 가져오게 된다.&lt;br&gt;
(menu1.chunk.js)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 549px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6f79b6c229e6a76498446f79b1006a35/928ea/2021-02-21-5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 65.54054054054055%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfUlEQVQoz5WRzU7CQBSF+ygklhaKaUP/f6ClQKlETVAJG93SYIQYDQtfBhes4W3UNR1JiN1AkxbTQqkTqwRdwcnNzczNfHNOZpDzRuuh/9Tu9C6b1737/l3v8ap1o5XrevX0Txlnmn7CMQLLCpzGU3lGEguI67qLxWK1Wn04juf7cRx7nj+fw5m7LbhdLj9fX95aikrnWYbhaYYnSRoJgmA4HI7HozHUaDQYPM9mM3jFZrOJfxVFEey2DXRNF0RFUVRZLorQGR4Kw9D3/SAMPc9zHGe9XifwVsnEnkwahsJykFZ5Qcpmj5F4R7tuu4q+5+/TKcPyOI4LogQ7hmHI1iRZJAn/w0lsACRBTqVSKIpiWBp2JN5DCQxsUJCLKJrG8Uwmk4V9LzjJBQBoXDQ5XiIpOpcjYR3iDIBlWVpJFyUZRY8wHD8MbretcsVQtRIviKKsHAZ3OrdKoViuGhAmCOIwuNvtVoxazazD5D9ftSds27ZpmgR8KJIiKQrCX302RdSEYKsbAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/6f79b6c229e6a76498446f79b1006a35/928ea/2021-02-21-5.png&quot;
        srcset=&quot;/static/6f79b6c229e6a76498446f79b1006a35/12f09/2021-02-21-5.png 148w,
/static/6f79b6c229e6a76498446f79b1006a35/e4a3f/2021-02-21-5.png 295w,
/static/6f79b6c229e6a76498446f79b1006a35/928ea/2021-02-21-5.png 549w&quot;
        sizes=&quot;(max-width: 549px) 100vw, 549px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;방법이 생겼으니 위 코드 들을 더 편하고 재사용 가능하도록 만들어 보자.&lt;br&gt;
또 한가지 중요한건 해당 사항들은 SSR 에는 적용되지 않는다.&lt;br&gt;
정확히는 lazy 와 suspense 는 아직 SSR 을 지원하지 않는다.&lt;br&gt;
SSR 을 사용할때는 Loadable Component Package 를 사용하도록 권장하고 있다.&lt;/p&gt;
&lt;p&gt;그럼 끝&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react web 클린하게 시작하기]]></title><description><![CDATA[새해부터 이런 기초적인 내용을 왜 쓰기 사작하는가 작년 중순부터 연말까지 너무 바빴던 것도 있고 새로운 프로젝트를 시작하면서 정리했던 내용 중 필요한 부분을 콕 찝어서 정리해두기로 생각했다. 여기서 Backend 내용은 빠져있다. Backend…]]></description><link>https://willowryu.github.io/2021-01-03/</link><guid isPermaLink="false">https://willowryu.github.io/2021-01-03/</guid><pubDate>Sat, 02 Jan 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;새해부터 이런 기초적인 내용을 왜 쓰기 사작하는가&lt;br&gt;
작년 중순부터 연말까지 너무 바빴던 것도 있고&lt;br&gt;
새로운 프로젝트를 시작하면서 정리했던 내용 중 필요한 부분을 콕 찝어서&lt;br&gt;
정리해두기로 생각했다.&lt;br&gt;
여기서 Backend 내용은 빠져있다. Backend 는 별도로 다룰 예정.&lt;/p&gt;
&lt;h3&gt;Web Project 를 시작하기 위해&lt;/h3&gt;
&lt;p&gt;생각을 해보자.&lt;br&gt;
새로운 web project 를 만들려면 다들 가장 먼저 뭘 하는가?  &lt;/p&gt;
&lt;p&gt;일단 어떤 내용의 서비스를 만들지 생각하고, 어떤 도구들이 필요한지&lt;br&gt;
모바일도 지원하는지, Backend 는 어디를 쓸지, App 으로도 출시할지,&lt;br&gt;
응용프로그램 을 지원할지, 브라우저는 어디까지 지원할지 등둥&lt;br&gt;
고려해야 할 것이 아주 많고 그에 따라 수많은 도구들이 존재한다.  &lt;/p&gt;
&lt;p&gt;내가 이번에 새로운 프로젝트를 시작하며 가장 크게 고려한 것은 필요할 때까지&lt;br&gt;
사용하지 않는다 였다.  &lt;/p&gt;
&lt;p&gt;패키지의 최소 설치는 (= opensource 최소 이용) 번들 사이즈를 줄일 수 있고,&lt;br&gt;
보안적으로 많은 도움을 준다.  &lt;/p&gt;
&lt;p&gt;그리고 오픈소스의 버전관리에서 벗어날 수 있으며,&lt;br&gt;
필요한 기능은 직접 만들어 쓰기 때문에 개발하는데 조금더 깊이 파고들 수 있다.  &lt;/p&gt;
&lt;p&gt;실제 회사에서는 Electron 과 반응형 웹, 그리고 graphql 을 사용하는 프로젝트로 했고,&lt;br&gt;
이번 예제에서는 단순히 반응형 웹에 초첨을 맞춰본다. 여기서 만약&lt;br&gt;
더 필요한 지원이 있다면 차차 늘려가면 된다.&lt;br&gt;
(ex: React Native, Ionic, electron, apollo, relay 등등)&lt;/p&gt;
&lt;h3&gt;Init Project&lt;/h3&gt;
&lt;p&gt;현재 FE 에서 가장 많이 사용되는 툴은 아무래도 React 일 것 이다.&lt;br&gt;
난 Angular 를 좋아하지만 각각 장단점이 있으니, 그리고 React 를 사용하는 곳이&lt;br&gt;
훠얼씬 많으니 React 중심으로 얘기한다.  &lt;/p&gt;
&lt;p&gt;빈 폴더를 하나 만들고 React 를 설치 해보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;test-project&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;test-project 란 폴더를 만들고 먼저 중심이 되는 React 를 설치 해보자.  &lt;/p&gt;
&lt;p&gt;잠깐! 여기서 create-reacr-app 으로 땡치려는 사람은 이글을 보지말고&lt;br&gt;
그냥 하던대로 개발을 계속 하면 된다.&lt;br&gt;
cra 를 사용할거면 이런 글을 쓸 이유가 없다.  &lt;/p&gt;
&lt;p&gt;물론 cra 에는 react 중심기능을 포함하여 test 관련 라이브러리나 webpack 같은&lt;br&gt;
번들러가 포함되어 있기 때문에 사용하기 편할 수도 있다.&lt;br&gt;
문제는 강제로 해당 패키지들을 사용해야 한다는 것이다.&lt;br&gt;
(물론 바꿀수는 있다. 그런데 그럴거면 cra 를 사용할 의미가 있는가)  &lt;/p&gt;
&lt;p&gt;처음부터 클린하게 만들다 보면 모르는 것을 볼 수도 있고, 새로운 것을 배울 수도 있다.&lt;br&gt;
그래서 순수하게 react 설치부터 시작한다.  &lt;/p&gt;
&lt;p&gt;만들었던 test-project 에서 npm init 을 사용하여 package json 을 초기화하자.  &lt;/p&gt;
&lt;h3&gt;React 설치&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add react react-dom&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;react 와 react-dom 의 차이는?&lt;br&gt;
차이라기 보단 react 는 정확히 우리가 알고있는 react 의 기능을 가지고 있는 코어 라이브러리다.&lt;br&gt;
react를 사용하여 후크, 라이프사이클, compoenet 등을 정의하고 사용할 수 있다.&lt;br&gt;
react 로 만들어진 요소들을 dom 요소에 붙이기 위해 react-dom 이 필요한 것이다.&lt;br&gt;
기존에는 둘이 합쳐져 있었지만 react-native 가 등장하며 분리되었다.  &lt;/p&gt;
&lt;p&gt;react, react-dom 은 웹앱을 위해 사용하고,
react, react-native 는 모바일 App 을 위해 사용한다.  &lt;/p&gt;
&lt;p&gt;자 그럼 react 와 react-dom 을 설치 했으니 끝난 것인가? 아니다.&lt;br&gt;
우리는 react 로 개발하며 로컬에서 컴포넌트를 디버깅하고 테스트하고 보기 위해&lt;br&gt;
만들어진 ui 들을 브라우저에서 편하게 볼 수 있도록 해당 코드들을 번들링 하고&lt;br&gt;
추가로 web server 를 구동하여 편리하게 개발할 수 있는 기능이 필요하다.  &lt;/p&gt;
&lt;h3&gt;Bundler 설치&lt;/h3&gt;
&lt;p&gt;현재 가장 많이 쓰이는 번들링 도구는 Webpack 이다.&lt;br&gt;
플러그인도 다양하고, 커스텀하게 설정할 수 있고, 다양한 커뮤니티와 많은 프로젝트에서&lt;br&gt;
사용 중 이다.  &lt;/p&gt;
&lt;p&gt;하지만 이 글의 제목이 무엇인가? 클린하게 설치하기다.&lt;br&gt;
그리고 현재 상황에서 webpack 의 다양한 설정이 필요한가?&lt;br&gt;
정답은 아니오 이다.  &lt;/p&gt;
&lt;p&gt;webpack 에 익숙하다면 webpack 을 사용해도 좋지만 zero configuration 을 지향하는&lt;br&gt;
parcel 을 고려해보도록 하자.&lt;br&gt;
parcel 을 특이하게 설정 파일이 없다. (만들수도 있다.)&lt;br&gt;
자동으로 파일들을 감지해서 번들링하고 dev server 뿐만 아니라 hmr 도 지원한다.  &lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://ko.parceljs.org/&quot;&gt;https://ko.parceljs.org/&lt;/a&gt; 여길 참조하자.&lt;br&gt;
(한글 사이트도 존재한다.)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add --dev parcel-bundler&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Typescript 설치&lt;/h3&gt;
&lt;p&gt;참고로 저렇게만 설치해도 이제 개발을 시작할 수 있다.&lt;br&gt;
하지만 현재 fe 개발에 필수로 들어가는 또 하나의 도구가 있다.&lt;br&gt;
typescript 는 꼭 같이 사용하길 바란다.&lt;br&gt;
서비스가 커질수록 typescript 의 혜택은 어마어마하다.  &lt;/p&gt;
&lt;p&gt;잘 정의된 type 는 그 자체로 가이드 문서가 될 수 있다.&lt;br&gt;
이는 후에 새로운 멤버가 합류해도 빠르게 적응할 수 있고, 서비스의 안정성을&lt;br&gt;
한껏 높여준다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add typescript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;추가로 typescript 를 사용하기 위해서는 @types 라는 추가 패키지를 설치 해야 한다.&lt;br&gt;
이 @types 에는 일반 js 파일로 만들어진 라이브러리들의 타입을 추론하기 위해&lt;br&gt;
해당 기능들의 type 이 정의 되어있다.  &lt;/p&gt;
&lt;p&gt;유명한 오픈소스 라이브러리는 typescript 지원을 위해 자체적으로 type 이 내장된&lt;br&gt;
보조 패키지가 존재한다. (없으면 직접 만들어야 한다!)  &lt;/p&gt;
&lt;p&gt;react 와 react-dom 의 기능을 typescript 에서 사용하기 위해 보조 라이브러리를&lt;br&gt;
추가해보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add --dev @types/react @types/react-dom&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;마지막으로 typescript 를 사용하기 위한 설정파일을 만들어주자.&lt;br&gt;
typescript 의 설정파일은 tsconfig.json 이란 이름으로 지정되어 있으며&lt;br&gt;
우리의 root 디렉터리에 만들어 주면 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;test-project/tsconfig.json&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;ES6&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,
    &amp;quot;allowJs&amp;quot;: true,
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot;,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;outDir&amp;quot;: &amp;quot;./dist&amp;quot;,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;noImplicitAny&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
  },
  &amp;quot;include&amp;quot;: [
    &amp;quot;src/**/*&amp;quot;,
    &amp;quot;*.d.ts&amp;quot;
  ],
  &amp;quot;exclude&amp;quot;: [
    &amp;quot;./node_modules&amp;quot;
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 설정에 관해서는&lt;br&gt;
&lt;a href=&quot;https://typescript-kr.github.io/pages/tsconfig.json.html&quot;&gt;https://typescript-kr.github.io/pages/tsconfig.json.html&lt;/a&gt;&lt;br&gt;
여기서 살펴 볼 수 있다. 간단한 설정이니 모른다면 꼭 읽어보자.  &lt;/p&gt;
&lt;h3&gt;Router 패키지 설치&lt;/h3&gt;
&lt;p&gt;웹앱에서 Router 설정은 중요하다.&lt;br&gt;
여기선 대놓고 공식적으로 사용하라는 react-router 라는 패키지가 존재한다.&lt;br&gt;
중요한건 얘네들은 react react-dom 쌍처럼 존재하는게 아닌&lt;br&gt;
각자가 독립적으로 존재한다.  &lt;/p&gt;
&lt;p&gt;react-router - 웹, 모바일&lt;br&gt;
react-router-dom - 웹&lt;br&gt;
react-router-native - 모바일  &lt;/p&gt;
&lt;p&gt;지금은 웹앱 프로젝트에 사용 중이니 react-router-dom 을 설치 하면 된다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add react-router-dom&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add --dev @types/react-router-dom&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Dependencies&lt;/h3&gt;
&lt;p&gt;여기서 한가지 의문이 있을수도 있다.&lt;br&gt;
패키지를 설치 할 때 무엇을 기준으로 dependencies 정의하는가?&lt;br&gt;
dev dependencies 는 말그대로 내가 개발할 때 필요한 의존성이다.&lt;br&gt;
bunlder 나 test 프레임워크들 또는 dev server 를 구동하는 패키지들.&lt;br&gt;
이들은 내가 개발할때 필요한 패키지이고, 실제 제품에서는 필요 없는 것 들이다.  &lt;/p&gt;
&lt;p&gt;그리고 production 으로 빌드할 때 dev 패키지들은 포함되지 않는다.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;실제로 우리는 번들링 해서 사용하고 웹서비스에만 제공하므로 저둘을 딱히 구분 할 필요는 없다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;단지 의미론적으로 구분 할 뿐 크게 신경쓰지 말라는 것 이다.&lt;br&gt;
다만 오픈소스와 패키지 기능을 만들때는 해당 기능을 구분 하는 것이 좋다.&lt;br&gt;
굳이 런타임에서 필요없는 패키지를 넣어서 기능을 크게 만들 필요는 없다.  &lt;/p&gt;
&lt;h3&gt;index.html&lt;/h3&gt;
&lt;p&gt;자 지금까지 설치한 부분을 살펴보자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;test-project&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;test-project&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;react&amp;quot;: &amp;quot;^17.0.1&amp;quot;,
    &amp;quot;react-dom&amp;quot;: &amp;quot;^17.0.1&amp;quot;,
    &amp;quot;react-router-dom&amp;quot;: &amp;quot;^5.2.0&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^4.1.3&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;@types/react&amp;quot;: &amp;quot;^17.0.0&amp;quot;,
    &amp;quot;@types/react-dom&amp;quot;: &amp;quot;^17.0.0&amp;quot;,
    &amp;quot;@types/react-router-dom&amp;quot;: &amp;quot;^5.1.7&amp;quot;,
    &amp;quot;parcel-bundler&amp;quot;: &amp;quot;^1.12.4&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;src 폴더를 만들고 index.html 파일을 만든 뒤 react 로 만든 컴포넌트 들이&lt;br&gt;
들어 갈 수 있도록 초기 페이지를 만들자.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;test-project/src/index.html&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;ko&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;TestProject&amp;lt;/title&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;index.tsx&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;test-project/src/index.tsx&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import ReactDom from &amp;#39;react-dom&amp;#39;;
import App from &amp;#39;./app&amp;#39;;

ReactDom.render(&amp;lt;App /&amp;gt;, document.getElementById(&amp;#39;app&amp;#39;));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;index.html 과 react 를 연결해주는 index.tsx 을 만들었다면&lt;br&gt;
이제 시작 파일인 App 을 만들어보자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;

const App: React.FC = () =&amp;gt; {
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;h2&amp;gt;react&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
export default App;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자 이제 준비는 다 되었다.  &lt;/p&gt;
&lt;h3&gt;start &amp;#x26; build&lt;/h3&gt;
&lt;p&gt;이제 실제 실행하여 개발을 헤보자.&lt;br&gt;
package.json 에 실행 명령과 빌드 명령을 추가하자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  ...
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start:dev&amp;quot;: &amp;quot;parcel -p 1212 ./src/index.html&amp;quot;,
    &amp;quot;build:dev&amp;quot;: &amp;quot;parcel build ./src/index.html --public-url ./ --out-dir build/output --no-source-maps&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;parcel 명령어는 매우 심플하다.&lt;br&gt;
해당 명령어로 시작 할 경우 자동으로 hmr 지원도 추가된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn start:dev&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;를 실행하고 &lt;a href=&quot;http://localhost:1212&quot;&gt;http://localhost:1212&lt;/a&gt; 에 접속하면 react 라는 우리가 만든&lt;br&gt;
글자가 나타난다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 343px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVQoz2OwsXFydfU2NrY0N7d1dfVycfHU1NKztLQ2t7BycXFzdXMHMrS1ddU0tCSlZKSkZZERQ3h4TGRkXFBQRGhoVHx8SmxsUkBAcHh4VEREVHxCUmxsfHhElJ9/oK9fgJu7Jxpi+Pnz59+/f//8+fP9+/cvYPDt2zcg+fnzl08g8BnI/Pr1GxB9xwAM9+7d279//5EjRx4+fPj///9///79JxowPHv2DKjzzJkzL1++BPKBrvhHNGD4TwFgABrwBwz+/ftLsmaKbB6BmgGY/25iLqsuhwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen&quot;
        title=&quot;screen&quot;
        src=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png&quot;
        srcset=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/12f09/21010301.png 148w,
/static/f2cc02990ee238542ff6f37e70fb9edd/e4a3f/21010301.png 295w,
/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png 343w&quot;
        sizes=&quot;(max-width: 343px) 100vw, 343px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;추가로 build 명령어를 실행해서 실제로 빌드가 잘 되는지 보자.&lt;br&gt;
build 명령어의 옵션을 보면  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;—out-dir&lt;/strong&gt; 은 빌드된 파일을 어디에 저장할 지 나타내는 부분이고&lt;br&gt;
&lt;strong&gt;—no-source-map&lt;/strong&gt; 은 말그대로 소스맵을 생성하지 말라는 옵션이다.&lt;br&gt;
그리고 &lt;strong&gt;—public-url 옵션에&lt;/strong&gt; ./ 을 줬는데 이는 빌드된 index 파일에서&lt;br&gt;
js 파일을 불러올때 base 경로를 지정 해 주는 옵션이다.  &lt;/p&gt;
&lt;p&gt;기본적으로 빌드했을대는 주소가 /src.133131.js 이런식으로 붙게 되는데&lt;br&gt;
이는 해당 프로젝트의 루트폴더를 의미하게 된다.  &lt;/p&gt;
&lt;p&gt;우리는 루트 폴더가 아닌 별도의 폴더에 저장하게 되고 추가로 index 파일과&lt;br&gt;
번들파일은 같은 폴더에 위치하고 있기 때문에 base 경로를 현재 index 파일이&lt;br&gt;
존재하는 경로로 맞춰주는 것 이다.  &lt;/p&gt;
&lt;p&gt;이제 빌드 명령어를 실행하고 실제로 빌드된 파일을 열어보자.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;test-project/build/output/index.html&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 343px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVQoz2OwsXFydfU2NrY0N7d1dfVycfHU1NKztLQ2t7BycXFzdXMHMrS1ddU0tCSlZKSkZZERQ3h4TGRkXFBQRGhoVHx8SmxsUkBAcHh4VEREVHxCUmxsfHhElJ9/oK9fgJu7Jxpi+Pnz59+/f//8+fP9+/cvYPDt2zcg+fnzl08g8BnI/Pr1GxB9xwAM9+7d279//5EjRx4+fPj///9///79JxowPHv2DKjzzJkzL1++BPKBrvhHNGD4TwFgABrwBwz+/ftLsmaKbB6BmgGY/25iLqsuhwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;screen2&quot;
        title=&quot;screen2&quot;
        src=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png&quot;
        srcset=&quot;/static/f2cc02990ee238542ff6f37e70fb9edd/12f09/21010301.png 148w,
/static/f2cc02990ee238542ff6f37e70fb9edd/e4a3f/21010301.png 295w,
/static/f2cc02990ee238542ff6f37e70fb9edd/41431/21010301.png 343w&quot;
        sizes=&quot;(max-width: 343px) 100vw, 343px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;똑같이 나올 것이다. (사실 스크린샷은 찍기 귀찮아서 재탕임..)  &lt;/p&gt;
&lt;p&gt;이로써 기본적인 개발 환경설정은 끝났다.&lt;br&gt;
이제 본인이 필요한 test 프레임워크, 백엔드와 연결 할 패키지, 스타일 관련 등
필요한 부분만 설치해서 사용하면 된다.  &lt;/p&gt;
&lt;h3&gt;추가 의문점&lt;/h3&gt;
&lt;p&gt;Babel 은 사용안하나요?&lt;br&gt;
parcel 번들러에는 필수 babel preset plugin 이 포함되어 있다.&lt;br&gt;
(env, flow, react, typescript)  &lt;/p&gt;
&lt;p&gt;그러므로 추가적인 preset 이 필요 없는 한 별도로 babel 을 설치 할 필요는 없다.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;참고로 async await 를 사용 하기 위해서는 별도 plugin 을 사용해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;사용하는 방법은 @babel/runtime 과 @babel/babel-plugin-transform-runtime&lt;br&gt;
을 설치하면 된다.&lt;/p&gt;
&lt;p&gt;babel 설정 파일을 사용한다면 parcel 은 자동으로 해당 설정 파일을 읽어서&lt;br&gt;
빌드하기 떄문에 위 플러그인 설치 후 .babelrc 파일을 생성하여&lt;br&gt;
해당 plugin 을 지정해 주면 사용 가능하다.  &lt;/p&gt;
&lt;p&gt;자세한 내용은
&lt;a href=&quot;https://ko.parceljs.org/code_splitting.html&quot;&gt;https://ko.parceljs.org/code_splitting.html&lt;/a&gt;&lt;br&gt;
요기를 참조하자.&lt;/p&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;간단하게 web project 를 시작하는 방법을 적었지만, 빠진 부분이 많다.&lt;br&gt;
global style 설정이나 스타일 관련 부분이나 이런부분은 본인이 원하는 방향으로&lt;br&gt;
지정해서 사용하길 바란다.&lt;br&gt;
사실 오늘 적은 부분은 빙산의 일각이다.&lt;/p&gt;
&lt;p&gt;그리고 프로젝트 폴더 구조나 상태관리나 이런 세세한 부분은 정답은 없지만&lt;br&gt;
시간이 되면 아마 더 추가할지도..  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Flutter Environments Setting]]></title><description><![CDATA[밀린 글들이 많은데 시간이 없어서 못 올리는중 🤔 web 개발에서 온 사람들은 flutter 를 이용해 실제 제품 개발 시 ‘그러고보니 환경변수는 어떻게 설정하지?’ 라는 의문이 들었을 것 이다. 아마 대부분 react 를 사용 했을텐데, .env…]]></description><link>https://willowryu.github.io/2020-08-11/</link><guid isPermaLink="false">https://willowryu.github.io/2020-08-11/</guid><pubDate>Tue, 11 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;밀린 글들이 많은데 시간이 없어서 못 올리는중 🤔&lt;/p&gt;
&lt;p&gt;web 개발에서 온 사람들은 flutter 를 이용해 실제 제품 개발 시&lt;br&gt;
‘그러고보니 환경변수는 어떻게 설정하지?’&lt;br&gt;
라는 의문이 들었을 것 이다.&lt;/p&gt;
&lt;p&gt;아마 대부분 react 를 사용 했을텐데, .env 파일로 통일 시켜서&lt;br&gt;
간편하게(?) 설정을 해왔을 텐데 (이는 angular 도 마찬가지다)&lt;br&gt;
flutter 에선 어떻게 설정해야 할까?&lt;/p&gt;
&lt;p&gt;공식 홈페이지에 친절하게 설정하는 법이 있다면 좋겠지만&lt;br&gt;
아쉽게도 친절한 가이드는 없다.  &lt;/p&gt;
&lt;p&gt;그래서 실제 개발 시 사용했던 방법을 공유하고자 한다.&lt;br&gt;
사실 이 방법도 구글링으로 어디선가 에서 보고 적용한 부분인데&lt;br&gt;
해당 글이 어딨는지 기억이 나지 않아 출처를 적을 수가 없다..&lt;br&gt;
만약 기억난다면 그때 출처를 적용하겠다.  &lt;/p&gt;
&lt;p&gt;환경변수는 여러가지 용도로 사용되지만 가장 많이 쓰이는 부분이&lt;br&gt;
아무래도 API Endpoint 를 개발 환경 별로 적용할 때 많이 쓸 것 이다.  &lt;/p&gt;
&lt;p&gt;이번글은 기존 web 개발과 깉은 순서로 앱이 구동되기 전&lt;br&gt;
환경별 변수를 적용시켜 앱 내에서 사용해보자.&lt;/p&gt;
&lt;h3&gt;Init Project&lt;/h3&gt;
&lt;p&gt;내가 적는 모든 글은 이전 글과 이어지지 않고, 기존 repo 를 가져와&lt;br&gt;
사용하지 않으며 독립적으로 무조건 새로운 프로젝트에서 시작할 것 이다.&lt;/p&gt;
&lt;p&gt;새로운 프로젝트를 만들어 main 부분을 정리하자.  &lt;/p&gt;
&lt;h3&gt;Create EnvSetting Class&lt;/h3&gt;
&lt;p&gt;env 셋팅에서 우리는 2개의 클래스를 만들 것 이다.
실제 앱 환경에서 가져와서 사용 할 클래스, 그리고 환경 변수를 환경에 맞게 설정 해주는 할 클래스 이다.  &lt;/p&gt;
&lt;p&gt;먼저 환경 별 선택을 위한 열거형을 하나 만들자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/core/env.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt; enum Environment { DEV, STAGING, PROD }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;스테이징, 개발, 제품 버전의 환경을 만들 것 이다.&lt;br&gt;
필요하다면 당연히 저기서 늘려도 된다.  &lt;/p&gt;
&lt;p&gt;이제 실제로 환경 변수를 설정 하는 클래스를 만들자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/core/env.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...
  class _Config {
    static const AUTH_URL = &amp;#39;AUTH&amp;#39;;
    static const PRODUCT_URL = &amp;#39;PRODUCT&amp;#39;;
    static const WEBSOCKET_URL = &amp;#39;WEBSOCKET&amp;#39;;

    static const String devPrefix = &amp;#39;https://dev.cloud&amp;#39;;
    static const String productPrefix = &amp;#39;https://product.cloud&amp;#39;;
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;일단 예제로 사용 할 URL 은 3가지 인데 당연히 알아서 잘 늘려 사용할 것 으로 본다.&lt;br&gt;
prefix 같은 경우 공통적으로 쓰는 endpoint 의 앞 부분이다.  &lt;/p&gt;
&lt;p&gt;이제 환경 별로 URL 을 넣어보자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  class _Config {
    ...

    static Map&amp;lt;String, String&amp;gt; debugConstants = {
      AUTH_URL: &amp;#39;$devPrefix/auth/v1&amp;#39;,
      PRODUCT_URL: &amp;#39;$devPrefix/product/v1&amp;#39;,
      WEBSOCKET_URL: &amp;#39;$devPrefix&amp;#39;,
    }

    static Map&amp;lt;String, String&amp;gt; productConstants = {
      AUTH_URL: &amp;#39;$productPrefix/auth/v1&amp;#39;,
      PRODUCT_URL: &amp;#39;$productPrefix/product/v1&amp;#39;,
      WEBSOCKET_URL: &amp;#39;$productPrefix&amp;#39;,
    };

    static Map&amp;lt;String, String&amp;gt; stagingConstants = {
      AUTH_URL: &amp;#39;$productPrefix/auth/v1&amp;#39;,
      PRODUCT_URL: &amp;#39;$productPrefix/product/v1&amp;#39;,
      WEBSOCKET_URL: &amp;#39;$productPrefix&amp;#39;,
    };
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;debug, prod, staging 마다 각 변수에 맞는 url 을 대입한다.&lt;br&gt;
간단하지 않은가?&lt;br&gt;
저기서 늘리든 줄이든 커스텀하게 바꾸든 필요에 따라 변경하면 된다.  &lt;/p&gt;
&lt;p&gt;환경 별 값을 설정하는 클래스는 완성되었다.&lt;br&gt;
이제 현재 어떠한 환경인지 파악해 위 _Config 클래스에서 해당 환경에 맞는&lt;br&gt;
값을 가져오는 클래스를 만들어야 한다.&lt;br&gt;
이 역시 간단하다.  &lt;/p&gt;
&lt;p&gt;새로운 클래스를 만들자.  &lt;/p&gt;
&lt;h3&gt;Create Environments Class&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/core/env.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Environments {
  static Map&amp;lt;String, dynamic&amp;gt; _config;
  static Environment _currentEnv;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;_config 에서는 설정한 환경변수 값을 넣고, _currentEnv 에는 현재 설정한&lt;br&gt;
환경 값을 넣을 것 이다.  &lt;/p&gt;
&lt;p&gt;이제 환경변수를 받아 설정하는 메소드를 만들자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Environments {
  ...

    static void setEnvironments(Environment env) {
    _currentEnv = env;

    switch (env) {
      case Environment.DEV:
        _config = _Config.debugConstants;
        break;
      case Environment.PROD:
        _config = _Config.productConstants;
        break;
      case Environment.STAGING:
        _config = _Config.stagingConstants;
        break;
      default:
        _config = _Config.debugConstants;
        break;
    }
  }

}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 메소드는 환경변수를 받아 _config 에 우리가 만든 환경변수 값을 넣는다.&lt;br&gt;
마지막으로 해당 값 들을 가져 올 getter 를 만들자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Environments {
  ...

  static get authUrl =&amp;gt; _config[_Config.AUTH_URL];
  static get websocketUrl =&amp;gt; _config[_Config.WEBSOCKET_URL];
  static get productUrl =&amp;gt; _config[_Config.PRODUCT_URL];
  static get env =&amp;gt; _currentEnv.toString();

}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;URL 이 추가되면 getter 도 같이 늘려주면 된다.&lt;br&gt;
이걸로 필요한 클래스는 다 만들었다.&lt;br&gt;
간단한 부분이라 딱히 더 설명 할 부분이 없다.  &lt;/p&gt;
&lt;p&gt;이제 마지막으로 해당 환경변수를 설정해서 사용해 보자.&lt;/p&gt;
&lt;h3&gt;Main Delegate&lt;/h3&gt;
&lt;p&gt;우리는 별도의 명령과 값을 주어 실행하지 않고&lt;br&gt;
환경 별 실행 부분을 여러개로 쪼개서 만들 것 이다.  &lt;/p&gt;
&lt;p&gt;여러개로 쪼개서 만들게 되면 빌드 시 환경 별로 선택하기 쉬워지고,&lt;br&gt;
더해서 vscode 에서는 환경 별 debug 가 쉬워진다.&lt;/p&gt;
&lt;p&gt;먼저 환경 App 을 구동시키는 main delegate 를 만들자.
해당 delegate 에서는 앱 구동의 역활을 맡고, delegate 로 가기 전&lt;br&gt;
환경 변수를 설정 할 것 이다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/main_delegate.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  import &amp;#39;package:flutter/material.dart&amp;#39;;

  void mainDelegate() =&amp;gt; runApp(MyApp());

  class MyApp extends StatelessWidget {
  const MyApp({Key key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData.dark(),
      home: Scaffold(
        appBar: AppBar(
          title: Text(&amp;#39;Flutter Environments&amp;#39;),
        ),
        body: Container(
          child: Text(&amp;#39;env&amp;#39;),
        ),
      ),
    );
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;간단하게 main 부분을 만들었다.&lt;br&gt;
여기서 현재 환경 변수 값을 표시 할 수 있도록 위젯을 추가해보자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...

  class _BuildText extends StatelessWidget {
    const _BuildText({
      Key key,
      this.text,
    }) : super(key: key);
    final String text;

    @override
    Widget build(BuildContext context) {
      return Container(
        margin: EdgeInsets.only(
          bottom: 10.0,
        ),
        child: Text(
          text,
          style: TextStyle(
            fontSize: 16.0,
          ),
        ),
      );
    }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 위젯에 설정한 환경변수 값을 넣어보자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...
  class MyApp extends StatelessWidget {
    ...
    body: Container(
      width: double.infinity,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          _BuildText(
            text: &amp;#39;ENV : ${Environments.env}&amp;#39;,
          ),
          _BuildText(
            text: &amp;#39;AUTH_URL: ${Environments.authUrl}&amp;#39;,
          ),
          _BuildText(
            text: &amp;#39;PRODUCT_URL: ${Environments.productUrl}&amp;#39;,
          ),
          _BuildText(
            text: &amp;#39;WEBSOCKET_URL: ${Environments.websocketUrl}&amp;#39;,
          )
        ],
      ),
    ),
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;준비가 다 되었다.&lt;br&gt;
이제 실행 파일을 만들어보자.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/main_staging.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;#39;package:env_setting/core/env.dart&amp;#39;;
import &amp;#39;main_delegate.dart&amp;#39;;

void main() {
  Environments.setEnvironments(Environment.STAGING);
  mainDelegate();
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Staging 환경의 실행 파일을 만들었다.&lt;br&gt;
이제 main 을 실행 해보면 Staging 환경 변수의 값을 볼 수 있다.  &lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 335px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d3c810254c3730a0fb3f8e49e4fe9a57/c0051/env_staging.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 203.3783783783784%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAYAAAA1bQl+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB7UlEQVRIx+2V2W7qQAyG8xyAGhCLKhD7WvZ930Hi/Z/Eh89HjpKUHh2pXFQVF788tsf/eDyJ7cTjcUkkEmISRKNRiUQiKmOxWECaD133E3eHe19f3t/FMRI/ptOpLBYLGQ6H0u/3ZTKZqByPx2qbzWbS6/UCScTvcN/exMHoh+u60mq1NBiSWq2mstPpqIRoNBqpHo4FTjablTDS6bQkk0lJpVKSyWRUYkMCfOiPYp1SqSRhlMtlqVQqCtZhmP1RrFMsFuWZeD7ho7S/gxfhi/D3E/LrfLXxK1/Y7pjRHMhCoRD4P/3B+Az+GFs74VNoTY1GQ6rVqsLfpvA1m031A/Rwpt6VOZEG+dH6kMvlot15s9nIbreT/X4v5/NZlsul6qyv16seSAyxgX6Yy+W0ta/Xa50fEDE7mCvz+VyJwGq10vbPTGHNfuYP4yCfz/9tX6Td7XY1mCCkERJAoAUbAfp2u1XJgcRTCsrjkPbxeJTD4aAbjIhM7IrYOQQ72SGxQ4odiY3ktIbUgSvfbjetDQdQN7KhXhxyOp28A/BBwm3QB4OBli3wKIxLatFut3WM2mui1+t1zwe4ou1jjd97ZVvwUhTWYN+arf2+MOyVvZnyrz/kf/HpO3y1rxfhryL0t/EfQ+jneP6//OwM/wB5Tw8d4p+vwQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;env-staging&quot;
        title=&quot;env-staging&quot;
        src=&quot;/static/d3c810254c3730a0fb3f8e49e4fe9a57/c0051/env_staging.png&quot;
        srcset=&quot;/static/d3c810254c3730a0fb3f8e49e4fe9a57/12f09/env_staging.png 148w,
/static/d3c810254c3730a0fb3f8e49e4fe9a57/e4a3f/env_staging.png 295w,
/static/d3c810254c3730a0fb3f8e49e4fe9a57/c0051/env_staging.png 335w&quot;
        sizes=&quot;(max-width: 335px) 100vw, 335px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다른 환경 파일 역시 main&lt;em&gt;prod.dart 또는 main&lt;/em&gt;dev.dart 를 만들어&lt;br&gt;
Environment 값만 변경 시키면 된다.  &lt;/p&gt;
&lt;p&gt;이렇게 해두면 빌드 시 메인 파일 타겟을 횐경 별로 지정해서 원하는 환경의 앱을&lt;br&gt;
손쉽게(?) 빌드 할 수 있다.&lt;/p&gt;
&lt;p&gt;위 예제의 전체 코드&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/WillowRyu/flutter-env-setting&quot; target=&quot;_blank&quot;&gt;https://github.com/WillowRyu/flutter-env-setting&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;출처: 내 머리 &amp;#x26; 기억나지 않는 어떤 개발자의 글&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Flutter Cupertino Date Picker]]></title><description><![CDATA[디자인 시스템 없이 Flutter 를 사용하는 대부분의 개발자들이 Material Design 을 많이 사용할 것 으로 본다.   그 중 DatePicker 같은 경우 cupertino 와 Material…]]></description><link>https://willowryu.github.io/2020-07-03/</link><guid isPermaLink="false">https://willowryu.github.io/2020-07-03/</guid><pubDate>Fri, 03 Jul 2020 15:14:00 GMT</pubDate><content:encoded>&lt;p&gt;디자인 시스템 없이 Flutter 를 사용하는 대부분의 개발자들이 Material Design 을&lt;br&gt;
많이 사용할 것 으로 본다.  &lt;/p&gt;
&lt;p&gt;그 중 DatePicker 같은 경우 cupertino 와 Material 의 차이가&lt;br&gt;
가장 많이 나는 위젯 중 하나라고 볼 수 있다. &lt;/p&gt;
&lt;p&gt;Material 에서는 달력 자체가 나타나는 반면, cupertino 에서는 bottom bar 가 나타나며&lt;br&gt;
선택하는 모양으로 표현했다. &lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 436px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2bea3a5c000b5a3e1a26e37e956dadea/8574c/material-date-picker.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 141.2162162162162%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAIAAADuuAg3AAAACXBIWXMAAAsTAAALEwEAmpwYAAADKElEQVQ4y6VU60uTYRTfHxKhhWSgplJEVGIRBRKUqBlRDJegwS4woQgC+9gNamozjCxNo6ZtWmC6PvrNbxHVZm5zqcxd3d775Xnft/O8zzbdvCUdDmfnufzO7zznnL0Gu91u6bpj7rq7J7V13QagwWaznXo4V9W3erT3T23PUrUDa43uHNG1ulBrHOGK3ljD/Y92c4fBarHUPvHVDil1b7mql9yBPrZU1zInV/6CO9RfrOVO5uCAerb7s+3WTYPVajn2+EeDS7zuoU++powT7A0Pc/E9fWaYbhlnGj/QFf3URq10pg8PSOe6J62dGGytfPCzelCqH6JPDzHnR5nmcbbhHXN8kL4wytQPM/ufZUocVEkPTbTUkdn3XK67N2nrNGHm1le/Gj2o0cU0jbGXXOxlF9fsllrc4tUJqdUjgl5xC3BEtGWMaZpQrz36ZO4wGSwWy+LioqZpkiRquoATjawk47HVyMoa/EQja6mklhNR4MF6Z2ZMpiw4rCgqL+TBKBqLxeOJaDSWTKbAzVCUqmqqfsqwLNjpPDgYCsEaKQpCSJZl8BUV34SIYFUimiYjRCwGT0/nmXHaBCkIAvgkBPiwCUBFUcgFPS8J7EyeOaQzkxs7CLlA4q4zbwdW1YIlSYrjuF2Y9Tdm7UYnf22dORwOQzKiKIJlGAbO0uk0WJqmYQeeyvM82YQorF5tr9fb1ta2lzdruFvFzFBtiAfM8CoSOJVKAQlkAUu4nUgkcIfTSah7Op2BnWJm0hXyvGy3dSFH0PLvEZ6V8DAUFAyYkS5ATlEUnFF4pFR4M88LElI0iXX75DIn/XRORjytbn4zGRJSG9IPsLiKAEbC1xA68YYb/CarIlvMrORmc2MzYZhgB45IIZYSNGRPoheAIUNSMNKkeDxOCkb6B0tcxWQCZh5quUXBdm3V1kPyLxOm5pao6F/1X8yBQICUB20SGM4EIy+nZbCqgkQJRTL4m/FlagqD4QO4M3NM0AKUlsBN0GRFW2YUMttZ8OzsbDAY9Pl8/q0k8NsfWsAWZN7vX5j3QXdGRkba29sxGGJc3V5ac5pfghiNRrPZ/Beoq0Uf6gHpFgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;material-date-picker&quot;
        title=&quot;material-date-picker&quot;
        src=&quot;/static/2bea3a5c000b5a3e1a26e37e956dadea/8574c/material-date-picker.png&quot;
        srcset=&quot;/static/2bea3a5c000b5a3e1a26e37e956dadea/12f09/material-date-picker.png 148w,
/static/2bea3a5c000b5a3e1a26e37e956dadea/e4a3f/material-date-picker.png 295w,
/static/2bea3a5c000b5a3e1a26e37e956dadea/8574c/material-date-picker.png 436w&quot;
        sizes=&quot;(max-width: 436px) 100vw, 436px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 517px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b62240fc84274a90b06bbdf49a50f359/fa2f5/cupertino-date-picker.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 64.86486486486486%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVQ4y42T3WoaURDHz15IRShqENKASLASpOBWFHwQZUUJwSUPoHilN37cG8hFc9EHyF7YFpJ38UZQU1ALIpFkVVy/9kzOjLtgi0kz8Gdm58z5nZmzu+z01M+OjtxhRcno19ffodG44VdXN/AeNRrfOO7JZM6N42OffHb2mTGfz8tcrg/hi4uc3mzewe3tD65pP0HTfsHOvy6sbTbvQVUvDbf7o+z3nzDbwuVyWYedcXi/UW2tVjMEQ2Z7Fi6VSgQ0TZOvVitYLpdgGAZgzDknL9Yoj892Lfpqtfo2cLFYwGw2I83ncwKh32w2lNtutxQLEbBSqbwOxDHG4zG0223o9XrQ7XYJOBqNAA/qdDqg6zq0Wi3MvQl8tjo0cTzsZDqdCr/rEMe3O0T/9PSMuf8Dxf2Y6/WaI8AWAkWOQPiMd4jjitHtO1z8C/xiv2VRhE2aYoOJDR8SGh5s1XDrpXzdB/oURXkQ9tc3geP1+30YDockjPEa9m0wGEA2m/0jGLuPMJVKSfV6nQWDwVQymewWi8VJPp9/RK+q6kSsT8RhJIxzudwE1wqFAtWI3O9QKJTVNI2l02mJJRIJhEniMOR/slqXbTmdTtnhcJAw3l+zak9wbyAQkGKxGCNgNBqlTtkB83rx13SRPB7PoRImupcikQiLx+PsBa2FabizEZULAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cupertino-date-picker&quot;
        title=&quot;cupertino-date-picker&quot;
        src=&quot;/static/b62240fc84274a90b06bbdf49a50f359/fa2f5/cupertino-date-picker.png&quot;
        srcset=&quot;/static/b62240fc84274a90b06bbdf49a50f359/12f09/cupertino-date-picker.png 148w,
/static/b62240fc84274a90b06bbdf49a50f359/e4a3f/cupertino-date-picker.png 295w,
/static/b62240fc84274a90b06bbdf49a50f359/fa2f5/cupertino-date-picker.png 517w&quot;
        sizes=&quot;(max-width: 517px) 100vw, 517px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;둘 중 원하는 뭘 선택해도 되지만, 여기서는 cupertino 의 date picker 를 살펴보자.&lt;br&gt;
cupertino 의 date picker 를 사용할 경우
onDateTimeChanged 라는 콜백함수로&lt;br&gt;
날짜 데이터 변경을 알 수 있다.&lt;/p&gt;
&lt;p&gt;여기에 날짜를 변경 한 뒤 사용자가 직접 제어할 수 있도록&lt;br&gt;
cancel 과 done 기능을 추가해보자.&lt;/p&gt;
&lt;h3&gt;Init Project&lt;/h3&gt;
&lt;p&gt;일단 신규 프로젝트에서 cupertino date picker 를 불러오는 버튼을
설정 하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          brightness: Brightness.light,
          backgroundColor: Colors.transparent,
          elevation: 0.0,
          title: Text(
            &amp;#39;Cupertino Date Picker&amp;#39;,
            style: TextStyle(
              color: Colors.black,
            ),
          ),
        ),
        body: SafeArea(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Center(
                child: CupertinoButton(
                  child: Text(
                    &amp;#39;OPEN DATE PICKER&amp;#39;,
                    textAlign: TextAlign.center,
                  ),
                  onPressed: () {},
                ),
              ),
            ],
          ),
        ),
      ),
    );&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 314px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/22d2be84ec0b5245a7aaac3c3c763bc1/5b158/date-picker.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 214.86486486486487%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAArCAIAAAD3xz8iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEEElEQVRIx52W+08jVRTHbwzrKoWCfUwftDMdZvoubSn0waMLRZZE2ZWN7q6vmGj8zfgH+INR/wR/hI1uNDH+pDGFlvUn6WNFXdhklxZiqAIhrLW1ZSUppTN94Gmn1C5ghDn55uTO9HzmnHvu3DtF1l5nb5+7t88FvsfWZ7X3gweZLL12h2t84sUhrw9uujzD3pExR78HwgaHR90DXqPZjlwuz+iI79Iln29s3OnyuD1DIKdroMfmcLkH33jzralrL/f1uy9PvHDj5uvD3tGBQe/1G69euTrVY7UjCeUWk84OpalVSgsVRglh4yTV2DDSLsatEsJavSRsIpWlHdO1KwwdXWYR4ehQO5BAPynAtE6Pd3Lq+tDIuESuxpREVQocJD2SWKZSqEjfxKS3f8Bisl6UGp5SjyGBwvLRhx/8mUzGY7F0OuUbHWlvE2CYVCoRc8KkErkMa332mXffebtYKi58+82tTz5+7eYrLTI7UpLm2MqDUrmyublZLpd3dnZCoVA0Go1EouFwOHr3biQSCYcjcCeTybIMm8ru/haLffr+exfENNIYHPHYw8PDw1LN0ul0MplMpVLgs9ndra0t7g48NJfLQQDLMBD83ddftXRokEbfy8EHBwfFYhEev55IQBUbG5uPHv2RSCS2t7eBXF9f39vbAzifz0Pw93eCLZ0aRGmNMFu4LhQKLMtC5TCuVCrNnhvAoyEAcsB4Pjh7AeBunSUeW2nATM0KNWuMG74B3wnOPS3qRqShXjYH/6814IsiElG6J8o+O9wqUiOaLywAmNL3NM/5jPB8cK5NDJm1eh6ZazCOKIqKx+PnhgOzApkOEQS5ygtukxsRDvAqH7gdYELTzatsv1BpQmQ3zW/O7Qojomh9PB7jDetOwkzTgPlP2IBI8vhSwd4pF9lS8V8PKp6amXiy2xCUL7CZHPt3nn28X9VurqoCc6JhXWaE40QzDKn28uyvfzFbu8xGltl+zPyeYRIZJndQT87BwYAfztBTug17vlKqVVuqCy5PK1t/+hsG257h/JGONSwYmBVCw46VfcalqpVtQgRlWOW1zkKlEZF6K4/9XG+Y1uKEQ//c8Jy/U2VGuh4XHzjg7+SfmZszbeqLrzzk0zBYKsro4HFu12Gt2RE7f+baS6JHRos9xq9suQ6RlJbnYQCwSo3zej1n2zAKqdX42toa931mjuwk0/hpf3+/+n2eD1RhCSb/+adF7p/B4ZGVSuUmgZWbfqqGffnF7VYJiYQy+qWrV8Kh0PLS0r17v9y/v7yw8MPM9PStmemZGfDgpm9//tni4o/Ly7WA5aXAnN/tdmPaISQzPd/ZZRLJVEqcVuIUeJVGp6GNGtpEas0ggjKCughtLYBWkbrnMFzS7VI5rv0DXIu4pK4ZNZAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;date-picker&quot;
        title=&quot;date-picker&quot;
        src=&quot;/static/22d2be84ec0b5245a7aaac3c3c763bc1/5b158/date-picker.png&quot;
        srcset=&quot;/static/22d2be84ec0b5245a7aaac3c3c763bc1/12f09/date-picker.png 148w,
/static/22d2be84ec0b5245a7aaac3c3c763bc1/e4a3f/date-picker.png 295w,
/static/22d2be84ec0b5245a7aaac3c3c763bc1/5b158/date-picker.png 314w&quot;
        sizes=&quot;(max-width: 314px) 100vw, 314px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Cupertino DatePicker 같은 경우 해당 DatePicker 를 보여주고
말고는 위젯 자체를 숨기거나 보여주거나 해야 한다.&lt;/p&gt;
&lt;p&gt;(Scaffold 에서 지원하는 게 아닌 datepicker 위젯을 만들어두고
해당 위젯을 보여줄 지 말지 직접 컨트롤 해야 한다.)&lt;/p&gt;
&lt;p&gt;이를 위해 일단 Cupertino DatePicker 위젯을 별도로 만들자.&lt;/p&gt;
&lt;h3&gt;Create Cupertino Date Picker&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/lib/date_picker.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  import &amp;#39;package:flutter/cupertino.dart&amp;#39;;

class CuDatePicker extends StatelessWidget {
  const CuDatePicker({Key key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return CupertinoDatePicker(
      initialDateTime: DateTime.now(),
      maximumDate: new DateTime.now(),
      minimumYear: 2018,
      maximumYear: 2020,
      mode: CupertinoDatePickerMode.date,
      onDateTimeChanged: (DateTime value) {},
    );
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;(date picker 에 들어간 설정은 이름만 봐도 뭘 하는건지&lt;br&gt;
알 수 있으리라 생각한다.)  &lt;/p&gt;
&lt;p&gt;만들어진 DatePicker 를 메인화면에 적용해보면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 305px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f73cb836d7a74671adda62f30c563e7a/a3e09/cu-datepicker.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 206.08108108108104%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAIAAAC6D54pAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD6ElEQVRIx7WVS08TURTHJ8GEKAiERxEoFktpkafoAlBaBNr6ESAE/RCKbnWpRjE89kYWJhiILFghj+iCBCQCCW2pWoWE0CeFdvqYTh/4n7llmCkt4sLD7c3cOec359xzzz1QFyta82UKpbq+vulWtaahoOhKfmFpYUl5abkiZRSXylWaBrVSUylXZhdczSq5SRVXqAf6e4dev3r54vnjwUd9fb0P7g90d3fl5V3OybmUm5uDgecLF7Jut7X+3tmZ/TAxNjg4MNCfXVxDtbXfmZ+fm5mZmf44PTExMTU1NTk5OT4+Pjw8PDIyMjo6OoK/0bGhoTerq6tHR0d2p2v585f3z56WlF2jDMZ7eBWNxhKJBB4OePH7/REIy4ZCIYZhQsFQOBxmWRbPmGH2de6TvFJF9egNwKCDAvOvX7bl5eX19fVv39ZMJtPKysrGxsbmpmlpaWl3dzcej8MG9j9+/lDUNFIGgwFf4t1wAnWCF7yMJ+KYhWUsFiPO8fx9y6JQ1Utg/GJsxO5jNuzMTw9jdjI2D/PdzS0PAkyU04vgmgaEbRR75tQRNhzhZmGEGVZQJ2Grpep02IJE2fRCYKt1S6WupYwZYPZvsFpTm9Hz/4Y1lNGYCkej0fPAKnVdGs9Qi5cpQQlHpay9QfX09Ihh6Hw+H8ozGAwiBJqmvV6vOJakZw5uBqwXYBgFAgGQYFDVZHl4eJgWroZnvV4v9gw/brfb5XKBRz2eBV+Xwpg9Hg9gXCx4BowoMoWd6hkK4hZXJ8qLnwZ8kAFuTvXsdDrhlliThAnLjDC55Zj39vaETWJGzg+xhXDY6XAgInxdErY42xD4wbbFZ4st4BMgyXsBVtUdnzPpMjTt397eRobIFogplvv7+1ar1Wazka7EwRYzl23imWTI4XCgAbndHuSZ1Bms7XY7ErG2tma2WE7gLXO1UCSkIjGgpmmcbuA4PRGcFraP7oQOBQM0u5OEkbCZ42zTvAR5Ic75TprcRWqRoHuKjyogEgFOc6uS2ZbCxCdIPCMLMM0Eq+paKL1B0gAFtwieZBuX7Az43mmYz1mQvEQg6WHuYog8I04UCeoBFU7u8xlh8xdDCiNanCpChRGWOP9MYZPaluyZnBYpOGKaKWweNhjPboApSwlsOAWfq/Wevs//CDdR3dLueX5YqWlMekaGIucTWMJ+y2JWwbNOp8P/btwYkhsisaTEhVlQgQdsMm2WK2ooWZl8/N1bFJSPFxwM+sHs7OzCwsL8sSwuLrpdbjpAE5sDr/fJ4MM8WRVVIG8sKq1oa2vXdd7VIgxdp1bX2dGh5Yb2ZIaKjM67Xc3NLQWySplG+wfL6PF9Fh8idQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cu-datepicker&quot;
        title=&quot;cu-datepicker&quot;
        src=&quot;/static/f73cb836d7a74671adda62f30c563e7a/a3e09/cu-datepicker.png&quot;
        srcset=&quot;/static/f73cb836d7a74671adda62f30c563e7a/12f09/cu-datepicker.png 148w,
/static/f73cb836d7a74671adda62f30c563e7a/e4a3f/cu-datepicker.png 295w,
/static/f73cb836d7a74671adda62f30c563e7a/a3e09/cu-datepicker.png 305w&quot;
        sizes=&quot;(max-width: 305px) 100vw, 305px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;해당 화면처럼 나온다.&lt;br&gt;
(버튼은 위치는 위로 올렸다. 스샷 다시 찍기 귀찮음..)  &lt;/p&gt;
&lt;p&gt;모양은 나오지만 우리가 원하는 건 아이폰처럼 하단에 적절한 크기와&lt;br&gt;
모양으로 나타나길 원한다.&lt;br&gt;
이제 위치와 크기를 수정 해보자.  &lt;/p&gt;
&lt;p&gt;우리는 date picker 를 scaffold 에서 제공하는 bottom sheet 에서
나타나도록 별도로 수정 할 것이다.&lt;/p&gt;
&lt;p&gt;그리고 해당 bottom sheet 의 높이를 설정하고,&lt;br&gt;
date-picker 내부의 width 를 제한 할 것이다.  &lt;/p&gt;
&lt;p&gt;(이는 landscape 레이아웃 에서의 문제 때문이다.&lt;br&gt;
뒤에서 설명 할 것 이다.)&lt;/p&gt;
&lt;p&gt;그럼 크게 Todo 를 정리해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;버튼으로 bottom modal sheet 를 Toggle 할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;Date Picker 는 Cancel, Done 라는 별도의 컨트롤 버튼이 존재한다.&lt;/li&gt;
&lt;li&gt;Date Picker 가 나타내는 시각은 한국 시간에 맞춘다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;버튼으로 BottomModal 컨트롤&lt;/h3&gt;
&lt;p&gt;showModalBottomSheet 같은 경우 Future&lt;void&gt; 를 반환한다.&lt;br&gt;
Widget 이 아니라 Future 를 반환 하기 때문에 뭔가 버튼이나 제스처에&lt;br&gt;
연결 시켜 사용해야 편하니 기존 버튼을 별도로 export 하여 만들자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class _BuildButton extends StatelessWidget {
  const _BuildButton({
    Key key,
    @required this.showPicker,
  }) : super(key: key);

  final Function(BuildContext context) showPicker;

  @override
  Widget build(BuildContext context) {
    return CupertinoButton(
      child: Text(
        &amp;#39;OPEN DATE PICKER&amp;#39;,
      ),
      onPressed: () {
        showPicker(context);
      },
    );
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;간단하게 버튼을 분리했다.&lt;br&gt;
이제는 해당 showPicker 함수에 date picker 를 넣어주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    Future&amp;lt;void&amp;gt; showPicker(BuildContext context) {
    return showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return CuDatePicker();
      },
    );
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Root Widget (여기서는 MyApp) 에 showPicker 함수를 만들어주자.  &lt;/p&gt;
&lt;h3&gt;Create Bottom Modal Sheet&lt;/h3&gt;
&lt;p&gt;이제 DatePicker 의 모양을 변경 해야한다. &lt;/p&gt;
&lt;p&gt;height 를 조정하고 내부 width 를 제한 할 것 이다.&lt;br&gt;
height 의 크기는 현재 스크린의 약 3/1 정도를 차지하도록 만들 것 이다.  &lt;/p&gt;
&lt;p&gt;현재 스크린의 3/1 길이..&lt;br&gt;
반응형으로 생각하면 현재 디바이스 스크린의 길이를&lt;br&gt;
구하는 유틸 함수를 미리 만들어 두자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;double getHeightByPercentOfScreen(double percent,  BuildContext context) {
  return MediaQuery.of(context).size.height * percent / 100;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;현재 스크린의 크기에서 원하는 퍼센테이지를 입력 받아 그 길이를&lt;br&gt;
구하는 함수이다.&lt;br&gt;
조금만 손 보면 당연히 width 길이도 구할 수 있다.&lt;/p&gt;
&lt;p&gt;그럼 hegiht 를 구했고, 내부 width 의 크기는 퍼센테이지로 구해도 되지만,&lt;br&gt;
기존 모바일의 길이를 생각히면 maxwidth 를 400 으로 정했다.&lt;/p&gt;
&lt;p&gt;showPicker 함수를 수정하고 datePicker 위젯에 width 제한을 두자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;lib/main.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  Future&amp;lt;void&amp;gt; showPicker(BuildContext context) {
    return showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return Container(
          height: getHeightByPercentOfScreen(33.0, context),
          child: CuDatePicker(),
        );
      },
    );
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;lib/date_picker.dart&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;#39;package:flutter/cupertino.dart&amp;#39;;

class CuDatePicker extends StatelessWidget {
  const CuDatePicker({
    Key key,
    this.onDateChange,
  }) : super(key: key);

  final Function(DateTime value) onDateChange;

  @override
  Widget build(BuildContext context) {
    return Container(
      constraints: BoxConstraints(
        maxWidth: 400.0,
      ),
      child: CupertinoDatePicker(
        initialDateTime: DateTime.now(),
        maximumDate: new DateTime.now(),
        minimumYear: 2018,
        maximumYear: 2020,
        mode: CupertinoDatePickerMode.date,
        onDateTimeChanged: onDateChange ?? (DateTime value) {},
      ),
    );
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 한번 date-picker 를 소환해보자.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 303px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1990d423fd030a87dc4ffc1ea698d74d/6728c/date-picker-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 217.56756756756758%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAsCAIAAADqwg+aAAAACXBIWXMAAAsTAAALEwEAmpwYAAADj0lEQVRIx+1W204TURQdExODoIBCy0VJRXgY7dAZSpEiEGitnSkGqy0xipWrSG3obaZgEL6AZ32TH1CjfAUJ+BtQA9iCcinQiqvn0GFQTPRVWZnu7LP3Wmfvs3syGUZp6Zh8aI08bbI57tjs9rtut+TqlFyuRqtVdHV++PjxzZuZ206xr39gZmZmNBiEPz7+4tWr148e+xjBaDbX1wvmepazsJz5Wl2DkW+EU8vynHDD5nA5pC6jyWJpanOIXdYWG8c3trbf7rr3oOFGC1NgsObp2bwLhvyLVQUlhqLymsKymiI8cPRX8y9UnS2+XKivPldqyCu+dOZ8Oezp8+VM/qVTunqm6koNbzK573Z5Pfcdjlu60pKDR1ei15VmH70OFpHyMr3U6fK6JN/NZhNvOldxnamtrYlEIiN+/8iIPxaLWZubWfaa0cgZNeA4jmXZ1ta2WGwsEAj0e7zKo4fVV6oZXhDGxsagj0ajsizDh40SqI6aon5QUaYGB/lqiHkeBWUCJIaGhh77fL29vX19fYODQz09PQMDA1j6fE+Gh58pigIafhFFQT+MIAgQ070BtDA6OhoJh6LhEGw4FMz6+AWD4XBEziGmKJwq1kbDUeVZUA6EZH9IDoRhlZGgjCCpegBFK1YrgxCKyH4ifh46sFhqqv5eTPUxBelDm3Xkn8XGX9v+Q2TFxv9PfPy0T8Qn4n9GDI++ev8c0GffJGazeWpqamJi4uXfYHJysq7OxLjd7vX19ZWVlVWCLzms5qD1KUBOJpO3HA6mu7t7f38/k8l8J0ilUpubm9vb23t7e4jDwkc8Q0A5cJASRYnxer3wdnZ2dgkSiQQ2hh4RKDc2NlB5LwfKQQp6p1M8IoaNL8UTXxKUB7u1tQUx/G8EKu14McpStlokq0mlPhPgCMeIcVSEYDEJjASkHQJQcQTUX1paisfjcCktnU4fiumEkF5YWEBxbKxut7i4COXc3Nz8/Dw9f07sPFIZRZaXl9eSSbU9AL2g8lcC2tHPYnXa4OGQGLLaNpawaYKj03YyHo9HK94gQAuwtD4K7h7FoRiXBP+7Vgz22toa9CmCJDmFSqBidCGKIiNJLnqTaGM4ENL7GtD7BEsJYMJFpL29Hd8kwuzsrDqzdCaDW46Zf9IAS9y87NYEIL9/97asooqZnp7Gx1JHR4ckSegE1mazWRosQKMGdrsdKSchgFx52VBYef0HLvqAEIIBtHIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;date-picker1&quot;
        title=&quot;date-picker1&quot;
        src=&quot;/static/1990d423fd030a87dc4ffc1ea698d74d/6728c/date-picker-1.png&quot;
        srcset=&quot;/static/1990d423fd030a87dc4ffc1ea698d74d/12f09/date-picker-1.png 148w,
/static/1990d423fd030a87dc4ffc1ea698d74d/e4a3f/date-picker-1.png 295w,
/static/1990d423fd030a87dc4ffc1ea698d74d/6728c/date-picker-1.png 303w&quot;
        sizes=&quot;(max-width: 303px) 100vw, 303px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제 어느정도 모양이 잡혔다.&lt;br&gt;
하지만 아직 부족하다.  &lt;/p&gt;
&lt;h3&gt;Create Cancel, Done Buttons&lt;/h3&gt;
&lt;p&gt;날짜 선택 후 실행 될 또다른 로직을 위해&lt;br&gt;
추가로 Done 버튼과 Cancel 버튼을 추가해주자.  &lt;/p&gt;
&lt;p&gt;우리는 bottom sheet 를 7:3 비율로 나눠서
상단(3) 에 버튼을 두고,&lt;br&gt;
하단(7) 에 날짜 선택을 넣을 것 이다.&lt;/p&gt;
&lt;p&gt;그러기 위해 버튼 부분의 위젯을 만들고, bottomSheet 에&lt;br&gt;
Column 위젯을 추가 할 것이다. &lt;/p&gt;
&lt;p&gt;먼저 2개의 버튼 셋이 포함 된 위젯.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class _BuildButtonSet extends StatelessWidget {
  const _BuildButtonSet({
    Key key,
    this.onPressCancel,
    this.onPressDone,
  }) : super(key: key);

  final Function onPressCancel;
  final Function onPressDone;

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        CupertinoButton(
          child: Text(
            &amp;#39;Cancel&amp;#39;,
            style: TextStyle(
              color: Colors.red,
            ),
          ),
          onPressed: onPressCancel ??
              () {
                Navigator.pop(context);
              },
        ),
        CupertinoButton(
          child: Text(
            &amp;#39;Done&amp;#39;,
          ),
          onPressed: onPressCancel ??
              () {
                Navigator.pop(context);
              },
        ),
      ],
    );
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Cancel 과 Done , 2개의 버튼을 가진 위젯이 완성 되었으니&lt;br&gt;
이제 DatePicker 와 합치기 위해 showPicker 함수를 수정하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    Future&amp;lt;void&amp;gt; showPicker(BuildContext context) {
    return showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return Container(
          height: getHeightByPercentOfScreen(33.0, context),
          child: Column(
            children: [
              Expanded(
                flex: 3,
                child: _BuildButtonSet(),
              ),
              Expanded(
                flex: 7,
                child: CuDatePicker(),
              )
            ],
          ),
        );
      },
    );
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 318px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0465e1a5b1a06acbd2866f546e6c3522/cd2d9/date-picker-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 212.16216216216216%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAqCAIAAAA8m+yHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEpklEQVRIx6WV2U9bRxSHpxIQoCze9w1jYzBLSqJSCqEyi222go2NbYQFAZyFzdi+Jly7UR+iKFJf2qc8VlUrFAhNbQhu1f+heWlSBam0qQSlINaAwIDZeu69sYuiNnXdo9HRzJnfN+ec0Vwb6WoNgw2Gm336JmPHB/WWemNXXUuntqWzvLpV22q///nk7buf1TTZHEP4nU/uGzquN7f3+u98esN1+4rWiCordDZNvdVSq9EbyzQtlXXGKp3pirattEJfUWf0fHSv3/Pxe5oWS9fgCH5X32qvbrB4/Pd6+r2XK7QoQ65JEl5OylamZEtT6dJMdm4Whxg0vjKLq0jJFl2gibM4inSGLCmDn5IpTKaJURr3rey8ZMG7iKbS8kSKyopyvV5XW1srFotYLBYHjM2GwSUNVhDMkUlrdbrmsjLNpVK6SJEsrERM6SW9tvrWrTFHnwPHcZ1OJ5fLVSpV3jmDZa5c3tjYiPt8vXa7u6OjsfL9VH4xYkuLbdb2MRx3Op0ej2d0dNTtdrvARkj3yo9AELY8bjeIcMzbpal6m5+P2LKL1nYTHAmk1+vt7+/v6uru6r7a09PrcDg67fa+vr7u7qsQHBoaAgHwIDaZDBm8fMSRqK0WM44TMIZh4CERpAYRDCiCmHiIWigBLHw+X3sbCfPFcqvFAt1Se14Mc3kwxzB2cxi7PozdcGLXhrFrQ0QQtqjTIbMZMkPZXFnR+czkNuZ0YU434UdIDyO6eR4uQDxpvtXSfh4m8nujIzqPmYcs29xmhIeAhJJcEsbPw28wCja1GZmCXMQTSqxWSwIwA2B4SFarNQGYJVQgHo+fEGxgCPMQNyHY3GagiQoRTyBOoGcCFqoRk8Wx2awJwgwmy2azJVg2jcZIDKaLixCbw0vswuj/98ISL1ukRlzJ33wY8cI8eclrn2ScMENciISK0tjP0H+GBQBbzD6/n/yM/91A5vf7zSYjBb9jNLTAT9TAwMBgHAYyl8vd+mETg7iwnGI/PhYIBMfHxx/EYSALBqe9mDuTp0QsccH334XOzs6Oj4/P4rCjoyPw3zyaSmPmIKZIFQoGzjY39n6dP9zZOYxEDt9ov6zurUbOJiYepDFliAXw7Awcth8OR+KwcDgM4qlJEmYIFKHZxwS8vx9TQIZ/gvcp+OFEKkOCGPzcGAz97OzsrK+vUwfBcnd3d2trCyax46KZAZa+Dm9ubq6trR1GXkkhCMeBX15e3tjYAEH4r8xSRI/CYbJnKvPe3l4kenMwh/yLi4vEoeSSgi/QRIjGk1PwwcEB8M+e/bSwsHByckLVCcHV1dWlpaUfnjx5PjcHS6giCgsQjSuLZQZbWVmheo7B0AhVDjQPQarsh9AzZM7myL4NzcIa6qH2QLq9vQ2TfdJevnwJceiWOosq++upyTS6CKXR+MHAI1hHyKcDOlCAlHpwp6enEKEmhEVf2FdffpGSJUAZHGVzU8Pc3PM/lpZ+X1wEPz//88zM9HQw+HgGbDoQCIRCod9evIgJnj79saamOp2Th+g55elMCfzdqYsuFqhLCgpLwCvzC5UqtVJF+DxyTsTJATIOX5TOlDGVVX8C0GX10bqJquoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;date-picker2&quot;
        title=&quot;date-picker2&quot;
        src=&quot;/static/0465e1a5b1a06acbd2866f546e6c3522/cd2d9/date-picker-2.png&quot;
        srcset=&quot;/static/0465e1a5b1a06acbd2866f546e6c3522/12f09/date-picker-2.png 148w,
/static/0465e1a5b1a06acbd2866f546e6c3522/e4a3f/date-picker-2.png 295w,
/static/0465e1a5b1a06acbd2866f546e6c3522/cd2d9/date-picker-2.png 318w&quot;
        sizes=&quot;(max-width: 318px) 100vw, 318px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제 원하는 date picker 가 완성되었다.&lt;br&gt;
여기서 추가로 디자인이나 크기를 원하는 상태로 수정 하면 된다.&lt;br&gt;
로직은 onPressCancel, onPressDone, onDateChange 에&lt;br&gt;
적절히 넣어서 사용하면 된다.&lt;/p&gt;
&lt;h3&gt;Localization&lt;/h3&gt;
&lt;p&gt;마지막으로 DatePicker 에 나오는 시간을 한국 시간으로 변경해보자.&lt;br&gt;
localization 을 하기 위해 pubspec.yaml 에서 flutter_localizations 을 추가하자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
  dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 main.dart 의 MaterailApp 에서
localization 관련 코드를 추가하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;      return MaterialApp(
      localizationsDelegates: [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: [
        const Locale(&amp;#39;ko&amp;#39;, &amp;#39;KO&amp;#39;),
        const Locale(&amp;#39;en&amp;#39;, &amp;#39;US&amp;#39;),
      ],
      home: ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 앱을 리셋 시키고 다시 date picker 를 열어보면&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 332px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/9587a509bb2d72e7475d6993dc1e5192/f8dc5/date-picker-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 205.4054054054054%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAIAAAC6D54pAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFC0lEQVRIx52U21MTdxTHdzpD6yhVkr0mu5vNbTcXAgZaAUUuEhEI3qjtDKOwibQSciOQi8EnfCi9vGm99H+ore1DR+tDW0RRkPLqi32sYKioJBESCKQnG6DqjDJw5pff/nJ+55Pv75zf5iCW8rp9lbWV1futlfXWirqyyvrSPbUwLOXVdYeOHv1MrNjfuGd/o62lrfqA/aO9DTUHD8MoragvUNUijR9XnWuu6f98T3NTc0NDQ2trq91ut9lslZVVPp/v+k8/tre3t7Udv3jhQiAQaGpqOj84+O03Xx9osBUw+xCKr1LoyxUaC8mZKM6s1BQrtcUwKzTFjK6UE8pgpnUWTrCyuhJKbWYFq8ZUQWjLC9hapFB/qJAUWI2gN1hYNY8SSoykMZKBIcdpGaYAD0rQRXJSqdLp1TynVL0vV79HVRWobQiqrair2ef3eb0eNwyB11MkQSso5dqg4UMSOq3G4/P6u7qCn544WFO9gy7ZprcjOFfiFDsikajH44lEIjA7nc7Tkr26cLvd4XDY2xsI+Py9rS1yJb+NtyOUZrfYcTI6MAB7/f39LpfrzJnunh63q9vldnu6u7tdrh7J0xMMBsOh0MC5c87OUzhjyClTmhKx8xTAsBcKhbw+H8T5/T6f1yNN7l5IyePxer2wCzFnz0a7Tjsw1rgdlGm1UezsiEZX4Ug4HAhG3IGwty/s6Qv7+3Pr3mAYMsrD0Wi0yykCvENoRZTa15TBevuDnkDQFwh6A0F/ILfu7VvdWodx1lRoOAKw5Q04nNNfHeH8HAq9DjtIVthpPIywWvMb8Lq9+X0NPu10KFR8kQmUGY0odq7n/G57DTYfQUiScjgc4NoczPF46TFEqaRFUdwkLCo4I2FtA5jZAkxyZrT0OKKgVVLOm4VNaMkxBMPJzecswbvbEBQjNgkPAAx/bNz6CYKi+BaUKXUxUXYCoZmt5ExxptxVEaRiS9U2YSVHEZykHQ5xi8pKbenb3u135mwm4SVh+LJOqZNs7g3Lw6xQvgU4V+2cst566mQ7dAro6X0bGcRAq3N0duSOvVuCXd1fDA19NTg4eH4jg5gvh4agsZEqI1YstaHbw39ks9n4y40tmUhA5Pj9Uag2ZmmF7mm5B/CL56mpfzKLi5m32FIms7Kc+TeRnk5lxx5MUJwRM7cgkProyDD83kI8vphOL77TkvOpTDY78WCcUuVhzjR6dyQHpzYgwdKpFET+NTFOqgyY+RACj1V4YeHVuKWlpUQiMTs7m0qlY7GZRCIOHoj5Hy5uBmXjOgzbyWTyiWTpdBoAWIDezMzM8+cvIPE1+AHJGlCjDYFHHp6fnwfBeDw+NTX1+PFjiJubm5uampacc8+ePYPFujLB8jKhHiEYYR0G5UeP/p6cnBwbG5uefvL06ezY+Dgw4Hz48CHUHGLyygSjl/F1CE7zo3dWYTgqKL+QLJVKwcXGYjFwwuFjT2Lw03kYqk2yPGqwITijv39vNA8DsChd9crKyvLyMmDghDWULX/sPDw5OUGpBLnhAFKIMrdu3gAXMFnJJAyqnVlYSEH9wJ9MvkxJl5SPGf7z9124CoOCfagwNjYevHnj17t3RkZuD98bvfvLz9cvfXfx+6tXrly+dOXyZVhfu/ZDfvfOyO1bv920tzTvIAQUCibT7d2GabfvIuQEK8OVRRiNkizF6ChGuzZrMQUnw+kinJYTzPad+AcyTs7XEObG/wBHBqIYKvEfDgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;date-picker3&quot;
        title=&quot;date-picker3&quot;
        src=&quot;/static/9587a509bb2d72e7475d6993dc1e5192/f8dc5/date-picker-3.png&quot;
        srcset=&quot;/static/9587a509bb2d72e7475d6993dc1e5192/12f09/date-picker-3.png 148w,
/static/9587a509bb2d72e7475d6993dc1e5192/e4a3f/date-picker-3.png 295w,
/static/9587a509bb2d72e7475d6993dc1e5192/f8dc5/date-picker-3.png 332w&quot;
        sizes=&quot;(max-width: 332px) 100vw, 332px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;한글로 변경 된 picker 를 볼 수 있다.&lt;br&gt;
여기서 만약 한글로 변경 되지 않는다면 해당 모바일 폰의 설정 에서&lt;br&gt;
지역과 언어를 한국으로 변경해보자.&lt;/p&gt;
&lt;p&gt;추가로 DateTime 설정에 관해서 쓸 내용도 있지만 이는 별도로&lt;br&gt;
글을 써서 정리를 해보겠다.  &lt;/p&gt;
&lt;p&gt;위 예제의 전체 코드 &lt;/p&gt;
&lt;p&gt;github repo: &lt;a href=&quot;https://github.com/WillowRyu/flutter-cupertino-datepicker&quot; target=&quot;_blank&quot;&gt;https://github.com/WillowRyu/flutter-cupertino-datepicker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;출처: 내 머리..&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Flutter Multi Device Debugging]]></title><description><![CDATA[Flutter 는 구글에서 공개한 크로스플랫폼 프레임워크다.
모바일 만이 아닌 웹과 데스크탑도 지원하지만, 아마 대부분 모바일로 
개발 하고 있으리라 본다. Flutter 의 렌더링 특성 상 개발한 UI 는iOS 와 Android…]]></description><link>https://willowryu.github.io/2020-07-02/</link><guid isPermaLink="false">https://willowryu.github.io/2020-07-02/</guid><pubDate>Thu, 02 Jul 2020 13:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Flutter 는 구글에서 공개한 크로스플랫폼 프레임워크다.
모바일 만이 아닌 웹과 데스크탑도 지원하지만, 아마 대부분 모바일로
개발 하고 있으리라 본다.&lt;/p&gt;
&lt;p&gt;Flutter 의 렌더링 특성 상 개발한 UI 는iOS 와 Android 에서 똑같은 화면을 나타내지만,&lt;br&gt;
그래도 기기 별로 보고 싶거나, 실제 기기와
동시에 보면서 개발 하고 싶을 수 있다.  &lt;/p&gt;
&lt;p&gt;예를 들면 태블릿 버전도 동시에 개발하거나,&lt;br&gt;
iphone 5 를 지원 한다거나, 다양한 사이즈의 모바일을 동사에 보고 싶거나..&lt;/p&gt;
&lt;p&gt;이럴때 시뮬레이터든 실제 기기를 사용하든 PC 의 사양이 받쳐주는&lt;br&gt;
한계 까지 동시에 디버깅 하는 방법이 있다.&lt;br&gt;
본인은 이번에 Tablet 과 mobile 사이즈를 둘 다 지원하는 반응형 앱을 개발 했기에&lt;br&gt;
유용하게 써먹은 기능이다.&lt;/p&gt;
&lt;p&gt;이름하여 &lt;/p&gt;
&lt;h2&gt;Flutter Octopus !!&lt;/h2&gt;
&lt;p&gt;(실제로 저 이름이 맞다)&lt;/p&gt;
&lt;img src=&quot;https://pbs.twimg.com/media/ELhtpHuUEAAB6hO.jpg&quot;&gt;
&lt;p&gt;실제로 사용 해보자.&lt;br&gt;
신규 프로젝트로 실제 iphone 11, ipad, pixel 3, android Tablet 총 4개의 기기를&lt;br&gt;
실행 하여 동시에 디버깅 해보자.&lt;/p&gt;
&lt;h3&gt;Create Configurations&lt;/h3&gt;
&lt;p&gt;vscode 의 디버깅 탭에서 Add configuration 을 클릭하자.&lt;br&gt;
자동으로 루트 폴더에 .vscode 폴더와 launch.json 이 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 371px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/cf823707882af9e9380a0126a7a5446e/d4635/0702-1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 106.08108108108108%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAIAAADJt1n/AAAACXBIWXMAAAsTAAALEwEAmpwYAAACF0lEQVQ4y5WT6XPSQBjG8z94VZ3WaQ0JR4CGkGNzcQjhTDinrTp2MEexScGOYAsIxFqr7Yx+8D92kQ92LGO3M78vO7vP7vM+77tYkT/azZ69yV+9enFR4D2Ncwuct5KGMq7JJ3VlpEtDSFMZY0LAytL9hjEtM5Ma5zfAuRJ2AeGI5ME/ANJZIpLLXQcTCEul3KJglxKnGv0RLsXg33PXEa+xXGIy2U3TJ1r9p8H4be5bnhpKeFcJeShgW2vq86d5imow0SrNvI7GW0S4vPUkvflQ3Xx0C9jGA+HZY7BNRqhoFmdrBKPjTGVjDazf49fv3wK07eaTvY553OIuX4IfxdgI2lbDRyhgHGFplHuaH1S4WTEx4mFg5OrAboKBgJWK9evlz+XEGGZws0P/AfbZydEH3v5+lfXvpFyIQcBOJTzDHFSTUzl0yOPmnV621OhhQevr7LxIj9KRnhTsoophQinSbgf3KsnZjnRZ58+UkAtIB9G2CSIeI/va9tDgfIP1U5HeytleLRZDrsB+qjCTFrjYka+y1HtUsYBbcszOlTpVZgY9N4QvGaoPgxDJLkLNuJWJ253WXikxaQrnOjeHo7L4lQhlY3zAykRsS92FrWpL33V2Bq/IxQYCYSPYJkwp+C4X/2Cw0yb4anBzqM9SxyhlYwB/K0Z7fPUXlNWFRc2V5FQNe0hi4c9PkHATngaEDRZuHcQh+Q3iGU+misHRHgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;flutter-octopus&quot;
        title=&quot;flutter-octopus&quot;
        src=&quot;/static/cf823707882af9e9380a0126a7a5446e/d4635/0702-1.png&quot;
        srcset=&quot;/static/cf823707882af9e9380a0126a7a5446e/12f09/0702-1.png 148w,
/static/cf823707882af9e9380a0126a7a5446e/e4a3f/0702-1.png 295w,
/static/cf823707882af9e9380a0126a7a5446e/d4635/0702-1.png 371w&quot;
        sizes=&quot;(max-width: 371px) 100vw, 371px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;launch.json 에는 flutter 디버깅 할때 사용 할 디바이스 정보는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;type&lt;/li&gt;
&lt;li&gt;device id&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가 필요하다.&lt;br&gt;
간단하게 첫번째 device 를 등록해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
  &amp;quot;configurations&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;current_device&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;
    }
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 vscode 의 디버깅 탭을 보면 current_device 라는 이름의
디버깅 타겟이 생성된 걸 볼 수 있다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 226px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/00c3bcc218acdaf6dd257ba0050aa2ea/5f7d4/0702-2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 17.567567567567565%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8ElEQVQY00XMzU6DQBQFYN6lG4saoQMIc2eAaBNj1Go0bf1ti9YAk6ZQNXHjQpemD+DjHq9gdPHlnJObXEvJDCqYQfV+CeYxd/q/o+yPDKegMEO0NUG4cYOoewdpTxDZbVrJ/gL6uAINKujhCnRWQx0uoa6fQBfcT/nmlC3XoO+9QNMCJAxm6RdO/Hf4nXsM/A+MaA0r3jNQ50vIcQV1W0NeVpAj7nN+eFWDfraTQ+7kTfb9ZygykKLAMPzEgfuKoJNhrNc4Em+wUj4muyWSXtHyuAfM4S7KRipNI2FxVDADvZ2Dug9Q9iPizbxJsuf4BpXblo+hFWGuAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;debugging-1&quot;
        title=&quot;debugging-1&quot;
        src=&quot;/static/00c3bcc218acdaf6dd257ba0050aa2ea/5f7d4/0702-2.png&quot;
        srcset=&quot;/static/00c3bcc218acdaf6dd257ba0050aa2ea/12f09/0702-2.png 148w,
/static/00c3bcc218acdaf6dd257ba0050aa2ea/5f7d4/0702-2.png 226w&quot;
        sizes=&quot;(max-width: 226px) 100vw, 226px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위 설정에서 특정 device id 를 지정하지 않았기 때문에
해당 디버깅은 현재 타겟으로 설정 되어 있는 디바이스를 대상으로 한다.&lt;/p&gt;
&lt;p&gt;그럼 이제 여기서
안드로이드의 pixel 3 시뮬레이터 기기를 등록해보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;0.2.0&amp;quot;,
  &amp;quot;configurations&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;android_pixel_3&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;,
      &amp;quot;deviceId&amp;quot;: &amp;quot;emulator-5554&amp;quot;
    }
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;deviceId 같은 경우 Android 는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;adb devices&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;명령어로 해당 device 의 아이디를 알 수 있다.&lt;/p&gt;
&lt;p&gt;이제 디버깅 탭에 android&lt;em&gt;pixel&lt;/em&gt;3 라는 타겟이 생성 되었을 것 이다.&lt;/p&gt;
&lt;p&gt;기존 타겟과 함께 pixel 3 를 실행시키기 위해 먼저 기존 타겟을&lt;br&gt;
디버깅 하고 그 후 디버깅 탭에서 android&lt;em&gt;pixel&lt;/em&gt;3 를 실행시키자.&lt;/p&gt;
&lt;p&gt;결과는 ?&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/17a251b8ade1270717f4cf37120720c1/33c15/0702-3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAACVklEQVQoz2MwNvRztYi1N4410wgx0w42MPPUN/UwMHU3tPAxsvESVTPjVzblVjRl4FdJzi6bOHMRr5y+vIqOkq65orYlg4myv5l2kIGSt4Git6ach5KmraKGjbKGtaqBi7qhU+7MIx1HftTtfJu3/uWUZbumLt/h1H0itHtnxKxLdnnzGHRVvTVV/FSlXJVl3NQkHFXEnFTFnFREHbTkfHXlgi6eufT///+/YHDk2OmN2/Y8e/n6738QWLxmK4OuWpC+Xoy2Zqi+ir+mrIealAsQqUo66yj6aCv5njpxFqju569fP3/+2rv/0LrN2169fP73zy+g4Mq1Wxh0FH1NdSOMdEJ1FXy05Lw1ZTw1ZTw0pT20ZL1UJB1OnjgNVPf16zcgOHDw4KZNm589e/brF0jzinXbGDTlPHXkAwyUQw1UwgxVww1Uw4AMfeUQDWkPJXE7iObPnz9//fp1//4DW7Zuf/LkCdAgkGagzVpyXibqocaakQaqITry/tpyfroKAbqK/hoyIM0nwJp//Pj588f3A4eObt6x7/nz53/+/AEKLgdplvey0I0y0Y0x1Iq01I201IvUVw4CmgjUrCxud+H8ZaC6P79BqtumLonOqvv+9fPff6AAW71hK4O+gpehWpC2SqCugqehqreBireGtLuGtBvQ2aqSDtOmzty3f9+endsXbdzrGFFo75v48sWzt29ef/r2s2biUgZd5WAt7RgT5SB99RADJT9deW91KaBOd3Updw1ZFy4uPmZmJnZ2TnZWJnEFXXmTAFPnMCOHYGOnMHljHwA6nwqiownv2QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;debugging-device&quot;
        title=&quot;debugging-device&quot;
        src=&quot;/static/17a251b8ade1270717f4cf37120720c1/fcda8/0702-3.png&quot;
        srcset=&quot;/static/17a251b8ade1270717f4cf37120720c1/12f09/0702-3.png 148w,
/static/17a251b8ade1270717f4cf37120720c1/e4a3f/0702-3.png 295w,
/static/17a251b8ade1270717f4cf37120720c1/fcda8/0702-3.png 590w,
/static/17a251b8ade1270717f4cf37120720c1/efc66/0702-3.png 885w,
/static/17a251b8ade1270717f4cf37120720c1/c83ae/0702-3.png 1180w,
/static/17a251b8ade1270717f4cf37120720c1/33c15/0702-3.png 1463w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스크린샷에서 보이듯이 iphone 11, pixel 3 가 동시에
디버깅 되고 있다.&lt;br&gt;
심지어 핫 리로드도 동시에 진행된다.&lt;/p&gt;
&lt;h3&gt;Multiple Device Configurations&lt;/h3&gt;
&lt;p&gt;이번에는 iPad 와 Android Tablet 을 추가하여
총 4대를 동시에 돌려보자.&lt;/p&gt;
&lt;p&gt;그리고 iphone 11 역시 별도로 디바이스 id 를 입력하여&lt;br&gt;
원클릭으로 4대의 기기를 동시 디버깅 할 수 있도록 변경하자.&lt;br&gt;
참고로 ios simulator 기기의 device id 는&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;instruments -s devices&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;명령어로 알수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;    &amp;quot;configurations&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;android_pixel_3&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;,
      &amp;quot;deviceId&amp;quot;: &amp;quot;emulator-5554&amp;quot;,
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;ios_iphone_11&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;,
      &amp;quot;deviceId&amp;quot;: &amp;quot;2EDE7A91-FB2D-413C-8EEA-139543D33623&amp;quot;,
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;ios_ipad_7th&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;,
      &amp;quot;deviceId&amp;quot;: &amp;quot;DB43D5D4-3097-4547-BD5E-8147D58A8670&amp;quot;,
    },
    {
      &amp;quot;name&amp;quot;: &amp;quot;android_tablet_10.1&amp;quot;,
      &amp;quot;request&amp;quot;: &amp;quot;launch&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;dart&amp;quot;,
      &amp;quot;deviceId&amp;quot;: &amp;quot;emulator-5556&amp;quot;,
    }
  ]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;2대의 태블릿과 2대의 모바일을 등록하였다.&lt;br&gt;
이제 디버깅 탭에서 하나하나 실행하면 4대 동시 디버깅이 가능하다.&lt;br&gt;
그런데 여기서 일일이 하나하나 실행하기에는 굉장히 귀찮은 작업이다.&lt;br&gt;
4대도 귀찮은데 기기가 더 늘어난다면 이 얼마나 비효율 적인 작업인가.&lt;/p&gt;
&lt;p&gt;그래서 한번의 클릭으로 동시에 실행시키는 명령어를 만들어보자.&lt;br&gt;
configurations 밑에 compounds 라는 항목을 추가하자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;quot;configurations&amp;quot;: [
    ...
  ],
  &amp;quot;compounds&amp;quot;: [
    {
      &amp;quot;name&amp;quot;: &amp;quot;All Devices&amp;quot;,
      &amp;quot;configurations&amp;quot;: [
        &amp;quot;android_pixel_3&amp;quot;,
        &amp;quot;ios_iphone_11&amp;quot;,
        &amp;quot;ios_ipad_7th&amp;quot;,
        &amp;quot;android_tablet_10.1&amp;quot;,        
      ],
    }
  ]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;name 에는 원하는 타겟 명령 이름을 기입하고,&lt;br&gt;
configurations 에는 해당 명령을 실행 할 때,
포함되는 설정들을 넣는다.&lt;br&gt;
우리는 위에서 만든 4개의 디바이스 설정을 넣었다.&lt;/p&gt;
&lt;p&gt;자 이제 디버깅 탭에서 All Devices 라는 이름을 볼 수 있을 것 이다.&lt;br&gt;
한번 실행해보자.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 309px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a0575f0a256200a6c0811a7465571b98/532e8/0702-4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 209.45945945945948%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAqCAIAAAA8m+yHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACrElEQVRIx+2U6U/iQBiH+9kYE9dks1ld40GheEKv6TEtBRUYbnVXEV0PaCtQsKKoiwSPoGY/bDYm+w/vIESNMUb9sB82JE8mv3TeZzqZvh2CHdsKATvhO5Qogx/JymI+ECvBxT24bMuZivzNlmZ2MfJ0XgO2CspfhZ/qRGlZvIFUkVCm9CBTQVw1zFYRU53nbL9U9EuWX7gb2+GOgGhpbFGbKfg9xYDH0mbyRFAori1cZiO/c9FbM/5nNXAW4gsIlBEodRAeYyGpFBYtJJZwIHDperBpxG530K8InhAKEamMw3NYS9pJAlbWF5pxWEkqB4Tkzc/zh0FwvMBXNaas0qUX0FhbY/ZwpY8p40AwVE4gDZ7MAVIXnOZrAM5OJcFRuuwypXfRlf+9vCtTD7xBZlw5wZHjHVlA4nEHOLIiabwSQmWtqHyKQXIt6buIwtMAb7/AXIt9DM6E6tlMKcfpufOUXM0EmstqTfNsarNbmndbo5/B593CCgYHYqDP1dcz4hzlh1j4UYSfZHVQ1ga1+c+sMjBA9feM9/c62nzodfT1jIkciqONROT7FKUQk1/i08Mp6NmAtC7TpsIWJNqAfMHrXpsaTj5hYiiOFHM1VknHDzRmkxBdOnRbUama4M8WuWaKu1zirlLspUpZiruIgY+QXIWVUN1YuTbTNwl4RAByGx96GNgxvh5jG0viVZSpI/oHIFvnj5eWXMY9AplbCdX01SszfR2DB215NyLuY3lRaCbBRYI/xyHK1iPMqW+yLDqN+w8rkDqWjSfynNdCzEmYriGmhp0410B0LTh7pEwURdeDjBdK+o4y0UYm1giD/ZaMOwxfJqB1mbTJtntGaG3beNJV/HiOHc2yI1nBoXfeLFPm4w59oVXxQ+hugZWO/M4foyt35a7838h/AbgMo9zbjcbQAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;debuggin stack&quot;
        title=&quot;debuggin stack&quot;
        src=&quot;/static/a0575f0a256200a6c0811a7465571b98/532e8/0702-4.png&quot;
        srcset=&quot;/static/a0575f0a256200a6c0811a7465571b98/12f09/0702-4.png 148w,
/static/a0575f0a256200a6c0811a7465571b98/e4a3f/0702-4.png 295w,
/static/a0575f0a256200a6c0811a7465571b98/532e8/0702-4.png 309w&quot;
        sizes=&quot;(max-width: 309px) 100vw, 309px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a95345485910af1f853515437f1d753a/161ec/0702-5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACgklEQVQoz2OQ1HGQMXTRck4qnHuieMmlnHnnsueeLVxyJaNxvqCWC5emK4OEWXh6VVx6EY+ogoSijqicpqSSnrSyjoSyIUPPgTfd+18nNK+8eOf5m1//n3z6B0Svfvw/efHGlAPPZp741LX//Yqdpwtr2hyL5wY0rQluXOlTtyKoZb2OQyjDfzBYvnbr/UdPgYx/f3/9+/sTyLh29ernL18gshfOnW3v6v349SuQ/fffvx+/fwMZWSX1DH+B/L9/Zy/ZcPPuI6DeH2AAFLl46fKr1+++/fj54+fvo8dPtnd0fnz35v/f37+BAt9BpuQW1zD8/fsHqGf5xj0Pnr4E2QwGQMa9+/e+gq0CgqtXr06cNPHz589AQ4FGf/v2DSiYU1QNcvaTx49KytumTlqyaummJQvWLVmwdumStf29M+fNWrFkIZC9rrNzUmJizr69h//9+/sVDECai8Gad+8+rK8SZK4dry3rryHtqynjaaDmoqPspizsqiRjL6lqLKtmqmpgl5SRf/vWLaC7IGGRU1jJ0D99QXJmlYVegpNxroVGvIlKhK6it5NxgL1xkImGr6Gqj46Cp7acp6KofWFO499/QD/+/w0OsNySGgYGcQtuGTsL3UhrnRRDxUh9hRBteQ9jNTc9ZVdVKUdlcQcVSUc1GWc5Qbuo4Nz9+/fs2L595/atu/bud/SLZuBVtBJSsLXSSXbRL7ZWzzBTjdeR9bY3DDDR8FKVdFWXcVMTd1Xld9SU8JCRtOAUVeaRUAchcXU+GX0GdnFtfnFDa+14T5MKK7U0U5U4LVlPawN/My1fdWl3DQk3bX1fw+QYXX1/aTErThkDbhkjblljblkTbhljAHc8YzkOgzlRAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;all devices&quot;
        title=&quot;all devices&quot;
        src=&quot;/static/a95345485910af1f853515437f1d753a/fcda8/0702-5.png&quot;
        srcset=&quot;/static/a95345485910af1f853515437f1d753a/12f09/0702-5.png 148w,
/static/a95345485910af1f853515437f1d753a/e4a3f/0702-5.png 295w,
/static/a95345485910af1f853515437f1d753a/fcda8/0702-5.png 590w,
/static/a95345485910af1f853515437f1d753a/efc66/0702-5.png 885w,
/static/a95345485910af1f853515437f1d753a/c83ae/0702-5.png 1180w,
/static/a95345485910af1f853515437f1d753a/161ec/0702-5.png 1840w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4개의 기기를 동시에 디버깅 하는 모습을 확인 할 수 있다.&lt;br&gt;
실제로 개발 할 때 특별한 경우가 아니면 시뮬레이터를 4대,5대 돌리면서&lt;br&gt;
디버깅하진 않을 것 이다.  &lt;/p&gt;
&lt;p&gt;완성된 앱에서 약간의 수정이 필요 할 경우 동시에 켜두고 비교 해보기 좋다.&lt;br&gt;
또는 다양한 사이즈의 UI 를 비교하거나.&lt;/p&gt;
&lt;p&gt;아니면 안드로이드와 아이폰의 UI 를 같이 볼 경우,&lt;br&gt;
또는 반응형 앱을 만들 경우 모바일과 태블릿을 동시에 디버깅 하기에 좋은 기능이다.&lt;/p&gt;
&lt;p&gt;해당 기능의 자세한 설명은&lt;br&gt;
(&lt;a href=&quot;https://github.com/flutter/flutter/wiki/Multi-device-debugging-in-VS-Code&quot;&gt;https://github.com/flutter/flutter/wiki/Multi-device-debugging-in-VS-Code&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;위 링크를 참조하자.&lt;/p&gt;
&lt;p&gt;이글이 누군가에게 도움이 되었길 바란다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Native Android 개발 후기]]></title><description><![CDATA[React 가 jQuery, Angular js 를 누르고 현재 가장 널리 쓰이는 Front-end 
프레임워크 가 된지 몇년이 흘렀다. (네 정확히는 UI 라이브러리 입니다.) Google 을 좋아해 Angular…]]></description><link>https://willowryu.github.io/2020-05-07/</link><guid isPermaLink="false">https://willowryu.github.io/2020-05-07/</guid><pubDate>Thu, 07 May 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;React 가 jQuery, Angular js 를 누르고 현재 가장 널리 쓰이는 Front-end
프레임워크 가 된지 몇년이 흘렀다. (네 정확히는 UI 라이브러리 입니다.)&lt;/p&gt;
&lt;p&gt;Google 을 좋아해 Angular 를 주로 해왔지만, 대부분 React 를 사용하니 어쩌겠는가&lt;br&gt;
먹고 살기위해 일단 대세에 따라 React 로 제품을 만들고 있다.&lt;/p&gt;
&lt;p&gt;그 중 이번에 React Native (줄여서 RN) 를 활용하여 태블릿 앱을 만들게 되었다.&lt;br&gt;
Cross platform 을 좋아했기 때문에 이전에 Ionic, Native Script 그리고&lt;br&gt;
현재 핫 한 Flutter 를 사용 하여 만들었지만, 유독 RN 은 건들여 본 적이 없다.&lt;br&gt;
(그 당시 회사에서 RN 을 활용한 프로젝트를 하고 있었지만 참여하지 않았다.)&lt;/p&gt;
&lt;p&gt;어쨋든 결국 개발 완료 했으니 만들며 느낀 점 과 수많은(?) 버그에 대처한 방법을&lt;br&gt;
공유 하려 한다.&lt;br&gt;
이 글이 누군가에게 조금이라도 도움이 된다면 좋겠다.&lt;/p&gt;
&lt;p&gt;개발 당시 RN 의 버전은 0.61+, 즉 Fast Refresh 가 적용된 버전.&lt;/p&gt;
&lt;h2&gt;Expo?&lt;/h2&gt;
&lt;p&gt;처음 RN 설치 시 Expo 를 활용한 방법과 순수하게 RN 을 이용하여 설치 하는 방법이&lt;br&gt;
있는데 Expo가 뭔가 하고 찾아봤더니, RN 개발을 좀 더 쉽게 해주고, 내가 만든 앱을&lt;br&gt;
웹으로 볼수 있게 해주고, 어쩌고 저쩌고…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결국 나중에 Eject 를 해야 하는 상황이 올 수 있다?.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그래서 Expo 는 탈락 시키고 순수 RN 을 설치하게 되었다.&lt;/p&gt;
&lt;p&gt;다들 알겠지만 타 패키지 의존성은 최대한 줄이는 것 이 좋다.&lt;br&gt;
특히 React 같이 커뮤니티에서 큰 힘을 발휘하는 라이브러리 일 경우,&lt;br&gt;
여러 패키지를 설치 해서 사용 중 React 버전을 업데이트 했을 때&lt;br&gt;
충돌이 발생하는 경우가 잦아 질 수 있다.  &lt;/p&gt;
&lt;h2&gt;설치한 Package 들&lt;/h2&gt;
&lt;p&gt;아래는 개발시 사용했던 패키지들 이다.&lt;br&gt;
기본적으로 설치되어 있는 Package 외에 추가로 설치한 건 다음과 같다.&lt;br&gt;
(TS 버전으로 설치)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;axios&lt;/li&gt;
&lt;li&gt;hangul-js&lt;br&gt;
(태블릿 자체 키보드가 아닌 커스텀 키보드 사용으로 한글 입력시 필요하여 설치)&lt;/li&gt;
&lt;li&gt;moment.js&lt;/li&gt;
&lt;li&gt;react-navigation&lt;/li&gt;
&lt;li&gt;redux&lt;/li&gt;
&lt;li&gt;redux-observable&lt;/li&gt;
&lt;li&gt;rxjs&lt;/li&gt;
&lt;li&gt;styled-components&lt;/li&gt;
&lt;li&gt;typesafe-actions&lt;/li&gt;
&lt;li&gt;react-native-code-push&lt;/li&gt;
&lt;li&gt;react-native-config&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eslint 나 자잘 한 건 목록에서 빼고 주요 패키지는 위 목록으로 설치 하였는데&lt;br&gt;
저 목록의 기능 중 가장 좋았던 건 rxjs 와 code-push 다.&lt;br&gt;
폰트는 spoqa han sans 폰트를 추가 하였고&lt;br&gt;
Test 관련 패키지는 모두 삭제 하였다.  &lt;/p&gt;
&lt;h2&gt;고통의 시작&lt;/h2&gt;
&lt;p&gt;장단점은 뒤로 하고 이 글의 목적인 개발 시 마주친 버그들에 대하여 살펴보자.&lt;br&gt;
(본인은 네이티브 앱 경험 개발이 없고, RN 을 처음 접했다.&lt;br&gt;
그렇다. 미리 밑밥 깔아 두는 것 이다.)&lt;br&gt;
(또 하나 중요한 건 제품 특성 상 Android Tablet 전용으로 만들었기 때문에 iOS 는 패스)&lt;br&gt;
(또또 해당 버그를 접하며 느꼈지만, 기종이나 환경에 따라 해결방법이 다른 것도 있다.
한마디로 RN은 아직 깔끔하지가 않다.)&lt;/p&gt;
&lt;h3&gt;1. Android Network Error&lt;/h3&gt;
&lt;p&gt;처음 API Fetch 를 실행하니 request failed 가 계속 나타났다.&lt;br&gt;
코드를 이리 뜯고 저리 뜯고 찾아봐도 무엇이 문제인지 알수 없었다.&lt;/p&gt;
&lt;p&gt;emulator는 물론 이고 실제 device 에서도 같은 현상이 발생했고,그 외 다른곳&lt;br&gt;
(web, postman 등) 에서 호출 시 정상 작동을 하니..
이 무슨 아아러니한 일인가&lt;/p&gt;
&lt;p&gt;API 가 까칠하게 제품 가려가면서 응답하는 것도 아니고..
해결한 방법은 의외로 간단했다.
permission 에러로 permission 을 추가해주면 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;xml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 코드를 android/app/src/main/AndroidManifest.xml 의 파일에 추가하자.  &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;xml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;manifest xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; package=&amp;quot;com.yourapp&amp;quot;&amp;gt;
    &amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;
    &amp;lt;application&amp;gt;
      ...
  &amp;lt;/manifest&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;본인은 이런식으로 깔끔하게 해결이 되었다.&lt;br&gt;
혹시나 권한을 추가해도 해결이 되지 않는다면 아래 issue 링크를 열어 토론을 확인해보자.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react-native/issues/24408#issuecomment-490368508/%22%20target=%22_blank&quot;&gt;RN Android Network Error issue&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. RN StatusBar Hidden 시 헤더 밀림&lt;/h3&gt;
&lt;p&gt;제품을 만들었는데 상단에 상태 창을 숨기기 위해&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;StatusBar hidden /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;옵션을 주었다고 하자.&lt;/p&gt;
&lt;p&gt;여기서 로그인 화면을 만들고,
아이디를 입력하기 위해 TextInput 에 Focus 를 둘때&lt;br&gt;
아래에서 virtual keyboard 가 올라온다.&lt;br&gt;
동시에 헤더 부분이 같이 쭉 올라간다.  &lt;/p&gt;
&lt;p&gt;헤더는 그대로 두고 텍스트 창 밑으로 키보드가 나오게 하고 싶은데&lt;br&gt;
야속한 헤더는 같이 승천한다.&lt;br&gt;
문제는 승천한 헤더가 keyboard 가 사라진 뒤에도 내려오질 않는 것 이다.&lt;br&gt;
해당 문제는 기본적으로 softkeyboard 의 설정 문제다.&lt;/p&gt;
&lt;p&gt;android/app/src/main/AndroidManifest.xml&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;xml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  &amp;lt;activity android:windowSoftInputMode=&amp;quot;stateVisible|adjustResize&amp;quot; ... &amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;windowSoftInputMode 는 여러가지 옵션이 있지만&lt;br&gt;
기본적으로 adjustUnspecified 값이 되어있다.&lt;br&gt;
상황에 따라 adjustPan 과 adjustResize 를
결정하여 나타낸다.&lt;/p&gt;
&lt;p&gt;두 옵션을 살펴보면&lt;/p&gt;
&lt;p&gt;adjustPan 은 keyboard 가 올라왔을 때 포커싱 된 input 을 기준으로 화면이 이동하게 된다.
동시에 올라온 키보드에 의해 다른 부분은 가려지게 되고 만약 입력받는 부분이 아래쪽에 있다면
당연히 위 쪽 컨텐츠 역시 가려지게 될 것 이다.&lt;/p&gt;
&lt;p&gt;adjustResize 는 keyboard 가 올라왔을때 화면의 크기를 자동으로 조정한다. 화면의 모든 부분이
보이지만 올라온 키보드로 인해 화면이 줄어든다.&lt;/p&gt;
&lt;p&gt;추가 다른 옵션은 아래 링크를 확인하자.&lt;br&gt;
&lt;a href=&quot;https://developer.android.com/guide/topics/manifest/activity-element.html#wsoft&quot;&gt;android Soft keyboard options&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자 이제 알아서 결정하는 건 그렇다 치고, 뭘로 결정 되었든 내 헤더는 왜 같이 승천할까&lt;br&gt;
만약 adjust resize 가 되었다면 헤더는 그자리에 있어야 할 터이고,&lt;br&gt;
adjust pan 으로
나타낸다면 헤더가 올라가는 건 이해된다. 그럼 키보드를 내렸을 때&lt;br&gt;
같이 내려와야 되는 것 아닌가?&lt;/p&gt;
&lt;p&gt;커스텀 스타일의 헤더를 사용한 것도 아니고 진실(?)되게 react-navigation 의 옵션을&lt;br&gt;
그대로 활용하였다.
아래는 내가 작성한 공유 헤더의 옵션이다.&lt;br&gt;
해당 부분 어디에도 커스텀한 흔적을 볼 수 없다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const sharedHeader: StackNavigationOptions = {
  headerStyle: {
    backgroundColor: &amp;#39;#fff&amp;#39;,
    height: 110,
    borderBottomWidth: 0,
  },
  headerTintColor: &amp;#39;#000&amp;#39;,
  headerTitleStyle: {
    fontSize: defaultFontSize,
    fontFamily: FontType.REGULAR,
  },
  headerTitleAlign: &amp;#39;center&amp;#39;,
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;StatusBar 의 hidden 옵션을 제거하면 정상 작동하지만, 어떻게든 없애야 한다.&lt;/p&gt;
&lt;p&gt;그래서 검색 한 결과 그렇다 버그였습니다.&lt;br&gt;
&lt;a href=&quot;https://github.com/facebook/react-native/issues/13000&quot;&gt;BUG Issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;안드로이드의 자체 버그 였다.&lt;br&gt;
아마 지금은 해결이 된 것 같으니, 어느 옵션을 사용해도 정상적으로 작동 할 것 이다.&lt;br&gt;
그래서 windowsoftKeyboard 옵션을 adjustPan 으로 변경하나 해결 되었다.(?)&lt;br&gt;
그리고 지금은 adjustResize 를 사용하고 있다?.&lt;/p&gt;
&lt;p&gt;업데이트가 되서 해결 된건지, 코드가 잘못 된 건지 아직도 미스터리다…&lt;br&gt;
의도치 않은 삽질이었다.&lt;/p&gt;
&lt;h3&gt;3. Unable to resolve path to module ‘react-native-screens’&lt;/h3&gt;
&lt;p&gt;앱을 실행 시 해당 문구의 에러가 나타났다.&lt;br&gt;
react-navigation 관련 문제 이다.&lt;br&gt;
react-navigation 을 사용하기 위한 의존 패키지 중 하나인 react-native-screens 의&lt;br&gt;
경로를 찾을 수 없다는 건데…
이상하다..분명히 난 설치 했었는데…&lt;/p&gt;
&lt;p&gt;어쨌든 react-navigation 에 설명된 패키지를 다시 설치 하였다.  &lt;/p&gt;
&lt;p&gt;react-native-reanimated&lt;br&gt;
react-native-gesture-handler&lt;br&gt;
react-native-screens&lt;br&gt;
react-native-safe-area-context&lt;br&gt;
@react-native-community/masked-view  &lt;/p&gt;
&lt;p&gt;설치하니 해당 문구의 에러가 사라졌다.&lt;br&gt;
만약 설치해도 에러가 난다면 node_modules 를 삭제하고 패키지를 다시 설치해보자.&lt;br&gt;
그런데 이상하다..분명히 난 설치 했었는데…&lt;/p&gt;
&lt;h3&gt;4. async storage 관련 버그&lt;/h3&gt;
&lt;p&gt;react-native 에서 lcoal storage 와 비슷하게 쓰기 위해 async storage 를&lt;br&gt;
설치하여 사용 하던 중 계속 storage 에서 값이 넘어오지 않는 문제가 생겼다.&lt;br&gt;
(애초에 값이 저장 되지 않았을 수도 있다.) &lt;/p&gt;
&lt;p&gt;async storage 와 sqlite 와 다르다.&lt;br&gt;
async storage 는 JSON 과 같이 키 와 값 쌍으로 데이터를 저장하는 방식으로&lt;br&gt;
간단한 데이터를 저장하고 불러오기 좋다.&lt;/p&gt;
&lt;p&gt;데이터가 서로 얽혀있고 join 이나 merge 가 필요할 때는 sqlite 를 사용하자.&lt;/p&gt;
&lt;p&gt;어쨌든 또 무슨일이냐 하고 부랴부랴 검색을 해보니 같은 문제로 고통받는 사람들이&lt;br&gt;
있었다.&lt;br&gt;
&lt;a href=&quot;https://github.com/react-native-community/async-storage/issues/219&quot;&gt;Async Storage issue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;해결이 된 건지 안된건지 아리송하다.&lt;/p&gt;
&lt;p&gt;다만 어떤 상황에서는 되고, 어떤 상황에서는 안되는 이런 자잘한 버그가 있다면&lt;br&gt;
실제품에 사용하기에는 불안하다고 생각되어 storage 관련 기능은 다른 방법으로
처리하고 그냥 안쓰기로 했다. (깔끔)&lt;/p&gt;
&lt;p&gt;물론 문제가 없다면 계속 사용하면 된다.&lt;/p&gt;
&lt;p&gt;추가로 이 블로그 글을 쓰고 3일 뒤 해당 async storage 가 필요한 기능이
생겨 다시 사용하게 되었다.
아직까지 문제는 없는 걸 보니 내 코드의 실수였던가…&lt;/p&gt;
&lt;h3&gt;5. Duplicate resources error&lt;/h3&gt;
&lt;p&gt;처음엔 그랬다.&lt;br&gt;
빌드도 잘되고 apk 의 이상유무도 없었다.&lt;br&gt;
하지만 릴리즈 빌드를 위해 app icon image 들을 추가하고&lt;br&gt;
초기화면과 splash screen 에 사용 할 이미지를 추가하고..빌드를 시작했다.  &lt;/p&gt;
&lt;p&gt;그때부터였다. 또다시 말썽이다.&lt;/p&gt;
&lt;p&gt;빌드할때 보니 수많은 에러메시지가 나타났지만 핵심적인 이유는&lt;br&gt;
‘Duplicate resources error’ 이거다.&lt;/p&gt;
&lt;p&gt;andorid 에서 변수명을 처리할때 확장자를 포함하지 않고 파일의 이름으로
지정한다고 한다. 그래서 혹시 하고 찾아보니 같은 이름의 파일이 있었다.&lt;br&gt;
이놈의 이름을 변경 해주면 간단하게 해결 될 줄 알았다.&lt;br&gt;
하지만 그건 RN 을 너무 쉽게 본 나의 오만한 생각이었다.&lt;/p&gt;
&lt;p&gt;해결책을 찾아보자. &lt;/p&gt;
&lt;p&gt;android/app/src/res 에 저장된 모든 리소스 파일을 삭제하고
react-native 로 bundle을 만들어 새롭게 리소스를 android 로 배포 하라고 한다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;해당 명령 실행 후 다시 빌드 했다. 실패.&lt;/p&gt;
&lt;p&gt;android/app/src/main/raw/res 의 모든 파일을 지우면 된다고 한다. 실패.&lt;br&gt;
성공한 사람은 부럽다.&lt;/p&gt;
&lt;p&gt;node_modules/react-native/react.gradle 파일에서
doFirst 함수뒤에 다음 함수를 추가하라고 한다. &lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  doLast {
    def moveFunc = { resSuffix -&amp;gt; File originalDir = file(&amp;quot;$buildDir/generated/res/react/release/${resSuffix}&amp;quot;);
  if (originalDir.exists()) {
    File destDir = file(&amp;quot;$buildDir/../src/main/res/${resSuffix}&amp;quot;);
    ant.move(file: originalDir, tofile: destDir);
  }}
    moveFunc.curry(&amp;quot;drawable-ldpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;drawable-mdpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;drawable-hdpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;drawable-xhdpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;drawable-xxhdpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;drawable-xxxhdpi&amp;quot;).call()
    moveFunc.curry(&amp;quot;raw&amp;quot;).call()
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;신기하게 해당 코드를 추가하니 release build 가 성공하였다.&lt;br&gt;
그런데 node_modules 내부 파일을 조작하라니..이 무슨 말도 안되는 해결법인가&lt;/p&gt;
&lt;p&gt;일단 위 방법은 정 급하면 사용하기로 하고
다른 방법을 찾아보았다.&lt;/p&gt;
&lt;p&gt;drawable/* 폴더와 raw 폴더를 제거한후 react-native bundle 을 거치지 않고
android studio 에서 release apk 를 직접 만들라고 한다.&lt;br&gt;
그 뒤 debug apk 를 빌드할 때는 react-native bundle 을 거쳐서 만들라고 한다.&lt;/p&gt;
&lt;p&gt;결국 android studio 를 거치니 빌드가 진행되었다.&lt;br&gt;
release 빌드는 빈도가 많은 편은 아니지만&lt;br&gt;
빌드할 때 마다 android studio 를 거쳐야 한다면 이는 여간 불편한게 아니다.&lt;/p&gt;
&lt;p&gt;RN 의 최신버전을 설치 하였지만 그래도 바뀌지 않았다.&lt;br&gt;
android studio 에서 된다는 건 resource 에는 문제가 없다는 뜻이 아닌가?&lt;br&gt;
결국 node_modules 내 파일을 수정해야 한다는건 RN 의 빌드 방식에 버그가&lt;br&gt;
존재한다는 뜻 이다.&lt;br&gt;
처음부터 같은 이름의 리소스를 지정하지 않으면 되지만, 한번의 실수로 해결하기 위한&lt;br&gt;
방법이 너무 가혹하지 않은가&lt;/p&gt;
&lt;p&gt;혹시 깔끔한 해결방법을 알고 있다면 꼭 알려주길 바란다.&lt;/p&gt;
&lt;p&gt;아래는 해당 이슈에 대한 링크다.&lt;br&gt;
&lt;a href=&quot;https://github.com/facebook/react-native/issues/26245&quot;&gt;Duplication Resource error&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;6. Deprecated Gradle Error&lt;/h3&gt;
&lt;p&gt;Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.&lt;/p&gt;
&lt;p&gt;emulator 의 target API 를 27 (8.1) 로 변경하여 테스트 중 빌드시 해당 에러가 나타났다.&lt;br&gt;
내가 뭘 잘못했길래 또 괴롭히지 하며 해결 방법을 찾아보았다.&lt;/p&gt;
&lt;p&gt;역시나 같은 문제로 고통받는 동지들이 있었다.&lt;br&gt;
&lt;a href=&quot;https://github.com/software-mansion/react-native-gesture-handler/issues/640&quot;&gt;Deprecated Gradle Error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;차근차근 해결법을 실행해보자.&lt;/p&gt;
&lt;p&gt;jetify 를 실행 하라고 한다.&lt;br&gt;
AndroidX 로 migration 할때 RN의 종속성으로 설치 되어있는 패키지 중&lt;br&gt;
기존 java 코드를 AndroidX 로 변환해줘야 정상적으로 작동한다.&lt;br&gt;
문제는 새로운 패키지를 설치 할때 마다 마이그레이션을 해줘야 되는데
번거롭게 설치때마다 마이그레이션을 해줄 수 없으니 RN 을 실행할때 패키지들의 기존 Java 코드를 AndroidX 로 변환 시켜주는 것이 이놈의 역활이다.&lt;/p&gt;
&lt;p&gt;그렇다면 위 해결법은 migration 이 제대로 되지 않아 발생한 문제인가?&lt;br&gt;
위 해결법으로 고쳤다는 사람도 있지만 나는 실패 하였다.&lt;/p&gt;
&lt;p&gt;그럼 다른 방법으로 ./gradlew clean 을 한 뒤 ./gradlew :app:bundleRelease 를 실행하여
릴리즈 용 번들을 생성하라고 한다. &lt;/p&gt;
&lt;p&gt;그러나 역시 실패.&lt;/p&gt;
&lt;p&gt;다음 방법으로는
node_modules\metro-config\src\defaults\blacklist.js 의 파일을&lt;br&gt;
수정하라고 한다. 또 node-modules 내의 파일을 수정해야 하는가 ? 이 방법은 패스.&lt;/p&gt;
&lt;p&gt;그 외 여러 방법이 있었지만 결국 해결한 방법은&lt;br&gt;
android/.gradle 폴더 삭제&lt;br&gt;
android/app/build 폴더 삭제&lt;/p&gt;
&lt;p&gt;그런 뒤 빌드가 정상적으로 작동하였다.&lt;/p&gt;
&lt;p&gt;사실 이 폴더를 삭제 전에 다른 방법 몇을 실행해서 정확히 폴더를 삭제하는 방법이
올바르게 작동하리라 장담할 수 없다.&lt;/p&gt;
&lt;p&gt;아래 이슈를 보자.&lt;br&gt;
&lt;a href=&quot;https://github.com/software-mansion/react-native-gesture-handler/issues/640&quot;&gt;build gradle error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;같은 이슈인데 해결법은 제각각이다.
정상적으로 보이진 않는다.&lt;/p&gt;
&lt;h3&gt;7. Unable to resolve module `./debugger-ui/ui.cc464243.js&lt;/h3&gt;
&lt;p&gt;이번 에러는 가장 최근에 나타났던 에러로 package 버전을 업데이트 하고 나타났던 걸로 기억한다.
실행시 해당 에러가 나타났고, 앱이 제대로 작동하지 않았다. &lt;/p&gt;
&lt;p&gt;자 또 해결법을 찾아 떠나보자.&lt;/p&gt;
&lt;p&gt;빠르게 이슈를 확인했다.&lt;br&gt;
&lt;a href=&quot;https://github.com/react-native-community/cli/issues/1081&quot;&gt;debugger-ui error&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;package-lock.json 과 yarn-lock 을 삭제하고
패키지를 다시 설치 하라고 한다.
안된다. &lt;/p&gt;
&lt;p&gt;package.json 에 resolutions 으로&lt;br&gt;
@react-native-community/cli-debugger-ui”: “4.7.0”&lt;br&gt;
추가 하라고 한다.&lt;br&gt;
해당 항목은 설정한 패키지를 의존하는 타 패키지에서 설정한 버전으로만 해당 패키지를&lt;br&gt;
사용하도록 하는 것 이다.&lt;/p&gt;
&lt;p&gt;해당 항목을 추가 하니 문제가 해결되었다.
아마 패키지 버전 업그레이드 도중 debugger-ui 의 버전과 충돌이 났던 것 같다.&lt;/p&gt;
&lt;h2&gt;RN 개발 후기&lt;/h2&gt;
&lt;h3&gt;장단점?&lt;/h3&gt;
&lt;p&gt;이 외에도 자잘한 버그가 있었지만 기록을 해두지 않아 적을수가 없다.
개인적인 생각으로는 RN 은 아직 안정화 되지 않은 것 같다. 처음 접한 RN 이라 내가 실수한 부분도 많을 것 이다.
하지만 개발하며 이정도로 스트레스를 받게 될 줄은 몰랐다.&lt;br&gt;
react 자체는 굉장히 좋은 라이브러리 지만 react-native 는 글쎄..&lt;/p&gt;
&lt;p&gt;앱 퍼포먼스 적으로는 나쁘지 않았다.
1gb ram 의 예전 고물 태블릿으로도 괜찮게 돌아가는 걸 보여줬다.
다만 target API 버전을 변경할때 일부 style이 제대로 표현되지 않아
수정이 필요했다. (특히 애니메이션..)  &lt;/p&gt;
&lt;p&gt;하나 아주 마음에 들었던 건 code push 기능&lt;br&gt;
code push 가 위 모든 단점을 날려버리고 RN 개발을 고려할 만큼 좋다.
정말 편하고 좋다.
거기다 무료다. + MS 에서 관리하니 문제 생길 점도 거의 없다.  &lt;/p&gt;
&lt;h3&gt;Ionic ?&lt;/h3&gt;
&lt;p&gt;사실 지금 나온 제품도 조만간 ionic 이나 flutter 로 변경 할 예정이다.&lt;br&gt;
버전 업데이트마다 충돌없기를 문제없기를 기도해야 하다니..&lt;/p&gt;
&lt;p&gt;아마 ionic 을 활용할 확률이 높긴 한데 (정확히는 stencil 로 개발)&lt;br&gt;
stencil 은 순수 웹 컴포넌트를 만들어주는 컴파일러 이다.
웹 표준을 따른 이 웹 컴포넌트는 프레임워크 구분없이 어디든 사용할 수 있으며&lt;br&gt;
ionic 은 이미 모든 컴포넌트들이 stencil 을 활용한 웹 컴포넌트로 빌드 된다.  &lt;/p&gt;
&lt;p&gt;추가로 capcitor 를 활용한 android, ios, pwa, electron 의 동시 배포는&lt;br&gt;
진정한 크로스 플랫폼 하이브리드 울트라 앱 이라고 할 수 있다.&lt;br&gt;
조만간 이 거대한 물결에 대해 별도로 글을 써보려 한다.  &lt;/p&gt;
&lt;h3&gt;Flutter ?&lt;/h3&gt;
&lt;p&gt;flutter 는 그냥 진짜 그냥 좋다.&lt;br&gt;
정말로 개발하기에도 너무 편하고, 빠르고, 깔끔하다.&lt;br&gt;
RN 으로 개발 하다 중간에 Flutter 로 했을때 정말 신세계를 보았다.&lt;br&gt;
Dart 언어는 전혀 까지는 아니지만 크게 문제 되지 않는다.  &lt;/p&gt;
&lt;p&gt;마크업 할때 선언적으로 작성하는 방법도 좋고&lt;br&gt;
자체적으로 stream 을 지원하는 부분도 매우 마음에 든다.&lt;br&gt;
이외에도 개발 할때 debug 모드는 환상적으로 편하고, 보기 좋다.&lt;br&gt;
hot reload 기능은 말 할 것도 없고, Skia 엔진을 이용한 렌더링은
화면을 백색 도화지로 만들고 다시 페인팅 하기 때문에&lt;br&gt;
Android 는 이렇게 넣어주고, iOS 는 요렇게 넣어주고 할 필요가 없다.&lt;br&gt;
둘의 화면은 똑같다. 심지어 버전이 낮아도 어쨌든 완전히 다시 그리기에 똑같다.  &lt;/p&gt;
&lt;p&gt;이 외에도 많은 세일즈 포인트가 있지만, 나머진 다음 번에 정리 해보겠다.  &lt;/p&gt;
&lt;p&gt;flutter 가 code push 를 지원한다면 고민도 없이 flutter 를 사용하겠지만
flutter 구조 상 어려워 보이며 구글에서는 아직까진 계획한 부분이 없는 것 같다.&lt;/p&gt;
&lt;h3&gt;React Native ?&lt;/h3&gt;
&lt;p&gt;fast refresh 도 업데이트 되고 개발하기 더욱 편리해 진 건 사실이다.&lt;br&gt;
다만 개인적으로는 RN 에 좋은 인상을 받지 못 했다.&lt;br&gt;
React 의 성공으로 그냥 같이 찬양받는 정도 ?&lt;br&gt;
친숙한 React 를 쓴다는 것 외에 무엇이 장점인지 아직 모르겠다.  &lt;/p&gt;
&lt;p&gt;이후 ionic 이나 flutter 로 변경한다면
그때는 RN 과 비교 후기를 한번 적어보려 한다.&lt;/p&gt;</content:encoded></item></channel></rss>