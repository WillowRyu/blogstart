{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-05-31/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"4ba8e911-75a1-5c3d-8f2e-1e5275ac5835","excerpt":"예전에 운영하던 블로그에서 react 에서 rxjs 를 이용한 간단한 state managenet 기법을 소개한 적 있다. 그 후 몇년이 지난 지금 조금 더 업데이트 된 좋은 패턴을 소개하려 한다. 참고로 현재 프로젝트에서 사용하는 패턴이다. rxjs…","html":"<p>예전에 운영하던 블로그에서 react 에서 rxjs 를 이용한<br>\n간단한 state managenet 기법을 소개한 적 있다.</p>\n<p>그 후 몇년이 지난 지금 조금 더 업데이트 된 좋은 패턴을<br>\n소개하려 한다. 참고로 현재 프로젝트에서 사용하는 패턴이다.</p>\n<p>rxjs 를 아예 모른다면 이해하기 힘들 수 있으니, 모른다면<br>\n조금은 공부하고 봤음 한다.</p>\n<h2>rxjs 로 react 에서 무엇을 할 수 있을까?</h2>\n<p>이에 대한 답은 거의 모든 것을 할 수 있다.<br>\nstate management 는 물론, dom event, 손위운 web socket 제어,<br>\n동기 또는 비동기 이벤트 작성 등 프로젝트에서 작성하는 모든 이벤트를<br>\nrxjs 를 이용해 쉽게 작성이 가능하다.</p>\n<p>물론 rxjs 가 없어도 가능하겠지만, 중요한 부분은 <strong>쉽게</strong> 라는 점이다.<br>\n이 글에선 이전과 마찬가지로 상태관리로 사용하는 방법에 중점을 둔다.</p>\n<h2>기본적인 state management 는 뭘 사용해야 할까?</h2>\n<p>redux, mobx, recoil, react context 등 기본적으로 많이 사용하는<br>\nstate management 라이브러리 들이 존재하지만, 본인은 현재 진행하는 프로젝트에선<br>\n상태 관리 라이브러리는 아예 찾아보지도 않았다.<br>\n그 많은 보일러플레이트 코드를 사용하기도 싫고, 사용 할 이유도 없었다.</p>\n<p>rest 가 아닌 graphql 을 사용하면, 보통 client 에서 사용하는 라이브러리 에선<br>\nquery 로 받아오는 데이터는 캐싱을 활용하게 된다.<br>\n이로 인해 server 와 연결된 데이터는 별도의 state management 를<br>\n사용 할 이유가 없다.</p>\n<p>남아있는 local storage 데이터들을 제외하고, global ui state 와<br>\n메모리에 남겨야 할 state 들을 어떻게 관리 할 것인가? 간단하게 rxjs 로 해보자.</p>\n<h2>간단한 counter 예제</h2>\n<p>먼저 간단한 counter 예제를 생각해보자.<br>\nincrement, decrement 기능이 있고,<br>\nview 에선 counter state 를 표시한다.</p>\n<p>가장 기본적으로 코드를 보면</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function Counter() {\n  const [count, setCount] = useState(0)\n  const handleCounter = {\n    increment: () =&gt; setCount(count + 1),\n    decrement: () =&gt; setCount(count - 1),\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;button onClick={handleCounter.increment}&gt;++++++&lt;/button&gt;\n      &lt;button onClick={handleCounter.decrement}&gt;------&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 children 을 더 늘려보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">interface CounterButtonProps {\n  onClick: () =&gt; void;\n}\n\nexport function IncrementButton({ onClick }: CounterButtonProps) {\n  return &lt;button onClick={onClick}&gt;++++&lt;/button&gt;\n}\n\nexport function DecrementButton({ onClick }: CounterButtonProps) {\n  return &lt;button onClick={onClick}&gt;++++&lt;/button&gt;\n}\n\nexport function Counter() {\n  const [count, setCount] = useState(0)\n  const handleCounter = {\n    increment: () =&gt; setCount(count + 1),\n    decrement: () =&gt; setCount(count - 1),\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;IncrementButton onClick={handleCounter.increment} /&gt;\n      &lt;DecrementButton onClick={handleCounter.decrement} /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>여기까진 괜찮다.<br>\n다만 이런 상황에서 children 이 더욱 늘어난다면?<br>\n또는 해당 버튼이 하나씩만 존재하는게 아니고, 여러 부분에 있어야 한다면?<br>\n다들 싫어하는 props drilling 현상이 나타나게 된다.</p>\n<p>이를 방지하기 위한 방법은 여러가지가 있다.<br>\n다만 rxjs 는 이를 더 쉽고 우아하게 해결한다.<br>\n(위 코드는 단순히 예제로 만든 것이니, 저기서 굳이 쓸 필요 없다는 말은 하지말자.)</p>\n<h2>event 를 만들자</h2>\n<p>위 예제에서 버튼이 onClick 을 props 받지 않고 실행할 수 있는 방법을 생각해보자.<br>\ncontext ? context 는 말그대로 context 의 사용처를 어디서 사용할지 명확하게<br>\n제한한다는 점에서 굉장히 좋지만 장황하다.<br>\n그리고 만약 처음엔 괜찮지만, 나중에 counter state 를 프로젝트의 여러곳에서 사용한다면?</p>\n<p>redux, recoil ? 등의 global state management 를 사용하는 방법도 있다.<br>\n그걸 사용해도 된다. 다만 이후 설명 할 side effect 를 관리하는 방법에선<br>\n굉장히 불편하다.</p>\n<p>자 이제 rxjs 로 어떻게 해결하는지 살펴보자.</p>\n<h2>counter service 의 작성</h2>\n<p>counter service 를 만들 것 이다.<br>\n해당 서비스는 어디서든 접근 가능하고, 어디서든 조작 가능한 global service 이며,<br>\nstate 가 없고 단순히 버튼의 이벤트를 처리하는 service 다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const counter$ = new Subject&lt;string&gt;();\n\nexport const CounterService = {\n  // observable\n  onCounter$: () =&gt; counter$.asObservable(),\n\n  // set\n  increment: () =&gt; counter$.next(&#39;increment&#39;),\n  decrement: () =&gt; counter$.next(&#39;decrement&#39;),\n};</code>\n        </deckgo-highlight-code>\n<p>counter$ 는 subject 타입으로 우리는 counter$ 를 구독하여,<br>\n이벤트를 수신 받을 것이다.<br>\n(asObservable 은 subject 를 observable 로만 사용하게 된다.<br>\n이는 counter$ 에 접근하여 직접적으로 이벤트를 사용하지 않도록 하기위함이다.)</p>\n<p>위 서비스를 적용해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function IncrementButton() {\n  return &lt;button onClick={CounterService.increment}&gt;++++&lt;/button&gt;\n}\n\nexport function DecrementButton() {\n  return &lt;button onClick={CounterService.decrement}&gt;++++&lt;/button&gt;\n}\n\nexport function Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() =&gt; {\n    const counter$ = CounterService.onCounter$().subscribe(event =&gt; {\n      if (event === &quot;increment&quot;) setCount(prev =&gt; prev + 1)\n      if (event === &quot;decrement&quot;) setCount(prev =&gt; prev - 1)\n    })\n\n    return () =&gt; counter$.unsubscribe()\n  }, [])\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;IncrementButton /&gt;\n      &lt;DecrementButton /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>useEffect 에서 우리는 이전에 만든 counterService 의 counter$ 를 구독하게 된다.<br>\n버튼을 누르게 되면 increment 또는 decrement 이벤트를 counter$ 로 보내게 되고<br>\ncounter$ 를 구독 하고 있는 counter 컴포넌트는 해당 이벤트를 받아<br>\ncounter state 를 변경 하게 된다.</p>\n<p>이제 IncrementButton 과 DecrementButton 은 어디에서 사용해도 되는 독립적인<br>\n컴포넌트가 되었다.</p>\n<h2>Event 는 해결 되었다. 그럼 state 는?</h2>\n<p>button 의 독립은 이루어졌지만, state 의 독립은 아직이다.<br>\ncounter 를 한 곳이 아닌 여러곳에서 사용한다면?<br>\ncounter state 를 공통으로 사용하도록 해야 한다.<br>\n이를 위해서 counter service 를 변경해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const counter$ = new BehaviorSubject() &lt; number &gt; 0\n\nexport const CounterService = {\n  // observable\n  onCounter$: () =&gt; counter$.asObservable(),\n\n  // set\n  increment: () =&gt; counter$.next(counter$.value + 1),\n  decrement: () =&gt; counter$.next(counter$.value - 1),\n}</code>\n        </deckgo-highlight-code>\n<p>subject 를 BehaviorSubject 로 변경 하였다.<br>\nbehavior subject 는 subject 와 다르게 값을 저장하는 기능을 가지고 있다.<br>\nBehaviorSubject<number>(0); 여기서 0은 해당 state 의 초기 값이다.</p>\n<p>counter$ 에 새로운 구독이 일어나면 마지막으로 저장된 값을 방출한다.</p>\n<p>이제 counter$ 는 본인의 value를 가지고 있는\n하나의 global state 가 되었다.</p>\n<p>(이렇게 하나의 stream 에서 구독자에게 동일한 값을 방출 하는 것을 hot observable 이라고 한다.)</p>\n<p>(반대로 cold observable 은 각 구독자에게 별도의 stream 을 할당한다.<br>\ncustom hook 과 같이 별도의 state 가 존재하는 것이다.)</p>\n<p>이를 실제로 적용해 본다면</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function Counter() {\n  const [count, setCount] = useState(0)\n  useEffect(() =&gt; {\n    const counter$ = CounterService.onCounter$().subscribe(setCount)\n\n    return () =&gt; counter$.unsubscribe()\n  }, [])\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;IncrementButton /&gt;\n      &lt;DecrementButton /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>버튼들은 변경 할 필요가 없다.<br>\n이미 버튼은 단순히 클릭으로 인한 이벤트를 보낼 뿐, 그 뒤에 어떤일이 일어날지는<br>\n알지 못하는 멍청한 컴포넌트가 되었다.</p>\n<p>counter$ 구독으로 얻는 값을 setCount 에 바로 적용하여,<br>\n새롭게 렌더링을 하게 되었다.</p>\n<p>이제 원하는 곳에서 onCounter$ 를 구독하여 사용하면 global state 의<br>\n역할을 하게 된다.</p>\n<p>그러나, 아직 옵션이 남아있다.</p>\n<h2>Custom hook 과 결합하자.</h2>\n<p>위 예제에서 거슬리는 부분이 2가지가 있다.<br>\nuseEffect 와 useState 다.<br>\ncounter 를 쓰는 모든곳에 해당 로직을 넣어주기에는 귀찮은 일이다.</p>\n<p>우리가 counter 를 globalState 로 사용하려고 마음 먹은 이상<br>\ncounter 를 customHook 으로 만들어 재사용해야 한다.</p>\n<p>그럼 만들어보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export const useCountState = () =&gt; {\n  const [count, setCount] = useState &lt; number &gt; 0\n  useEffect(() =&gt; {\n    const counter$ = CounterService.onCounter$().subscribe(setCount)\n\n    return () =&gt; counter$.unsubscribe()\n  }, [])\n\n  return {\n    count,\n  }\n}\n\nexport function Counter() {\n  const { count } = useCountState()\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;IncrementButton /&gt;\n      &lt;DecrementButton /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>오 아주 깔끔해 진것 같다.<br>\n이제 count state 를 사용하고 싶은 곳에선 어디서든<br>\nuseCountState 를 사용하면 된다.</p>\n<p>하지만 난 아직도 거슬린다.<br>\ncustomHook 을 사용한 건 좋지만, 이왕 rxjs 를 사용한다면<br>\n좀더 편한 customHook 이 있으면 좋겠다.</p>\n<p>저기서 countState 를 customHook 으로 만들지 말고,<br>\nstream 으로 받는 데이터를 그대로 state 로 쓸 수 있는<br>\nhook 을 만들면 좋지 않을까?</p>\n<p>그래서 만들었다.</p>\n<h2>useObservableState Hook</h2>\n<p>useEffect 에 observable 과 관련된 로직을 넣게 되면,<br>\n해당 컴포넌트가 리렌더링 될때, unsubscribe 와 subscribe 가 반복된다.<br>\n그리고 지금은 괜찮지만, 만약 useEffect 로직이 길어지게 된다면?</p>\n<p>그걸 방지 하기 위해 prop 으로 stream 을 받고 해당 stream 의 값을<br>\nstate 로 만들어주는 간단한 hook 을 만들어 보았다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { useEffect, useState } from &quot;react&quot;\nimport { Observable, Subscription } from &quot;rxjs&quot;\n\ninterface ObservableState {\n  &lt;T, K = T&gt;(\n    props: ObservableStateProps&lt;T, K&gt; &amp; { initialState?: undefined }\n  ): T | K | undefined;\n  &lt;T, K = T&gt;(props: ObservableStateProps&lt;T, K&gt;): T | K;\n}\n\ninterface ObservableStateProps&lt;T, K&gt; {\n  obs$: Observable&lt;T&gt;;\n  input$?: (input$: Observable&lt;T&gt;) =&gt; Observable&lt;K&gt;;\n  initialState?: T | (() =&gt; T);\n}\n\nexport const useObservableState: ObservableState = &lt;T, K&gt;({\n  obs$,\n  input$,\n  initialState,\n}: ObservableStateProps&lt;T, K&gt;) =&gt; {\n  const [state, setState] =\n    (useState &lt; T) |\n    K |\n    (undefined &gt;\n      (initialState instanceof Function ? initialState() : initialState))\n\n  useEffect(() =&gt; {\n    let observableState$: Subscription\n    if (input$) {\n      observableState$ = obs$.pipe(input$).subscribe(setState)\n    } else {\n      observableState$ = obs$.subscribe(setState)\n    }\n    return () =&gt; observableState$ &amp;&amp; observableState$.unsubscribe()\n  }, [obs$, input$])\n\n  return state\n}</code>\n        </deckgo-highlight-code>\n<p>실제로 프로젝트에서 사용하는 hook 이다.<br>\nobservable 과 pipe, iniitalState 를 받고, 해당 observable 로<br>\n받은 데이터를 state 로 return 하며, 자동으로 unsubscribe 까지 해준다.</p>\n<p>사실상 react 에서 rxjs 를 더욱 간편하게 사용하기 위해서<br>\nsubscribe 와 unsubscribe, 그리고 렌더링을 위한 state 작업을 모아둔<br>\ncustom hook 이다.</p>\n<p>해당 hook 을 사용하여 다시 정리해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function Counter() {\n  const count = useObservableState({\n    obs$: CounterService.onCounter$(),\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;IncrementButton /&gt;\n      &lt;DecrementButton /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>어마어마 하지 않은가?<br>\n이제 global service 로 만드는 모든 state 는 useObservableState 로<br>\n가져와서 간단하게 사용이 가능하다.</p>\n<p>거기다 해당 service 에는 어떠한 이벤트도 추가 가능하다.<br>\n예를 들어 일반적인 count 뿐만 아니라, count 에서 * 2가 된 값도<br>\n같이 보고 싶다면 input$ 에 pipe 를 추가해도 되고,<br>\nservice 에 추가해도 된다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">type inputType = { count: number, multi: number }\n\nexport const CounterService = {\n  // observable\n  onCounter$: () =&gt; counter$.asObservable(),\n  onCounterWithMulti: () =&gt;\n    counter$.pipe(map(count =&gt; ({ count, multi: count * 2 }))),\n\n  // set\n  increment: () =&gt; counter$.next(counter$.value + 1),\n  decrement: () =&gt; counter$.next(counter$.value - 1),\n}\n\nexport function Counter() {\n  const count =\n    useObservableState &lt;\n    inputType &gt;\n    {\n      obs$: CounterService.onCounterWithMulti$(),\n    }\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count?.count}&lt;/span&gt;\n      &lt;span&gt;{count?.multi}&lt;/span&gt;\n      &lt;IncrementButton /&gt;\n      &lt;DecrementButton /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>이제 하나의 state 로 count * 2 한 값을 같이 볼 수 있다.<br>\n이는 count state 가 변경 될때 마다 계속 유지되며,<br>\n원본 state 는 변경하지 않고 손쉽게 값을 변경하고 표현 가능하다.</p>\n<p>이런 패턴의 장점은 해당 로직을 어디서든 사용이 가능하다는 것이다.<br>\n심지어 service 는 react 가 아닌 다른 프레임워크, 라이브러리 에서도<br>\n재사용 가능하다. (rxjs 만 있다면.)</p>\n<h3>결론</h3>\n<p>간단하게 정말, 아주 간단하게 rxjs 를 react 에서 사용하는 패턴을 보았다.<br>\n위에 적힌 예는 정말 빙산의 일각이며 실제로 더욱 많은 기능을 손 쉽게<br>\n작성이 가능하다.<br>\n특히 dom event 를 다룰때 rxjs 를 사용한다면 다신 기본 event 를<br>\n사용하기 싫을 것이다.</p>\n<p><strong>ReactiveX</strong> 는 새로운 것도 아니고, 비인기 개념도 아니다.</p>\n<p>ReactiveX: <a href=\"https://reactivex.io/languages.html\" target=\"_blank\">https://reactivex.io/languages.html</a></p>\n<p>홈페이지를 보면 알겠지만, 수많은 주류 언어에서 사용되고 있으며<br>\nobservable stream 을 이해하기 시작하면, 어떠한 언어에서도 활용이<br>\n가능하고, reactive programming (feat. functional programming)<br>\n를 이해하는데 많은 도움이 될 것이다.</p>\n<p>사실 더욱 많은 응용 예제를 올리고 싶지만<br>\n글이 너무 길어지기 때문에 시간이 된다면 나중에 더 올리겠다.<br>\n새로운 응용과 패턴의 사용은 이 글을 보는 사람들이 충분히 재밌고 쉽게<br>\n사용할 수 있으리라 믿는다.</p>\n<p>—</p>","frontmatter":{"title":"Rxjs in React","date":"May 31, 2022","description":"왜 사용하지 않는가"}}},"pageContext":{"slug":"/2022-05-31/","previous":{"fields":{"slug":"/2022-05-24/"},"frontmatter":{"title":"SPA 는 죽어가는가"}},"next":{"fields":{"slug":"/2022-11-28/"},"frontmatter":{"title":"MFE 로 프로젝트를 전환"}}}},"staticQueryHashes":["2841359383","3490846071"]}