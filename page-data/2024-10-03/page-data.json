{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-10-03/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"147299e2-e4b1-593b-9748-04e3faef070a","excerpt":"최근에 를 공부하면서 GC 와 managend, unmanaged 에 대해 조금 찾아봤다. 이 두 분류를 구분할때 GC (garbage collector) 의 유무에 따라 managed 와 unmanaged…","html":"<p>최근에 <code class=\"language-text\">Rust</code>를 공부하면서 GC 와 managend, unmanaged 에 대해 조금 찾아봤다.</p>\n<p>이 두 분류를 구분할때 GC (garbage collector) 의 유무에 따라 managed 와 unmanaged 를 구분하기도 하고, 해당 언어가 네이티브로 컴파일 되는지, 바이트코드로 컴파일 되는지에 대해서도 분류 하기도 한다.</p>\n<p>이렇게 분류하면 <code class=\"language-text\">Java</code>, <code class=\"language-text\">C#</code>, <code class=\"language-text\">Python</code>, <code class=\"language-text\">Js</code> 등은 managed 가 되고, <code class=\"language-text\">C</code>, <code class=\"language-text\">C++</code> 같이 개발자에게<br>\n메모리에 대한 모든 제어권을 주는 언어는 unmanaged 라고 볼수 있다.</p>\n<p>어 <code class=\"language-text\">Go</code> 같은 경우에는 GC 가 있던데요? 하지만 네이티브로 컴파일도 된다.<br>\n<code class=\"language-text\">Go</code> 는 그럼 managed 인가?</p>\n<p>개인적으로 managed 와 unmanaged 의 개념을 GC 의 존재 유무로 구분하기로 생각중이라<br>\n(<code class=\"language-text\">Java</code> 나 <code class=\"language-text\">C#</code> 도 네이티브 코드로 컴파일 할 수 있다.)<br>\n<code class=\"language-text\">GO</code> 도 managed 라고 생각하고 싶다.</p>\n<p>그럼 <code class=\"language-text\">Rust</code>는 어떨까<br>\n<code class=\"language-text\">Rust</code> 는 <code class=\"language-text\">Ownership</code> 이라는 독특한 방법을 통해 메모리를 관리한다.</p>\n<p>이게 참 신기한게 개발자가 직접 명시적으로 메모리를 할당하고 해제하는 것 보다<br>\n<code class=\"language-text\">Rust</code>가 나에게 자동으로 메모리를 관리할 수 있도록 유도한다고 할까?</p>\n<p>실제로 <code class=\"language-text\">Rust</code> 에서 메모리 할당을 해제하는 <code class=\"language-text\">drop</code> 도 존재하지만<br>\n거의 쓰이질 않는다. (아마도?)</p>\n<p>그럼 unmanaged 로 분류할 수 있나? 그런 것 같다.<br>\n이 <code class=\"language-text\">Ownership</code> 의 규칙을 따라 개발하다보면 자연적으로 메모리 관리를 생각하며<br>\n개발하게 된다.</p>\n<blockquote>\n<p><code class=\"language-text\">Rust</code> 컴파일러가 정말 끝내주기는 한다.</p>\n</blockquote>\n<p>GC 를 탑재한다는 것은 성능과 생산성의 트레이드오프가 있지만, (Go?)<br>\n최근에는 뭐 하드웨어 사양들이 워낙 좋아서<br>\n게임이나 임베디드 같이 하드웨어 성능을 극한으로 최적화 시켜야 하는 경우가 아니라면<br>\n꼭 unmanaged 를 사용해야 할 이유가 많이 줄었다고 생각한다.</p>\n<p>그럼에도 <code class=\"language-text\">unmanaged language</code> 는 공돌이라면 꼭 공부해야 하는 분야라고 생각한다.<br>\n우리 친구 전자계산기의 OS 나 하드웨어의 동작방식에 더 깊은 이해를 가져다 주고,<br>\n개발할때 생각하는 방향이 달라진다.<br>\n개인적으로 <code class=\"language-text\">Rust</code>에서 가져오고 싶은 개념들이 많다.</p>\n<p>추천하는 언어는 <code class=\"language-text\">Rust</code>이긴 하지만, unmanaged 를 처음 접한다면 러닝커브가 조금 클 것이다.</p>\n<p>추가로 예전에 글에서 적었지만 현재 <code class=\"language-text\">Js</code> 의 전성기가 다시 오고 있는 시점에서<br>\n그 뒤에는 <code class=\"language-text\">Rust</code>가 큰 역할을 하고 있다.<br>\n흥미가 가는 부분이다.</p>\n<p>코드 하나 없는 재미없는 일기는 여기까지 적고<br>\n다음 글은 <code class=\"language-text\">Rust</code> 로 만든 서버와 웹서비스 예제를 가지고 살펴 보자.아마도.</p>","frontmatter":{"title":"Unmanaged Language","date":"October 03, 2024","description":"feat: Rust"}}},"pageContext":{"slug":"/2024-10-03/","previous":{"fields":{"slug":"/2024-08-18/"},"frontmatter":{"title":"Upgrade Project"}},"next":{"fields":{"slug":"/2024-12-01/"},"frontmatter":{"title":"SPA 에서 사용하는 Hot Remote Module Replacement 실험"}}}},"staticQueryHashes":["2841359383","3490846071"]}