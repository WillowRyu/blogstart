{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021-04-22/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"44f2df6f-c10a-59f5-9e5d-0971d678729f","excerpt":"오늘은 google 2014 Google Chrome Dev Summit 에서 소개된 FLIP 방식으로 Animation 을 처리하는 기법을 살펴보자. FLIP 방식은 Animation…","html":"<p>오늘은 google 2014 Google Chrome Dev Summit 에서 소개된 FLIP 방식으로<br>\nAnimation 을 처리하는 기법을 살펴보자.</p>\n<p>FLIP 방식은 Animation 처리 시 미리 최종값을 계산 하여\n애니메이션 진행 중 무거운 계산을 하지 않도록 만들어, 빠르게 처리 하는 방식이며 element 의 크기, 위치, 불투명도 (즉 scale, transform, opacity) 를 이용한 애니메이션에서<br>\n더욱 훌륭한 성능을 가져다준다.</p>\n<p>글로만 보면 이해가 되지 않을 수 있다.<br>\n실제로 어떤식으로 처리하는지 보자.</p>\n<h3>FLIP 의 정의</h3>\n<p>FLIP 일련의 방식의 줄임말이다.</p>\n<p>F: first<br>\nL: last<br>\nI: Invert<br>\nP: Play</p>\n<p>대상이 되는 element 의 초기 값을 계산하고,<br>\n해당 element 의 최종 지점의 값을 계산한다.</p>\n<p>그리고 현재 invert 를 적용하여 현재 element 의 위치로\ninvert 값을 부여한 뒤,<br>\n최종 지점의 값으로 되돌린다.</p>\n<h3>Code</h3>\n<p>간단하게 코드로 살펴보자.</p>\n<deckgo-highlight-code language=\"html\"  >\n          <code slot=\"code\">&lt;div class=&quot;content-wrap&quot;&gt;\n  &lt;div class=&quot;example-card&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p>위와 같은 구조의 html 이 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 179.05405405405406%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAkCAIAAAAGkY33AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAbklEQVRIx+3SwQqAIAyA4d7/UYr0hWLlvQg6VMxtZZcgMS8hdNj43ckPPFgdH6ZSrFhxYSyEvM/JRCiDJRxaHELje/vMhM3bdF97wwN2tQfjoY3ibSyLHXYNgkUwUflnX8OEfp2TCZP+MMWK/4xPy/9WKkP9alcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"sc1\"\n        title=\"sc1\"\n        src=\"/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png\"\n        srcset=\"/static/d38bf457dea426e48130e57dc0e670e1/12f09/2021-04-22-1.png 148w,\n/static/d38bf457dea426e48130e57dc0e670e1/e4a3f/2021-04-22-1.png 295w,\n/static/d38bf457dea426e48130e57dc0e670e1/10600/2021-04-22-1.png 362w\"\n        sizes=\"(max-width: 362px) 100vw, 362px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>위 그림 같이 생긴 간단한 구조다.<br>\n여기서 중앙에 있는 card 를 확장 시키는 애니메이션을 만들고자 한다.</p>\n<p><img src=\"/e01024a57f49bc258b05d025642ce982/2021-04-22-2.gif\" alt=\"sc2\"></p>\n<p>요런식으로 말이다.</p>\n<p>그럼 FLIP 방식을 사용해서 만들어보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">.full-card {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  border-radius: 0;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const card = document.querySelector(&quot;.example-card&quot;)\n\n// F: 초기 위치 값을 계산한다.\nconst first = card.getBoundingClientRect()\n\n// 대상 element 의 최종 상태로 적용시킨다.\ncard.classList.add(&quot;full-card&quot;)\n\n// L: 마지막 위치 값을 계산한다.\nconst last = card.getBoundingClientRect()\n\n// I: Invert 즉 초기 값에서 마지막 값을 뺀다.\nconst invert = {\n  scaleX: first.width / last.width,\n  scaleY: first.height / last.height,\n}</code>\n        </deckgo-highlight-code>\n<p>코드를 간단히 정리하자면<br>\n먼저 현재 card element 의 초기 위치 값을 가져온다.<br>\n그리고 그 즉시 card element 를 우리가 원하는 최종 상태로 변환 시킨다.</p>\n<p>이제 element 는 현재 화면에 꽉 차있는 위치가 되었다.<br>\n여기서 현재 element 의 값을 가져온다.</p>\n<p>이제 invert 값을 계산해보자.<br>\n현재 애니메이션에서 우리가 원하는 건 크기의 변경이다.</p>\n<p>dom 트리의 리플로우가 발생하지 않도록<br>\n컴포지터 스레드를 활용한 애니메이션을 사용한다면<br>\n여기선 크기와 관련된 scale 이 될 것 이다.</p>\n<p>scale 값 계산을 위해서 초기 값에서 마지막 값을 나눠준다.<br>\n이제 이 값을 가지고 animation 을 실행 해보자.</p>\n<h3>Animation Play</h3>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const animation = card.animate(\n  [\n    {\n      transform: `scale(${invert.scaleX}, ${invert.scaleY})`,\n    },\n    {\n      transform: &quot;scale(1, 1)&quot;,\n    },\n  ],\n  {\n    duration: 300,\n    easing: &quot;ease-in-out&quot;,\n  }\n)</code>\n        </deckgo-highlight-code>\n<p>animate 함수를 보면 초기값이 계산된 invert 값이고,<br>\n최종값은 우리가 원하는 기본상태이다.</p>\n<p>이제 실행해보면 우리가 원하는 Animation 이 매끄럽게 작동한다.</p>\n<h3>Why FLIP</h3>\n<p>그럼 왜 FLIP 방식을 사용하는가?<br>\n일반적으로 브라우저의 레이아웃을 변경하는 트리거가 발생되었을때 (크기, 위치)등<br>\n브라우저는 주위 다른요소의 레이아웃이 변경되었는지 재귀적으로 계속 계산하게 된다.</p>\n<p>이때 그 계산 이 16.7ms 보다 오래 걸린다면 해당 프레임을 건너뛰기 때문에<br>\n우리가 일반적으로 보는 끊김 현상이 나타난다.</p>\n<p>이런 현상을 없애기 위해 FLIP 에서는 애니메이션이 실행되기전 미리 최종 위치를 계산하고 애니메이션만 실행하게 된다.<br>\n이는 애니메이션 실행 도중 진행되는 브라우저의 부담을 확실히 줄이는 일이 된다.</p>\n<p>F 단계에서 초기 값을 얻고, 즉시 최종위치로 전환할때 브라우저는 해당 element의 최종위치 와 전체 레이아웃 값을 다 계산이 완료 된 상태다.</p>\n<p>여기서 우리는 이제 composite 단계에서만 애니메이션을 실행시켜<br>\n사용자에게 보여주면 된다.</p>\n<h3>주의점?</h3>\n<p>위에서 서술 했듯이 브라우저가 최종값을 계산하는 그 시간이 100ms 를 넘기면 안된다.</p>\n<p>RAIL 가이드에 따르면 사용자가 서비스와 상호작용 할때<br>\n반응이 일어나기까지 100ms 의 시간이 주어진다.</p>\n<p>이 시간을 이용하여 FLIP 은 최종 계산을 마치고 애니메이션을 실행하게 되는데<br>\n반대로 초기 계산이 100ms 를 넘어가면 이는 끔찍한 애니메이션 경험이<br>\n될 것이다.</p>\n<p>상식적으로 아직 계산이 되지도 얺은 값을 가지고 애니메이션을 진행할 수는 없지 않은가?</p>\n<p>그리고 해당 FLIP 을 진행 할때 오로지 composite 레이어 에서 작동하는 속성으로 진행 해야 한다.<br>\ntranslate, opacity, scale, rotate 등이 그 예가 될 것이다.</p>\n<p>composite 레이어에서 작동하는 다른 속성을 찾고 싶다면<br>\n<a href=\"https://csstriggers.com/\" target=\"_blank\">https://csstriggers.com/</a> 여기서 검색해보면 된다.</p>\n<p>그외 주의점 과 자세한 설명은<br>\nDev summit: <a href=\"https://youtu.be/RCFQu0hK6bU\" target=\"_blank\">Youtube</a><br>\n해당 영상을 참고하자.</p>","frontmatter":{"title":"FLIP 방식의 Animation 처리","date":"April 22, 2021","description":"Animation 처리 시 60fps 효율적으로 유지"}}},"pageContext":{"slug":"/2021-04-22/","previous":{"fields":{"slug":"/2021-02-21/"},"frontmatter":{"title":"react lazyload => preload"}},"next":{"fields":{"slug":"/2021-05-21/"},"frontmatter":{"title":"함수의 색상"}}}},"staticQueryHashes":["2841359383","3490846071"]}