{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-11-25/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"5f7593d9-8fc4-579a-9c34-2435d697ee45","excerpt":"오늘은 MFA(feat.Module Federation)에서 tailwindcss…","html":"<p>오늘은 MFA(feat.Module Federation)에서<br>\ntailwindcss 를 좀더 자연스럽게 사용하는 팁을 적어본다.</p>\n<p>하나의 프로젝트를 여러 모듈로 나뉘어 개발할때 중요한 부분 중 하나는<br>\n각 모듈이 하나의 기능을 가지고 독립적으로 실행 가능하도록 개발하는 것이 좋다.</p>\n<p>module federation 역시 양방향으로 사용가능하기 때문에<br>\nremote 로 내보내는 모듈들 역시 host 가 되었든 host 에서 사용하게 되든<br>\n독립적인 실행이 가능해야 한다.</p>\n<p>비즈니스 로직이나 상태 관리는 js 로 컨트롤이 가능하기 때문에<br>\n각 모듈별 요구사항을 충족하게 만드는데 어렵지는 않다.</p>\n<p>다만 style 은 조금 다르다.</p>\n<p>웹을 기준으로 보면 remote 모듈은 결국 하나의 browser 에서 실행되는데<br>\n우리의 browser 에서 style 을 처리할때는<br>\ncss 라는 이름처럼 cascading 하게 처리하게 되는데 여기서 같은 Specificity 를<br>\n가지게 되면 나중에 들어오는 style 이 앞의 style 을 덮어 쓰게 된다.</p>\n<p>이런 css의 알고리즘은 일반적으로는 문제가 되지 않지만 tailwind 에서는<br>\n약간의 문제가 생긴다.</p>\n<h2>Tailwind 의 Specificity</h2>\n<p>예를 들어</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function CustomInput(props) {\n  const className = `border rounded px-2 py-1 ${props.className || &quot;&quot;}`\n  return &lt;input {...props} className={className} /&gt;\n}\n\nfunction MyInput(props) {\n  return &lt;CustomInput {...props} className=&quot;p-3&quot; /&gt;\n}</code>\n        </deckgo-highlight-code>\n<p>위 예에서 MyInput 의 classname 은 <code class=\"language-text\">border rounded px-2 py-1 p-3</code> 이 생성된다.<br>\n하지만 <code class=\"language-text\">px-2</code> 와 <code class=\"language-text\">py-1</code> 그리고 <code class=\"language-text\">p-3</code> 은 같은 특이성을 가진다.</p>\n<p>그리고 tailwind 에서 classname 을 생성할때 css 의 순서는 아래 순서대로 생성된다.</p>\n<blockquote>\n<p>className 에 적힌 class 의 순서는 아무의미 없다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">.p-3 {\n  padding: 0.75rem/* 12px */;\n}\n\n.px-2 {\n  padding-left: 0.5rem/* 8px */;\n  padding-right: 0.5rem/* 8px */;\n}\n\n.py-1 {\n  padding-top: 0.25rem/* 4px */;\n  padding-bottom: 0.25rem/* 4px */;\n}</code>\n        </deckgo-highlight-code>\n<p>결국 <code class=\"language-text\">px-2</code> 와 <code class=\"language-text\">py-1</code> 이 적용되고 <code class=\"language-text\">p-3</code> 은 무시 되는 효과가 나타난다.<br>\n이문제는 MFA 가 아닌 일반적인 프로젝트에서도 볼 수 있는 문제 중 하나이다.<br>\n이 문제를 해결하기 위한 라이브러리가 존재한다.</p>\n<p><a href=\"https://github.com/dcastil/tailwind-merge\" target=\"_blank\">Tailwind-merge</a>\n라는 라이브러리를 사용하면 깔끔하게 충돌되는 className 을 제거해주고, 위 문제를 해결할 수 있다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function CustomInput(props) {\n  const className = twMerge(&quot;border rounded px-2 py-1&quot;, props.className)\n  return &lt;input {...props} className={className} /&gt;\n}\n// -&gt; className =&gt; border rounded p3</code>\n        </deckgo-highlight-code>\n<p>자세한 사용법은 해당 github 을 참조하자.\n그럼 이제 2번째 문제로 가보자.</p>\n<h2>Utility className 의 독립성</h2>\n<p>Tailwind 의 장점 중 하나는 className 에 유틸리티 클래스를 사용하여 style 을<br>\n빠르게 작성하고, 공유할 수 있다는 점이 존재한다.</p>\n<p>Tailwind 의 트리쉐이킹인 purge 동작은 해당 모듈에서 사용하지 않는 css 를 제거해주는<br>\n아주 좋은 최적화 기능이다.<br>\n하지만 이 부분이 결국 MFA 를 만들때 걸림돌이 된다.</p>\n<p>예를 들어 <code class=\"language-text\">Host</code>, <code class=\"language-text\">Module A</code>, <code class=\"language-text\">Module B</code> 3개의 모듈이 존재한다고 할때,<br>\n우리가 원하는건 각 모듈이 독립적인 style 을 가져가고, 어떤 모듈에서 remote 로 호출되어도<br>\nstyle 을 유지하기를 바랄 것이다.</p>\n<p>만약 remote 에서 tailwind 가 없다면? remote 를 부르는 host 에서 해당 remote 모듈의<br>\nstyle 을 가지고 있지 않는 한 remote 모듈의 style 을 정상적으로 적용되지 않는다.</p>\n<p>예를 들어,</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// Remote A\nconst RemoteA = () =&gt; {\n  ;&lt;div className=&quot;grid grid-cols-1&quot;&gt;RemoteA&lt;/div&gt;\n}\n\n// Remote B\nconst RemoteB = () =&gt; {\n  ;&lt;div className=&quot;grid grid-cols-2&quot;&gt;RemoteB&lt;/div&gt;\n}\n\n// Host\nimport &quot;./styles.tw.css&quot; // tailwindcss\nconst HostComponent = () =&gt; {\n  return (\n    &lt;&gt;\n      &lt;div className=&quot;flex items-center&quot;&gt;\n        // Remote A 와 Remote B 를 가져온다.\n        &lt;RenderRemoteA /&gt;\n        &lt;RenderRemoteB /&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 <code class=\"language-text\">RemoteA</code> 와 <code class=\"language-text\">RemoteB</code> 는 생성된 css style 없이 Host 로 가게 된다.<br>\n하지만 Host 가 가지고 있는 class 는 tailwind 의 최적화로 인해 <code class=\"language-text\">flex items-center</code><br>\n두개의 css style 만 가지고 있으므로 remote 들은 style 이 적용되지 않는다.</p>\n<p>결국 Remote 들이 각자의 style 을 가지고 있기 위해서는 Host 처럼 각각\n<code class=\"language-text\">import './styles.tw.css'</code> 이런식으로 tailwind 를 가지고 있어야 한다.</p>\n<p>그럼 문제가 해결되었나? 해결 된듯 해 보이지만 아직도 문제가 존재한다.<br>\n일반적인 classname 은 중복이 되어도 다른 모듈의 css 항목이 가지고 있기 때문에,<br>\n문제가 되지 않지만 <code class=\"language-text\">@media</code> 와 같은 항목을 사용할때는 문제가 생긴다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">/* ModuleA CSS */\n@media (min-width: 640px) {\n  .sm\\:hidden {\n    display: none;\n  }\n}\n@media (min-width: 768px) {\n  .md\\:block {\n    display: block;\n  }\n}\n\n\n/* ModuleB CSS */\n@media (min-width: 640px) {\n  .sm\\:hidden {\n    display: none;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이런식으로 Module A, B 가 각각 <code class=\"language-text\">@media</code> 항목을 사용할때, 둘의 특이성은<br>\n동일하기 때문에 뒤늦게 로드되는 style 이 먼저 로드된 style 을 덮어 버리게 된다.<br>\n위 media 쿼리의 정렬 문제는 <code class=\"language-text\">postcss-sort-media-queries</code> 로 해결할 수는 있다.</p>\n<p>그럼 이제 모두 해결된건가? 해치웠나?<br>\n아직 문제가 남아있다.</p>\n<h2>Utility className 의 중복</h2>\n<p>remote 모듈이 몇개 없을때는 문제가 되지 않지만, remote 모듈이 많아지면<br>\n각 remote 모듈마다 동일한 classname 을 가진 stylesheet 가 생성되기 때문에<br>\n같은 classname 의 중복이 무자비하게 생성된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/370739be96250bf75f459eb88f3c9d1a/248b0/231126-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAeUlEQVQI14XOSw6DMAwE0FymQY2UJv7kg2jZtIKk9z9QB9YURvZunmyz9m+sE2tKSb331t6Gwd7/JISQ9vAe03ov03N+f8bXHCMRM9Y5d4gBaq2lFHgRMcvaHqIYTxKhTzEuw/DWIZTN0jqVkVhV5PJtAJzNOetWlx97AiyfKyGLXwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"classname\"\n        title=\"classname\"\n        src=\"/static/370739be96250bf75f459eb88f3c9d1a/fcda8/231126-1.png\"\n        srcset=\"/static/370739be96250bf75f459eb88f3c9d1a/12f09/231126-1.png 148w,\n/static/370739be96250bf75f459eb88f3c9d1a/e4a3f/231126-1.png 295w,\n/static/370739be96250bf75f459eb88f3c9d1a/fcda8/231126-1.png 590w,\n/static/370739be96250bf75f459eb88f3c9d1a/efc66/231126-1.png 885w,\n/static/370739be96250bf75f459eb88f3c9d1a/c83ae/231126-1.png 1180w,\n/static/370739be96250bf75f459eb88f3c9d1a/248b0/231126-1.png 1316w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>이런식으로 쌓이게 된다.</p>\n<p>classname 이 계속 쌓이게 되면 이는 결국 성능저하를 가지고 오게 되며<br>\n해당 Element 의 style 을 디버깅 할때 걸림돌이 될 수 있다.</p>\n<p>이를 해결하기 위해서 몇가지 방법이 존재한다.</p>\n<h2>해결법</h2>\n<ol>\n<li>첫번째는 <code class=\"language-text\">Tailwind 를 Host 나 Root 에서 한번 포함한다.</code></li>\n</ol>\n<p>remote 모듈에서 각각 tailwind 를 불러오지 않고, root 에서 한번만 불러오거나,<br>\n해당 remote 를 사용하는 Host 에서만 생성하면 이런 중복을 줄일 수 있을 것이다.</p>\n<p>만약 root 에서 한번 불러온다면, 해당 Root 에는 모든 tailwind class 가 포함되어야<br>\n하며, 이는 tailwind 의 최적화 기능을 사용할 수 없기 때문에 좋은 방법이 아니다.</p>\n<p>그럼 특정 Host 에서 불러온다면?<br>\nstyle sheet 는 빌드 타임에 생성된다. 그런데 Host 에서는 자신이 불러오는 Remote 모듈에서<br>\n사용되는 class 를 과연 알수 있을까?</p>\n<p>Host 의 tailwind content 설정에 사용하는 Remote 모듈의 path 를 등록한다면<br>\n빌드타임에 알수는 있을 것이다.</p>\n<p>하지만 MFA 나 ModuleFederation 에서 remote 모듈은 독립적으로 개발하고 배포된다.<br>\n만약 remote 의 style 이 변경되어 배포 된다면 그 변경사항을 Host 가 알수 있을까?</p>\n<p>Host 가 변경사항을 적용하기 위해서는 사용하는 remote 모듈이 변경될때 Host 본인도<br>\n다시 빌드가 되어야 한다.</p>\n<p>이는 Host 와 Remote 에 거대한 의존성이 생기게 되고, MFA 와 개발원칙과 어울리지 않는<br>\n방식으로 변하게 된다.<br>\n추가로 해당 의존성은 어떻게 관리할 것인가?<br>\n만약 해당 Host 도 또 다른 Host 에 연결되어 있다면?</p>\n<ol start=\"2\">\n<li>두번째는 <code class=\"language-text\">twin.macro 와 같은 css-in-Js 를 사용한다.</code></li>\n</ol>\n<p>css-in-js 는 여기서 좋은 해결법이 될 수 있다.<br>\n런타임에 난독화된 classname 의 style 을 inject 하기때문에<br>\n각 모듈간 classname 의 충돌도 없고<br>\ntwin.macro 같은 경우 tailwind 문법을 그대로 사용할 수 있기 때문이다.</p>\n<p>하지만 이를 위해선 className 에서 별도의 함수로 매번 감싸줘야 하는 불편함이 있고,<br>\n추가로 css-in-js 의 동작방식으로 인한 추가 런타임 비용이 들어가게 된다.</p>\n<ol start=\"3\">\n<li>세번째는 <code class=\"language-text\">tailwind 자체적으로 prefix 를 붙여준다.</code></li>\n</ol>\n<p>Tailwind 에서는 자체적으로 className 의 충돌을 막기 위해 prefix 옵션을 제공한다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">module.exports = {\n  prefix: &quot;custom1-&quot;,\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 하면 실제로 개발 할때</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">&lt;div className=&quot;custom1-grid custom1-grid-cols-1&quot;&gt;\n  &lt;span&gt;Custom&lt;/span&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p>이런식으로 prefix 를 제공할 수 있고, 생성되는 css 에서도 prefix 가 붙어 나오게 된다.<br>\n추가로 vscode 같은 ide 에서도 자동완성 역시 지원된다.</p>\n<p>다만 이 방식의 단점은 가뜩이나 긴 classname 을 더 길게 만들어 DX 가 저하되고,<br>\nclassname 을 복사해서 다른 모듈에서 사용하기가 아주 불편해지는 점이 생긴다.</p>\n<ol start=\"4\">\n<li>네번째는 <code class=\"language-text\">ShaodwDom</code> 을 사용해 dom 을 캡슐화 시킨다.</li>\n</ol>\n<p>ShaodwDom 을 활용해서 해당 모듈을 dom 트리에서 별도로 격리 시켜 버리면, 해당 모듈들은<br>\n같은 className 이라도 독립적인 style 을 활용할 수 있게 된다.</p>\n<p>하지만 이는 또다른 문제를 야기한다.<br>\n말 그대로 격리되어 있기 때문에 디자인 시스템과 같은<br>\n공유 컴포넌트를 사용하기 위해서는 해당 remote 모듈에서 공유 컴포넌트의 style 을<br>\n전부 가지고 있어야 한다.<br>\n배보다 배꼽이 커질 수 있는 방법이다.</p>\n<p>이 모든 해결법에는 모두 tradeoff 가 존재한다.<br>\n실제로 moduleFederation 에서 알려진 큰 문제점 중 하나이다.</p>\n<p><a href=\"https://github.com/nrwl/nx/issues/9784#issuecomment-1095128433\" target=\"_blank\">Nx Git Issue</a> 해당 링크를 살펴보면 Nx 의 개발자가 이 문제에 대해 설명을 잘 해준다.</p>\n<h2>새로운 해결법</h2>\n<p>결국 개발 할때는 기존 Tailwind 를 사용하듯이 일반적으로 사용하고,<br>\n빌드 될때는 모든 classname 에 prefix 가 붙어서 빌드 된다면 이문제는 해결된다.</p>\n<p>이를 해결하기 위해 몇가지 트릭을 사용했다.<br>\n먼저 postcss 의 <code class=\"language-text\">postcss-prefix</code> plugin 을 사용해 빌드될때 styleSheet 의 모든<br>\nclassName 에 고유 prefix 를 붙여준다.<br>\n가장 좋은 prefix 는 해당 package 또는 모듈의 이름이다.</p>\n<p>prefix 가 붙은 styleSheet 의 style 을 적용하기 위해서는 실제 컴포넌트에서도<br>\n해당 prefix 가 붙은 className 을 써야한다.</p>\n<p>예를들어 <code class=\"language-text\">custom1-flex custom2-items-center</code> 이런식으로 써야 하는데<br>\n위에 적었듯이 개발할때는 일반적인 tailwind 를 사용하고<br>\n빌드될때 해당 부분을 변경해줘야 한다.</p>\n<p>이를 위해 Webpack 의 <code class=\"language-text\">string-replace-loader</code> 를 사용해서 빌드타임때 dom 의 className에 있는 class 앞에 모두 prefix 를 붙여줄 것 이다.</p>\n<p>예를들면 이런식이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const twClassnameTransForm = prefix =&gt; {\n  return {\n    test: /\\.tsx$/,\n    loader: &quot;string-replace-loader&quot;,\n    options: {\n      search: /className=[&#39;&quot;]([^&#39;&quot;]*)[&#39;&quot;]/g,\n      replace(_, p1) {\n        const classNames = p1.trim().split(&quot; &quot;)\n        const prefixedClassNames = classNames.map(className =&gt; {\n          if (className.startsWith(prefix)) {\n            return className\n          } else {\n            return `${prefix}-${className}`\n          }\n        })\n        return `className=&quot;${prefixedClassNames.join(&quot; &quot;)}&quot;`\n      },\n    },\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>해당 loader 를 사용하면 실제로 작성한 tailwind className 앞에 내가 원하는 prefix 가<br>\n모두 붙어서 빌드 된다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">&lt;div className=&quot;grid grid-cols-1&quot;&gt;\n  &lt;span&gt;Custom&lt;/span&gt;\n&lt;/div&gt;\n\n// 빌드 후\n\n&lt;div className=&quot;custom1-grid custom1-grid-cols-1&quot;&gt;\n  &lt;span&gt;Custom&lt;/span&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p>이런식으로 추가된다.<br>\n이제 각 모듈간 독립적으로 className 을 가지게 되며, 개발 할때는 일반적인<br>\ntailwind 의 사용을 활용할 수 있게 된다.</p>\n<h2>TwMerge 를 포함한다면?</h2>\n<p>위 방법은 단순히 className 을 string 으로만 적었을때 적용할 수 있다.<br>\n하지만 TwMerge 나 props 로 className 을 받아서 적용할때는 어떻게 해야 할까?</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">&lt;div className={twMerge(&quot;grid grid-cols-1&quot;, props)}&gt;\n  &lt;span&gt;Custom&lt;/span&gt;\n&lt;/div&gt;\n\n// 또는\n\n&lt;div className={`grid grid-cols-1 ${props}`}&gt;\n  &lt;span&gt;Custom&lt;/span&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">string-replace-loader</code> 는 단순하게 string 찾아서 변경시켜 주기 때문에\n이런식의 className 은 변환 시킬 수 없다.</p>\n<p>이를 해결하기 위해서는 별도의 Util 이 필요하다.<br>\n먼저 TwMerge 에서 옵션으로 prefix 설정을 추가하고 별도의 함수로 추출해야 한다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const extendsTwMergeConfig = ... // twMerge theme 관련 custom 설정\n\nconst twMerge = (prefix: string) =&gt; {\n  return isDev\n    ? extendTailwindMerge(extendsTwMergeConfig)\n    : extendTailwindMerge({\n        ...extendsTwMergeConfig,\n        prefix: `${prefix}-`,\n      });\n};\n\nexport const twCombine = twMerge(packageName);</code>\n        </deckgo-highlight-code>\n<p>이런식으로 twMerge 를 개발환경일때는 prefix 를 붙이지 않고 빌드 환경일때만 prefix 가 적용 되도록\n하여 <code class=\"language-text\">twCombine</code> 이라는 함수를 유틸로 노출한다.</p>\n<p>그리고 이 역시 <code class=\"language-text\">string-replace-loader</code> 를 사용해서 변경해주는 loader 가 필요하다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// transform util\nconst twMergeClassNameAddPrefix = (classNames, prefix) =&gt; {\n  const transCls = classNames.map(className =&gt; {\n    const pattern = /[\\&#39;\\&quot;]+/g\n    if (!pattern.test(className)) {\n      return className\n    }\n\n    const trimClassName = className.replace(pattern, &quot;&quot;)\n    if (trimClassName.startsWith(prefix)) {\n      return trimClassName\n    } else {\n      return `&quot;${prefix}-${trimClassName}&quot;`\n    }\n  })\n  return transCls\n}\n\n// 실제 Loader\nconst twMergeClassnameTransForm = prefix =&gt; {\n  return {\n    test: /\\.tsx$/,\n    loader: &quot;string-replace-loader&quot;,\n    options: {\n      search: /className={twCombine\\((.*?)\\)}/g,\n      replace(_, p1) {\n        const classNames = p1.trim().split(&quot;,&quot;)\n        const prefixedClassNames = classNames.map(className =&gt; {\n          const trimed = className.trim()\n          const splitClass = trimed.split(/\\s+/)\n\n          if (splitClass.length &gt; 1) {\n            return twMergeClassNameAddPrefix(splitClass, prefix)\n          }\n\n          const pattern = /[\\&#39;\\&quot;]+/g\n          if (!pattern.test(trimed)) {\n            return trimed\n          }\n\n          const trimClassName = trimed.replace(pattern, &quot;&quot;)\n          if (trimClassName.startsWith(prefix)) {\n            return trimClassName\n          } else {\n            return `&quot;${prefix}-${trimClassName}&quot;`\n          }\n        })\n        return `className={twCombine(${prefixedClassNames.join(&quot;, &quot;)})}`\n      },\n    },\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>twCombine 의 변형은 조금 더 복잡하다.<br>\n중첩되는 className 과 ’,’ 로 구분되는 className 으로 인해 로직이 더 생겼다.</p>\n<p>추가로 props 로 받는 className 에 대해서도 별도의 util 을 만들어서 자동으로 prefix 가<br>\n들어가도록 수정한다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const cxSet = (prefix: string) =&gt; {\n  return function (cls: string) {\n    const result: string[] = []\n    const clsDest = cls.split(&quot; &quot;)\n\n    for (const className of clsDest) {\n      if (className !== &quot;undefined&quot;) {\n        result.push(`${prefix}-${className}`)\n      }\n    }\n\n    return result.join(&quot; &quot;)\n  }\n}\n\nconst twProps = (pkgname: string) =&gt; {\n  const cx = cxSet(pkgname)\n  return (className: string) =&gt; (isDev ? className : cx(className))\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">twProps</code> 같은 경우 <code class=\"language-text\">twCombine</code> 과 마찬가지로 개발환경에서는 일반 className 을<br>\nreturn 하고 빌드타임때는 prefix 를 붙이도록 되어있다.<br>\n실제로 사용할때는 이런식으로 사용이 가능하다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const className = &quot;flex&quot;\nconst App = () =&gt; {\n  const ref = false\n  return (\n    &lt;div\n      className={twCombine(\n        &quot;grid grid-cols-1&quot;,\n        twProps(ref ? &quot; px-0&quot; : &quot;py-2&quot;),\n        twProps(&quot;p-3&quot;)\n      )}\n    &gt;\n      Template\n    &lt;/div&gt;\n  )\n}\n\n// 또는 TwProps With Combine\n&lt;div\n  className={twCombine(\n    twProps(&quot;grid grid-cols-1&quot;),\n    twProps(ref ? &quot; px-0&quot; : &quot;py-2&quot;),\n    twProps(&quot;p-3&quot;)\n  )}\n&gt;\n  twProps\n&lt;/div&gt;\n\n// 단순히 props 로 className 을 받았을때\n&lt;span className={twProps(`grid grid-cols-[1fr_1fr] ${className}`)}&gt;\n  Span\n&lt;/span&gt;\n\n// 일반적인 사용\n&lt;span className=&quot;grid grid-cols-[1fr_1fr]&quot;&gt;Center&lt;/span&gt;</code>\n        </deckgo-highlight-code>\n<p>이제 위 모든 className 이 build 할때 지정한 prefix 가 들어가게 된다.</p>\n<blockquote>\n<p>주의할 점은 <code class=\"language-text\">twCombine</code> 사용시 아래처럼 <code class=\"language-text\">string className</code> 이 twProps<br>\n사이에 있으면 안된다.<br>\n<code class=\"language-text\">string className</code>은 처음 시작되거나, 그게 아니면 twProps 로만<br>\n사용되어야 한다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// OK\n&lt;div\n  className={twCombine(\n    twProps(&quot;grid grid-cols-1&quot;),\n    twProps(ref ? &quot; px-0&quot; : &quot;py-2&quot;),\n    twProps(&quot;p-3&quot;)\n  )}\n&gt;\n  twProps\n&lt;/div&gt;\n\n\n// OK\n&lt;div\n  className={twCombine(\n    &quot;grid grid-cols-1&quot;,\n    twProps(ref ? &quot; px-0&quot; : &quot;py-2&quot;),\n    twProps(&quot;p-3&quot;)\n  )}\n&gt;\n  twProps\n&lt;/div&gt;\n\n\n// FAIL!!\n&lt;div\n  className={twCombine(\n    twProps(&quot;grid grid-cols-1&quot;),\n    &quot;flex&quot;,\n    twProps(&quot;p-3&quot;)\n  )}\n&gt;\n  twProps\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<h2>외부 모듈끼리의 className 주입</h2>\n<p>추가로 만약 module 내에서가 아닌 remote module 끼리 className 을<br>\nprops 로 주고 받는다면?</p>\n<p>twProps 는 들어오는 className 을 받는다면 예외없이 해당 모듈의 prefix 가 붙게 된다.</p>\n<p>이러면 외부 모듈의 className 을 적용할 수 없기 때문에 외부 모듈의 className은<br>\ntwProps 내부가 아닌 별도로 className 을 받아야 한다.</p>\n<blockquote>\n<p>그리고 외부 모듈에서는 반드시 twProps 로 className 을 감싸서 반드시 prefix 를<br>\n붙여서 주입해야 한다.</p>\n</blockquote>\n<p>밑의 예를 보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// module A\nconst ModuleA = () =&gt; {\n  const externalClassName = twProps(&quot;flex items-center&quot;)\n  // 이때 externalClassName 은 module A 의 prefix 를 적용하고 있다.\n  // ex) moduleA-flex moduleA-items-center\n\n  return (\n    // ModuleB 로 moduleA 의 prefix 가 적용된 채로 className 을 주입한다.\n    &lt;ModuleB externalClassName={externalClassName} /&gt;\n  )\n}\n\n// module B\nconst ModuleB = ({ externalClassName }: { externalClassName: string }) =&gt; {\n  // twProps 외부에 externalClassName 을 배치한다.\n  // 이렇게 하면 module B 의 최종 className 은\n  // moduleB-grid moduleB-grid-cols-1 moduleA-flex moduleA-items-center\n  // 이런식으로 양쪽 모듈의 css 를 모두 사용할 수 있다.\n  return (\n    &lt;div\n      className={`${twProps(&quot;grid grid-cols-1&quot;)}\n      ${externalClassName ?? &quot;&quot;}`}\n    &gt;\n      test\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<h2>마무리</h2>\n<p>webpack 의 loader 와 별도의 util 함수를 활용해 DX 저하는 없애고,<br>\n실제로 빌드된 모듈에서는 독립적인 className 을 갖도록 하여 className 의 중복과<br>\n충돌을 없어지도록 만들었다.</p>\n<p>물론 여기서도 tradeoff 가 존재한다.</p>\n<p>twProps 라는 함수로 감싸야 하는 점과 별도의 공통 util 함수를 추출해야 하는점,<br>\nwebpack 을 사용해야 한다는점, 그리고 React 기준이라는 부분.<br>\ntwCombine 사용시 주의해야 할 부분 등.</p>\n<p>위 방법도 어디서 언제 문제가 생길지 모르고, 그냥 tailwind 를 moduleFederation 에<br>\n적용하기 위한 또 하나의 방법이라고 봤으면 좋겠다.<br>\n다행히 아직까지는 문제가 없다.</p>\n<p>다른 번들러에서도 <code class=\"language-text\">string-replace-lorder</code> 와 같은 플러그인이 있어서<br>\n방법만 안다면 충분히 활용해볼만 하다.</p>\n<p>해당 방법을 사용하기 위한 함수와 설명은 충분히 한 것 같아, 별도의 디테일한 설정은<br>\n따로 기술하지 않겠다.</p>\n<p>그리고 혹시 tailwind 를 module federation 에서 사용하고 있고,<br>\n위와 같은 문제를 겪은 뒤 해결한 경험이 있다면 연락해줬으면 한다. 🥹</p>\n<p>다음 글은 아마 <code class=\"language-text\">Signal</code> 에 대한 글로.</p>","frontmatter":{"title":"Tailwindcss with MFA","date":"November 26, 2023","description":"feat.Module Federation"}}},"pageContext":{"slug":"/2023-11-25/","previous":{"fields":{"slug":"/2023-09-19/"},"frontmatter":{"title":"Jotai 사용, 쉽고 빠른 Convention"}},"next":{"fields":{"slug":"/2024-05-13/"},"frontmatter":{"title":"JS Quiz"}}}},"staticQueryHashes":["2841359383","3490846071"]}