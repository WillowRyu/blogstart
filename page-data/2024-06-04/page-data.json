{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-06-04/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"67d55f21-2519-5c88-8194-ed1dc2a2b71a","excerpt":"…","html":"<p>앱을 개발하며 컴포넌트를 만들고 구조를 설계할때 어떤식으로 하면 좋을까<br>\n인터넷이나 책에 다양한 방식의 설계 방법이 존재하고 있지만 공통적으로 말하고 있는 부분은<br>\n비즈니스 로직을 어디다 둘 것인가, 상태관리를 어떤식으로 할 것 인가에 따라<br>\n서비스 설계의 많은 부분이 변경된다.</p>\n<p>물론 리팩토링은 꾸준히 하겠지만 처음 만들때 제대로 정해두지 않으면 팀이 커질수록<br>\n서비스 유지보수에 많은 어려움이 생기고 DX에 악영향을 끼칠수 있다.</p>\n<p>시중에 나와있는 다양한 패턴을 다 설명하는 것 보다 기본적으로 컴포넌트를 만들때<br>\n요정도의 지식을 알고 있다면 추후 서비스를 개발할때 처음부터 헤메는 일은 없을 것 이라 본다.</p>\n<blockquote>\n<p>모든 코드는 React 기준으로 작성되어있다.<br>\n다만 단순히 컴포넌트의 구축 방향을 보기 때문에<br>\n타 UI 프레임워크 에서도 응용할 수 있다.</p>\n</blockquote>\n<p>가장 기본적이고 먼저 볼 부분은 <code class=\"language-text\">Statless</code> 컴포넌트 다.<br>\n말 그대로 이 컴포넌트는 상태를 가지고 있지 않고 오로지 UI 에 집중되어 있다.</p>\n<p>예를 보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">interface CountControlProps {\n  control: {\n    increment: () =&gt; void;\n    decrement: () =&gt; void;\n    reset: () =&gt; void;\n  }\n  count: number\n}\n\nexport function CountControl({ control, count = 0 }: CountControlProps) {\n  const { increment, decrement, reset } = control;\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={increment} type=&quot;button&quot;&gt;\n        Increment\n      &lt;/button&gt;\n      &lt;button onClick={decrement} type=&quot;button&quot;&gt;\n        Decrement\n      &lt;/button&gt;\n      &lt;button onClick={reset} type=&quot;button&quot;&gt;\n        Reset\n      &lt;/button&gt;\n      &lt;p&gt;count: {count}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>내부에서는 별도의 상태를 가지지 않고 외부에서 모든 <code class=\"language-text\">state</code> 와 <code class=\"language-text\">control</code> 을 주입받는다.</p>\n<p><code class=\"language-text\">Statless</code> 장점은 일단 의존하는 부분이 없기 때문에 <code class=\"language-text\">재사용성이 매우 높고</code><br>\n모든 것이 외부 입력에 의해 컨트롤 되므로 <code class=\"language-text\">테스트 하기가 쉽다</code>.<br>\n아마 디자인 시스템의 대부분 UI 컴포넌트에서 사용될 것이다.</p>\n<p>다음으로 볼 컴포넌트는 <code class=\"language-text\">Stateful</code> 컴포넌트다.<br>\n<code class=\"language-text\">Statless</code> 와 다르게 <code class=\"language-text\">Stateful</code> 은 컴포넌트가 로컬 State 와 로직을 가지고 있다.<br>\n위 CountControl 컴포넌트를 <code class=\"language-text\">Stateful</code> 로 변경하면 아래와 같다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function CountControl() {\n  const [conut, setCount] = useState&lt;number&gt;(0);\n  const control = {\n    increment: () =&gt; setCount(count + 1),\n    decrement: () =&gt; setCount(count - 1),\n    reset: () =&gt; setCount(0),\n  }\n\n  const { increment, decrement, reset } = control\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={increment} type=&quot;button&quot;&gt;\n        Increment\n      &lt;/button&gt;\n      &lt;button onClick={decrement} type=&quot;button&quot;&gt;\n        Decrement\n      &lt;/button&gt;\n      &lt;button onClick={reset} type=&quot;button&quot;&gt;\n        Reset\n      &lt;/button&gt;\n      &lt;p&gt;count: {count}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Stateful</code> 은 로컬 State 를 가지며, 자체적으로 State 를 컨트롤한다.<br>\n당연히 외부 주입도 없고, 의존성도 없으며 local state 로 작동하기 때문에<br>\n<code class=\"language-text\">Stateless</code> 와 같이 <code class=\"language-text\">재사용성이 매우 높으며</code>, <code class=\"language-text\">테스트 하기 쉽다.</code></p>\n<p><code class=\"language-text\">Stateful</code> 은 주로 디자인 컴포넌트에서 상태가 필요한 컴포넌트들<br>\n토글바나 다이얼로그, 메뉴 등에 사용된다.</p>\n<h2>Domain 과 합체</h2>\n<p><code class=\"language-text\">Presentatin</code> 과 <code class=\"language-text\">Domain</code> 을 분리하여 만드는 패턴이다.<br>\n아마 <code class=\"language-text\">Container</code> 라고 불리는 컴포넌트 들이 여기 해당된다.</p>\n<p>이때부터는 컴포넌트가 외부 상태와 느슨한 결합이 생기며, 의존성을 가지게 된다.<br>\n예를 들어 서버에서 현재 사용자들을 불러온다고 해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// UserListControl\n\nexport const useUserListControl = () =&gt; {\n  const getUsers: Promise&lt;UserModel[]&gt; = async () =&gt; {\n    const res = await fetch(&quot;https://jsonplaceholder.typicode.com/comments&quot;).then((res) =&gt; res.json);\n    return res;\n  }\n\n  return {\n    getUsers\n  }\n}\n\n// Container\nexport function UserListContainer() {\n  const [users, setUsers] = useState&lt;UserModel[]&gt;();\n  const [isLoading, setLoading] = useState&lt;boolean&gt;(true);\n\n  const { getUsers } = useUserListControl();\n\n  const getUserList = async () =&gt; {\n    const userList = await getUsers();\n    setUsers(userList);\n    setLoading(false);\n  }\n\n  useEffect(() =&gt; {\n    getUserList();\n  }, []);\n\n  if (isLoading) {\n    return &lt;div&gt;Loading&lt;/div&gt;;\n  }\n\n  if (!users) {\n    return &lt;div&gt;No data&lt;/div&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      {users.map((user) =&gt; (\n        // User 는 Statelss Component 라고 생각하자\n        &lt;User user={user} key={user.id}&gt;\n      ))}\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>정의된 fetch 는 크게 신경쓰지 말자. 임의로 만든것들이다.</p>\n</blockquote>\n<p>아주 간단한 예제이지만 여기서 <code class=\"language-text\">useUserListControl</code> 은 도메인 로직이며,<br>\n<code class=\"language-text\">UserListContainer</code> 는 <code class=\"language-text\">Stateful</code> 컴포넌트 이면서 내부에서 도메인로직을<br>\n부르기 때문에 도메인 로직과 의존성이 생겼다.</p>\n<p><code class=\"language-text\">UserListContainer</code> 는 <code class=\"language-text\">UI 로직에 대한 책임</code>을 가지고, 도메인과 관련된<br>\n비즈니스 로직에 대한 책임은 <code class=\"language-text\">useUserListControl</code> 훅(또는 서비스)으로 위임했다.</p>\n<p>이런식으로 <code class=\"language-text\">DomainSide &lt;-> PresentationSide</code> 로 확실히 분리시켜 두면<br>\n코드를 이해하기 더 쉬울뿐만 아니라 UI 테스트와 비즈니스 로직의 테스트를 용이하게<br>\n만들어준다.</p>\n<p>하지만 우리가 아는 실제 서비스들은 훨씬 복잡하겠지?</p>\n<p>실제로 위 방식은 비교적 간단한 Container 에서 사용하게 되고<br>\nDepth가 깊어짐에 따라 더욱더 많은 상태를 조작하거나 추가 메소드가 필요해진다.</p>\n<p>여기서 CQS 를 결합할 수 있다.<br>\nCQS 는 <code class=\"language-text\">Command Query Separation</code> 즉 읽기와 쓰기를 명확히 분리하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/af60fd6c03e1d740419f1752f65dec4b/5a6dd/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.24324324324324%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiUlEQVQoz6VSy07CQBTtP7n0J/wOt36FkYWuSViQACZGXq0S2NHERExsMVRSSu3DQitBHm0xpS3l2I6BBCFunOTOzJ2cOfeeM0PhH2O9Xu+dUb1eD6VSCeVyGZVKBdVqFY1GA4VCAcViERzHoVarIZ/PEwxN02QviiIhiKJoS54E1el0kEqlkE6nCUkmkyGXcrkcstksGIaBIAhQVRWDwQCj0Yisruse7JTSdQ23xRuwbDMOFvV6HfP5HEEQkOphGB6UFtPExAY8z9vt8C+PfN/fStoZ8ZEz96G8/XS94+HoU8VD9wq61cZs6sTSFAKSZRnNZhM8z5N8OBxCkiRo6jtelGu0+pd45loxXotVBFgsFqQ41Xg6R1k8Qr19hvGHDdueEcmO42C5XBJgktu2jclkiv5bF8zrCWjpGLzIYDJ2YVkmdF0n9lCy8Yh7/hSCcoeuIEHVlBhgwTAM8pIJ0DRN0mGyfi08cHIerHABx53tf5tkCvx901erFSHZmP7bwyjE9ttsHiSJb9ktl43EteSKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"CQS\"\n        title=\"CQS\"\n        src=\"/static/af60fd6c03e1d740419f1752f65dec4b/fcda8/1.png\"\n        srcset=\"/static/af60fd6c03e1d740419f1752f65dec4b/12f09/1.png 148w,\n/static/af60fd6c03e1d740419f1752f65dec4b/e4a3f/1.png 295w,\n/static/af60fd6c03e1d740419f1752f65dec4b/fcda8/1.png 590w,\n/static/af60fd6c03e1d740419f1752f65dec4b/5a6dd/1.png 802w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>해당 패턴을 적용할때 주의할 점은 실제로 State 가 변경될때 자동으로 전파가 되어야 하며,<br>\n해당 State 를 사용하는 <code class=\"language-text\">Usecase</code> 한테는 동일하게 공유되어야 한다는 것이다.</p>\n<p>일반적으로 <code class=\"language-text\">ObservableState</code> 를 만들어야 하는데, 적용 가능한 방법은<br>\n<code class=\"language-text\">Signal</code>, <code class=\"language-text\">rxjs</code> 또는 <code class=\"language-text\">Relay</code> 나 <code class=\"language-text\">Apollo client</code> 로 graphql 을 활용하는 방법 등이<br>\n있겠다.<br>\n아니면 상태관리 패키지를 사용해도 되고.</p>\n<blockquote>\n<p>gql 을 사용하면 이런 패턴의 상당 부분을 압축 할 수 있다.</p>\n</blockquote>\n<p>일단 여기서는 대중적인? <code class=\"language-text\">Rxjs</code> 로 작성을 해보겠다.<br>\n간단한 TODO List 를 만든다고 생각해보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import type { Observable } from &#39;rxjs&#39;;\nimport { BehaviorSubject, map } from &#39;rxjs&#39;;\n\ntype Todo = {\n  id: number;\n  title: string;\n  completed: boolean;\n};\n\nexport const TodoListStateService = () =&gt; {\n  const todos$ = new BehaviorSubject&lt;Todo[]&gt;([\n    {\n      id: 1,\n      title: &#39;first todo&#39;,\n      completed: false,\n    },\n  ]);\n\n  const addTodo = (title: string) =&gt; todos$.next([...todos$.value, {\n    id: todos$.value + 1,\n    title,\n    completed: false,\n  }]);\n\n  const toggleCompleted = (id: Todo[&#39;id&#39;], completed: boolean) =&gt; {\n    todos$.next(todos$.value.map((todo) =&gt; (todo.id === id ? { ...todo, completed } : todo)));\n  };\n\n  return {\n    todos$: todos$.asObservable(),\n    toggleCompleted,\n    addTodo,\n  } as const;\n};</code>\n        </deckgo-highlight-code>\n<p>간단하게 만든 TodoState 다.</p>\n<p>해당 서비스는 Todo 라는 State 의 상태를 관리하고<br>\n업데이트 한다. 사실 react 와 조금 어울리지 않지만 일단 특정 State 의 상태를 책임지는<br>\n서비스를 만들었다고 생각하자.</p>\n<p>그리고 해당 서비스를 이용한 Usecases 를 만들어보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\"> export const TodoListUsecase {\n   const { todos$, toggleCompleted, addTodo } = TodoListStateService();\n\n\n    // useObservableState 는 실제로 Observalbe 을 구독해\n    // useState 에 저장하는 유틸함수라고 생각하자.\n\n   const todoList = useObservableState({\n     obs: todos$\n   });\n\n   const inCompletedTodoList = useMemo(() =&gt; {\n    return todoList.filter((todo) =&gt; !todo.completed)\n   }, [todoList]);\n\n   const CompletedTodoList = useMemo(() =&gt; {\n    return todoList.filter((todo) =&gt; todo.completed)\n   }, [todoList]);\n\n   const addTodoItem = (title: string) =&gt; {\n     addTodo(title);\n   }\n\n   const addTodoIfNotExist = (title: string) =&gt; {\n     const alreadyExists = todos.find((todo) =&gt; todo.title === title);\n     if (alreadyExists) {\n        return;\n     }\n     addTodoItem(title);\n   }\n\n   const toggleTodoCompleted = (id: Todo[&#39;id&#39;], completed: boolean) =&gt; {\n     toggleCompleted(id, completed);\n   }\n\n   // 임의로 query 와 command 를 나눴다.\n   return {\n      query: {\n        todoList,\n        inCompletedTodoList,\n        CompletedTodoList,\n      },\n      command: {\n        addTodoItem,\n        addTodoIfNotExist,\n        toggleTodoCompleted\n      }\n   }\n }</code>\n        </deckgo-highlight-code>\n<p>이제 컴포넌트는 <code class=\"language-text\">Usecase</code> 에 의존하게 되며 TodoList 의 State 를 읽어오는 것과<br>\n변경하는 명령어 역시 전부 <code class=\"language-text\">Usecase</code> 를 통해 이루어진다.</p>\n<p><code class=\"language-text\">Usecase</code> 는 <code class=\"language-text\">StateService</code> 에 의존해 실제 state 를 변경하기전 추가적인 메소드와<br>\nstate 를 제공하며 <code class=\"language-text\">Usecase</code> 레이어의 주요목적은 <code class=\"language-text\">StateService</code>를 은폐하기 위함이다.</p>\n<p>도메인과 직접 연결되는 부분에 복잡한 로직과 메소드가 계속 추가 된다면 이해하기도 힘들어지고<br>\n특정 메소드의 테스트에도 많은 부하가 생길 수 있다.<br>\n알수없는 사이드 이펙트는 덤.</p>\n<p>추가로 <code class=\"language-text\">확장성</code>과 <code class=\"language-text\">재사용성</code> 그리고 <code class=\"language-text\">테스트 용이성</code>을 위해 관심사를 확실히 분리한 것이다.<br>\n해당 장점들은 왜 장점이 되는지 잘 생각해보자.</p>\n<p>이렇게 하면 도메인 테스트와 도메인 데이터를 이용한 조회,변경 테스트를 하기가 용이하다.</p>\n<p>추가로 <code class=\"language-text\">CQS</code> 원칙을 사용해 <code class=\"language-text\">read</code> 와 <code class=\"language-text\">write</code> 를 명확하게 분리하여 <code class=\"language-text\">query/command</code>를<br>\n구분하기 쉽고 <code class=\"language-text\">Query</code>는 오로지 read 만 담당하기 때문에 혹시 모를 사이드 이펙트가<br>\n생기지 않는다.</p>\n<p>그리고 문제가 생겼을 경우 <code class=\"language-text\">Query</code> 인지 <code class=\"language-text\">Command</code> 인지 디버깅 하기가 쉬워진다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">  export function UserListContainer() {\n    const { query } = TodoListUsecase();\n\n    return (\n      &lt;div&gt;\n        {query.todoList.map((todo) =&gt; &lt;TodoItem key={todo.id} todo={todo}&gt;)}\n        &lt;p&gt;{query.inCompletedTodoList.length}&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  }</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export function TodoInput() {\n  const { command } = TodoListUsecase()\n  const [title, setTitle] = useState&lt;string&gt;(&quot;&quot;);\n\n  return (\n    &lt;div&gt;\n      &lt;input value={title} onChange={e =&gt; setTitle(e.target.value)} /&gt;\n      &lt;button type=&quot;button&quot; onClick={() =&gt; command.addTodoItem(title)}&gt;\n        Add\n      &lt;/button&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>사용한다면 대충 이런식으로 사용하지 않을까?</p>\n<blockquote>\n<p>대략적으로 막 적은 코드라 오타나 type 오류가 있을 수 있다.<br>\n그냥 흐름만 보자.</p>\n</blockquote>\n<p>위 코드들은 정말 기본적으로 막 사용한 것들이고 추가로 유명한 상태관리 패키지나<br>\n다른 방식으로 충분히 더 훌륭하게 발전 시킬수 있을 것이다.</p>\n<p>위에 적기도 했지만 graphql 을 사용하고 있다면 위 패턴을<br>\n더욱 짧고 쉽게 압축해서 사용할 수 있다.</p>\n<p>워낙 요즘 패키지들이 이런 부분을 잘 지원해줘서 개념만 잘 익히고, 실제로 본인이 적용해보며<br>\n이것저것 고쳐 보는게 좋을 것이다.</p>\n<blockquote>\n<p>참고한 사이트들</p>\n</blockquote>\n<p><a href=\"https://martinfowler.com/bliki/CommandQuerySeparation.html\">CommandQuerySeparation</a><br>\n<a href=\"https://martinfowler.com/bliki/PresentationDomainSeparation.html\">PresentationDomainSeparation</a><br>\n<a href=\"https://www.apollographql.com/blog/client-side-architecture-basics\">ApolloClient&#x26;client-side-architecture-basics</a></p>\n<p>들어가서 한번씩 읽어보면 좋은 글들이다.<br>\n시간이 된다면 꼭 읽어보자.</p>","frontmatter":{"title":"기본 컴포넌트 설계 패턴","date":"June 04, 2024","description":"알아두면 좋다"}}},"pageContext":{"slug":"/2024-06-04/","previous":{"fields":{"slug":"/2024-05-18/"},"frontmatter":{"title":"The New Generation of JavaScript"}},"next":{"fields":{"slug":"/2024-06-16/"},"frontmatter":{"title":"The Programmer's Brain"}}}},"staticQueryHashes":["2841359383","3490846071"]}