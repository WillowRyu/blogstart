{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-08-18/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"8ac28b0e-b599-5e57-8d3c-f62d6ffd2c96","excerpt":"현재 재직중인 회사의 프로젝트는 거대한은 아니고 큰 monorepo 로 이뤄져 있으며 root 의 package.json 에 각 모듈이 사용하는 모든 package…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/074cdd09e1b45ebfce028e7b05d096ca/c1b63/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAIAAACZeshMAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD20lEQVQozwHQAy/8ADZ7wzh7xECAxjl7wzJ6x1WBtaGpvtzl89nh7Zi43cjS4/Pz9tHc7c/c7M/b7evt9b/S6WKZ1Xmo23up2wA6fcU5fcU0ecU5fMQ3fchfibuRoL1RjtJilc9Qist2o9aUtt6LrtnF1erQ3O7X4fDl7PWCrt2Tt+Hn7fYASobIPH/HY428QoDCMnvHY4e1trzLU4W+WY/McqLYVY/PTYzPTI7Re6fZob7iw9Hl////3ufzz97w8fT5AHSf0zt9x665ypa22zZ+yztTd2tiaZuNjKaip9XZ5W+g1kqO0k6KylyNxXuZwNrb4uDj6e7v8vr6/crZ6wC8zuZblNJqjru+vciEpMwsNE1MT2CqmI92eXtwcnd0haJWkc9OkNNJf7paaouptMvJ0d/L0N7N2enY5PMA4+fv0OP4RWGIXFNZl4WAKzJJZV9yvqWfhKDAZoKjZWx/doCZYoSwWHyrSlFsRlJzp7HErLXIys/a3eDoAM3U4e3x911hc1dSW5N+dzI2SlU9SphwbKGcpZ+hsmJmc0JFVlVUYUJGWTg4SWJleYem0ISlz6m927K+0wCUoLuzvM5GS2BsYGKekZBldZI+HCFZPENwf51ITF02PE44OUU6QFJHQEZeUlKSkqKYtt91odeAp9edut4AiaDEscDYgoiXp5iQpK/AcJ/YdIGfmI2aeZjAb4yydJjHXWyHTFBkQT5KTEhPbm93oqSxoK3FuMvlxNLoALfH3rLD3b3K4cbQ4qe/3n6k1ougycrDzZOTnYGVsn+Xu05ffWJ0k1NeeHeBl3iPrYKXs5600bbK5LDH5ADQ1uS0xd6iu9uswuCqv92Qs919jLXUzNe9yuCLp8uHmLNmbYBfbH5odYamrLy70u7J2e7K1+nM1uXJ1ecAtL7SucHTzdXjz9fnztfpy9jsgpC0sq3A4uf0tsnmtsXeydfttsDScHmCfoWTv87kxdPpxtftw9Trx9PoAKq917LH4piowqi0xJ6qtbjE0H2Nr4iKpt3a3MHQ17nK2LfH177O37rL3LLD08HQ47rF0rO9ycDM2sfW5wBmc194inxKVEpYYU1QWUdga1hqb3eDg4aTpJKOooyNoI+KnouJnYmSpY9wfW1kbltPWUhDSzdWYklufmcAh4eJgn+GiomRjYuWjYqYjY2cTEZLdXB1lJWlmpiomZenlJOkkpGgkI6cioiShISMf3+Hg4WKfX+Ce3x+AHt2fHZzdXRxcnBscXNxdoB9gygnKk9MVYmIl5aUoJ6Zo3t6h4eGlYSCkX58h4uHi5KMi4+KipGLjJiSkibvSqVUlVAtAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ff\"\n        title=\"ff\"\n        src=\"/static/074cdd09e1b45ebfce028e7b05d096ca/fcda8/1.png\"\n        srcset=\"/static/074cdd09e1b45ebfce028e7b05d096ca/12f09/1.png 148w,\n/static/074cdd09e1b45ebfce028e7b05d096ca/e4a3f/1.png 295w,\n/static/074cdd09e1b45ebfce028e7b05d096ca/fcda8/1.png 590w,\n/static/074cdd09e1b45ebfce028e7b05d096ca/efc66/1.png 885w,\n/static/074cdd09e1b45ebfce028e7b05d096ca/c83ae/1.png 1180w,\n/static/074cdd09e1b45ebfce028e7b05d096ca/c1b63/1.png 1200w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>현재 재직중인 회사의 프로젝트는 거대한은 아니고 큰 monorepo 로 이뤄져 있으며<br>\nroot 의 package.json 에 각 모듈이 사용하는 모든 package 들이 정의되어 있다.</p>\n<p>이렇게 <code class=\"language-text\">singleVersionPolicy</code> 를 사용하게 되면 각 모듈이 별도의 버전을 가지는 것에 비해<br>\n내부 모든 코드가 호환되고 일관성이 생기며, 특정 package 를 업데이트 할때 전체 모듈에게<br>\n한번에 배송된다는 장점이 있다.</p>\n<p>monorepo 구조의 개발과 배포에 대한 부담감을 상당히 줄여주는 package 중 하나는<br>\n<code class=\"language-text\">turborepo</code> 또는 <code class=\"language-text\">nx</code> 가 있겠다.</p>\n<p>이는 많은 수의 개별 모듈을 만들고 실행할때 명령어들을 하나로 압축하여<br>\n한번에 관리 할수 있는 아주 편리한 기능을 제공해주며, caching 으로 인해 시간의 손실을<br>\n현격히 줄여준다.</p>\n<p>또 하나로 흔히 말하는 <code class=\"language-text\">micro frontend</code> 구조를 위해 <code class=\"language-text\">module federation (mfe)</code> 를<br>\n사용하고 있는데 이는 모듈의 변경사항을 적용할때 각모듈을 이어주고 런타임에서<br>\n적용시켜주는 아주 고마운 기능을 제공해준다.</p>\n<p>위 2가지 핵심기술과 나머지 도구들을 조합하여 몇년전부터 계속 프로젝트를 진행하던 중<br>\n나는 슬슬 속도에 불만이 생기기 시작했다. 🤔</p>\n<p>우리는 <code class=\"language-text\">shared</code> 한 기능을 수정하거나 <code class=\"language-text\">internal package</code> 가 변경될때<br>\n모든 모듈을 다시 <code class=\"language-text\">build</code> 하고 배포해야 하는 경우가 종종 생기게 되는데<br>\n현재 모듈이 약 40개 가까이 만들어져 있으므로 CI 에서 속도가 점점 느려지기 시작했다.</p>\n<p>이를 개선하기 위해 각 CI 단계에서 실행되는 명령어중 속도를 올릴수 있는 도구로<br>\n변경해 보기로 했다.</p>\n<h2>lint</h2>\n<p>eslint 는 역사가 깊고, 커스텀할 수 있는 영역이 굉장히 많아 대부분의 개발자가 사용하는<br>\n범용적인 linter 이다.</p>\n<p>사실 lint 자체의 속도는 그렇게 큰 이슈가 되지 않았지만 가장먼저 만만해 보이는 lint 먼저<br>\nrust 기반의 <code class=\"language-text\">oxlint</code> 로 변경했다.</p>\n<p>확실히 변경 후 속도가 10초 이상을 가는 적이 없을 정도로 효과가 어마어마 했다.<br>\n<code class=\"language-text\">oxlint</code> 로 변경할때 <code class=\"language-text\">eslint</code> 의 구성을 가져다 쓸수도 있고, 자체적으로 왠만한 범용규칙은<br>\n가지고 있기 때문에 변경하는데 큰 어려움은 없었다.</p>\n<h2>tsc</h2>\n<p>우리는 pr 이든 push 든 모든 부분에서 <code class=\"language-text\">noEmit</code> 상태로 <code class=\"language-text\">tsc</code> 를 실행한다.<br>\n다만 <code class=\"language-text\">tsc</code> 의 속도는 발전했다고는 하나 아직 여전히 느리다. 내생각에는.<br>\nCI 에서 다른 부분의 속도가 빨라지게 되니 tsc 의 시간이 차지하는 지분이 점점 많아졌다.</p>\n<p>이미 2020년에 <code class=\"language-text\">noEmit</code> 상태에서 <code class=\"language-text\">incremental</code> 의 옵션을 적용 가능 하기 때문에<br>\nCI 에서 해당 옵션을 적용할 수 있도록 caching 을 손보기 시작했다.</p>\n<p>적용 후 어느정도 빨라지긴 했지만 아직은 만족할 수 없다.<br>\n이제 rust 기반의 툴에 익숙해진 탓이다.</p>\n<h2>webpack</h2>\n<p>이외에 다른 부분도 자잘하게 변경하여 시간의 손실을 조금씩 막았지만, <code class=\"language-text\">webpack</code> 의<br>\n빌드 부분은 최적화를 하고 또 해도 한계가 있어보였다.</p>\n<p>기능 구조를 바꾸고 모듈을 더 쪼개고 각 모듈이 적은 코드를 가질 수 있도록 변경해도<br>\n속도에 대해서는 그렇게 큰 이점을 얻지 못했다.</p>\n<p><code class=\"language-text\">webpack</code> 의 최적화는 속도보다 최종 결과물의 용량에 대해 더 관여하는 느낌이었다.</p>\n<p>그래서 결국 이전부터 눈여겨보던 <code class=\"language-text\">rspack</code> 으로의 변경을 시도했다.<br>\n때마침 <code class=\"language-text\">rspack</code> 에서 <code class=\"language-text\">1.0.0 alpha, beta</code> 버전이 출시 되기 시작했다.</p>\n<h2>변경하기 전에</h2>\n<p>특정 패키지를 변경할때 뿐만 아니라 기능을 변경하거나 추가할때, 어쨌든 하위호환이 가능하도록<br>\n유지하고 점진적으로 프로젝트를 변경해야 한다.</p>\n<p>번들러가 변경된다고 내부 코드에서 특정 무언가를 변경하는 경우가 없도록 해야 한다.<br>\n이 점을 최대한 유의하며 작업을 시작했다.</p>\n<h2>webpack plugin</h2>\n<p>번들러 변경시 첫번째로 걱정된점은<br>\n우리는 <code class=\"language-text\">tailwindcss</code> 를 주력으로 사용중이며, module 간 tailwind 의 treeshaking 으로<br>\n만들어진 css 정의가 중복되면 안되고, <code class=\"language-text\">css cascade</code> 에 서로 영향을 받지 않도록<br>\n만들어야 했다.</p>\n<p>이를 위해 별도의 <code class=\"language-text\">webpack plugin</code> 을 자체적으로 만들어 각 모듈이 build 될때<br>\nmodule의 이름이 <code class=\"language-text\">prefix</code> 로 담긴 <code class=\"language-text\">css 파일</code>과 <code class=\"language-text\">className</code> 을 만들어 주도록 했다.</p>\n<p>다행히 <code class=\"language-text\">rspack</code> 에서는 기존 webpack 의 plugin 과 호환성을 가지도록 인터페이스가 제공되어<br>\n특별히 해당 plugin 을 변경 할 필요는 없었다.</p>\n<h2>module federation</h2>\n<p><code class=\"language-text\">webpack</code> 과 <code class=\"language-text\">rspack</code> 에서 빌드된 파일들이 기존 프로젝트에서 서로 호환이 유지되어야 했다.</p>\n<p><code class=\"language-text\">module federation core</code> 팀은 번들러에 내장된 기능을 사용하는 것이 아닌<br>\n<code class=\"language-text\">module federation runtime</code> 으로 새롭게 분리하여 특정 번들어에 종속되지 않고<br>\nfederation 기능을 사용할 수 있도록 만들었다.</p>\n<p>그래서 먼저 <code class=\"language-text\">module federation runtime</code> 을 활용하여 federation 의 역활과<br>\n번들러의 역활을 명확하게 나누어 새로운 구조를 만들었다.</p>\n<p>이제 <code class=\"language-text\">webpack</code> 으로 빌드를 하던, <code class=\"language-text\">vite</code>, <code class=\"language-text\">rspack</code> 으로 빌드를 하던 mfe 는 그에 상관없이<br>\n<code class=\"language-text\">runtime</code> 에 remote 와 host 가 잘 통합된다.</p>\n<h2>module federation plugin</h2>\n<p>mfe 가 별도의 라이브러리로 분리되면서 기존에 있던 불편한점이 많이 사라졌다.<br>\n예를 들면 <code class=\"language-text\">dynamic remote load</code> 를 할때 <code class=\"language-text\">new promise</code> 를 사용하는 짜치는 방법에서<br>\n이제는 runtime 에 포함된 기능으로 간단히 구현이 가능한다.</p>\n<blockquote>\n<p>분리되면서 federation 의 기능을 좀더 세밀하게 제어할 수 있는 인터페이스가<br>\n많이 생겼다. 공식 홈페이지를 참고해보자.</p>\n</blockquote>\n<p>이번에 구조를 바꾸면서 공통적으로 사용 할 2가지 <code class=\"language-text\">plugin</code> 을 추가 했는데,<br>\n첫번째는 기존 webpack 의 plugin 으로 사용하던 <code class=\"language-text\">external remote plugin</code> 을<br>\nmfe 의 plugin 으로 옮겨서 적용했다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { FederationRuntimePlugin } from &quot;@module-federation/enhanced/runtime&quot;\n\nfunction externalRemoteLoadPlugin(): FederationRuntimePlugin {\n  return {\n    name: &quot;external-remote-load-plugin&quot;,\n    beforeRequest: args =&gt; {\n      const { options, id } = args\n      const remoteName = id.split(&quot;/&quot;).shift()\n      const remote = options.remotes.find(remote =&gt; remote.name === remoteName)\n      if (!remote) {\n        return args\n      }\n\n      // @ts-ignore\n      if (remote?.entry?.includes(&quot;?t=&quot;)) {\n        return args\n      }\n\n      // @ts-ignore\n      remote.entry = `${remote?.entry}?t=${Date.now()}`\n      return args\n    },\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이러면 <code class=\"language-text\">remoteEntry.js</code> 파일에대해 <code class=\"language-text\">cache busting</code> 을 plugin 없이 적용 가능하다.<br>\n<code class=\"language-text\">manifest.json</code> 파일을 사용 할 경우 추가 코드가 필요하지만 맥락은 같다.</p>\n<p>또 다른 하나는 <code class=\"language-text\">hmr</code> 과 <code class=\"language-text\">react-dom</code> 와 관련된 부분이다.</p>\n<p>기존에 local 에서 특정 host 와 remote 를 연결해서 개발할때 자체적으로 만든 명령어를<br>\n사용하여 각 모듈을 개발 서버로 띄워서 hmr 기능을 활용하도록 만들었다.</p>\n<p>다만 <code class=\"language-text\">react</code> 에서 <code class=\"language-text\">context</code> 의 공유 문제나 특정 모듈이 먼저 로드 되어야 할때,<br>\n예를 들어 디자인시스템 등,<br>\nshared 로 설정된 <code class=\"language-text\">react</code> 와 <code class=\"language-text\">react-dom</code> 를 어떤 모듈에서 가져와 사용할지에 대해<br>\n애매한 부분이 있었다.</p>\n<p>아마 <code class=\"language-text\">shared</code> 에 대한 설정이 기본적으로 <code class=\"language-text\">version-first</code> 이기 때문에 실제로는<br>\n마지막에 load 한 모듈에서 사용하는 것으로 설정이 된다.<br>\n그렇다고 미리 가져온 shared 모듈을 다시 불러온다는 뜻은 아니다.<br>\n출처만 변경 된다는 것이다.</p>\n<p>왠만한 경우에서는 큰 문제가 되지 않을 것이다. (또는 eager 를 사용하면 해결은 된다.)<br>\n다만 <code class=\"language-text\">eager 옵션의 사용은 최대한 자제</code>하고, 강제적으로 현재 <code class=\"language-text\">host</code> 에서<br>\n<code class=\"language-text\">react</code> 와 <code class=\"language-text\">react-dom</code> 을 사용하도록 하기 위해 두개의 package 는<br>\nhost 에서 가져오도록 강제하는 plugin 을 추가 했다.</p>\n<p>이는 local 에서 개발할때 hmr 적용 시 <code class=\"language-text\">host</code> 의 <code class=\"language-text\">react-dom</code> 을 사용하도록 만들고,<br>\n배포 된 후에는 최상위 <code class=\"language-text\">root</code> 의 <code class=\"language-text\">host</code> 모듈에서 <code class=\"language-text\">react</code> 와 <code class=\"language-text\">react-dom</code> 을 가져가도록 한다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">    resolveShare(args) {\n      if (args.pkgName !== &#39;react&#39; &amp;&amp; args.pkgName !== &#39;react-dom&#39;) {\n        return args;\n      }\n\n      const {\n        shareScopeMap,\n        scope,\n        pkgName,\n        version,\n        GlobalFederation } = args;\n      const host = GlobalFederation[&#39;__INSTANCES__&#39;][0];\n\n      if (!host) {\n        return args;\n      }\n\n      args.resolver = function () {\n        const hostScope = Array.isArray(host.options.shared[pkgName])\n          ? host.options.shared[pkgName][0]\n          : host.options.shared[pkgName];\n\n        if (hostScope) {\n          shareScopeMap[scope][pkgName][version] = hostScope;\n        }\n\n        return shareScopeMap[scope][pkgName][version];\n      };\n\n      return args;\n    },</code>\n        </deckgo-highlight-code>\n<p>plugin 의 interface 중 <code class=\"language-text\">resolveShare</code> 에서 공유 모듈을 어떤식으로 지정할지에 대한<br>\n정의를 해주었다.</p>\n<p>위 plugin 의 기능은 SPA 에서는 없어도 잘 돌아갈수 있으나 일종의 보험 같은 것이다.</p>\n<p>나머지 <code class=\"language-text\">remote load</code> 에 대한 <code class=\"language-text\">에러처리</code>와 <code class=\"language-text\">초기화</code>와 관련해서 몇가지를 더 추가해서<br>\nfederation 이 잘 돌아갈수 있도록 안정성을 높여두었다.</p>\n<h2>module federation dts</h2>\n<p>이번 federation 설정에서 자체적으로 remote 의 <code class=\"language-text\">ts type</code> 을 생성해주는<br>\n기능을 포함해서 나왔다. 이전에는 분리되어 있던 plugin 이지만 요즘엔 ts 를 안쓰는 프로젝트를<br>\n찾는게 더 힘드니 당연히 포함되서 나온 듯 하다.</p>\n<p>해당 기능으로 인해 remote 로 가져오는 모듈에 대해 ts 의 자동완성 기능을 더 잘 활용할수<br>\n있고 자체적으로 d.ts 를 만들 필요가 없어졌다.</p>\n<p>다만 <code class=\"language-text\">dev</code> 옵션이라고 개발중에 실시간으로 <code class=\"language-text\">tstype</code> 을 생성해주는 기능이 있는데<br>\n현재 <code class=\"language-text\">매우 느리기 때문에 사용을 비추</code>한다.</p>\n<h2>rspack</h2>\n<p><code class=\"language-text\">rspack</code> 으로의 전환은 그렇게 큰 문제는 있지 않았다.<br>\nrspack 에서 webpack 과의 호환성을 워낙 잘 맞춰둔 것도 있고<br>\nwebpack 에서 했던 여러 설정들이 하나로 합쳐진 부분도 있고 해서 더 간소화 시킬 수 있었다.</p>\n<p>주요 변경점은 <code class=\"language-text\">csslodaer</code> 의 사용변경과 기존에는 <code class=\"language-text\">esbuild</code> 로 빌드하고<br>\n<code class=\"language-text\">swc</code> 로 <code class=\"language-text\">polyfill</code> 을 넣어 주고 있었는데 이제는 <code class=\"language-text\">swc</code> 로 통일 되었다는 점?</p>\n<p>나머지 짜잘한 설정들은 시행착오를 겪으며 조금씩 수정하여 모든 모듈을 빌드 버전으로<br>\nlocal 에서 테스트 한뒤 전환을 하였다.</p>\n<p>아마 webpack 관련 설정은 안정화 되면 약 1개월 뒤 삭제 될 것이다.</p>\n<p><code class=\"language-text\">rspack</code> 으로 전환 후 결과적으로 빌드 속도가 3배는 빨라진듯하다. <code class=\"language-text\">붉은혜성</code> 같다.</p>\n<h2>추가 변경</h2>\n<p>그외 회사 자체 lib 를 모아둘 패키지를 만들어 버전 관리를 하기 시작하였고<br>\n이는 추후 오픈소스로 내보낼수 있다면 좋을 것 같다.</p>\n<p>그리고 폴더구조나 명령어삭제,추가 등 조금더 개발을 빠르고 편하게 사용할 수 있도록<br>\n변경을 조금 하였다.</p>\n<p>중요한점은</p>\n<blockquote>\n<p>변경된 구조와 package 가 적용되는 도중에도<br>\n누구도 현재 개발작업에 방해를 받지 않았고<br>\n변경된 후에도 이전과 같은 명령어로 똑같이 개발이 가능하다는 것이다.</p>\n</blockquote>\n<p>물론 변경된 후 구조나 변경점에 대해 설명은 하였다.<br>\n포인트는 이렇게 <code class=\"language-text\">대규모 변경을 할때도 하위호환을 유지하는 것</code>과<br>\n<code class=\"language-text\">breaking change 를 최대한 줄이는게 아주 중요</code>하다는 것이다.</p>\n<p>인원이 많고 연구할 시간이 많은 대기업에서는 모르겠지만,<br>\n빠르게 움직여야 하는 기업이나 팀에서는 기존 작업에서 오류가 생기거나<br>\n작업에 방해되는 부분이 생기면 많은 부분에서 손실이 클 수 있다.</p>\n<p>어쩔수 없는 부분이 생길수도 있지만 잘 생각해보면 방법은 있을 것이다.🤡</p>\n<h2>회고</h2>\n<p>프로젝트 업그레이드 회고 인데 module federation 에 대한 설명이 많은 것 같다.<br>\n그만큼 현재 fe 에서 중요한 부분을 담당하는 기능이기도 해서 그런듯.<br>\n더 설명하고 싶은 부분이 많지만 너무 글이 길어질 것 같아서 피곤해서 끝</p>\n<p>궁금점이나 논의 하고 싶은 부분은 언제든지 문의 주길 바란다.</p>","frontmatter":{"title":"Upgrade Project","date":"August 18, 2024","description":"Rspack, Federation runtime, 회고"}}},"pageContext":{"slug":"/2024-08-18/","previous":{"fields":{"slug":"/2024-06-16/"},"frontmatter":{"title":"The Programmer's Brain"}},"next":{"fields":{"slug":"/2024-10-03/"},"frontmatter":{"title":"Unmanaged Language"}}}},"staticQueryHashes":["2841359383","3490846071"]}