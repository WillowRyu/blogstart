{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-09-19/","result":{"data":{"site":{"siteMetadata":{"title":"FE Factory"}},"markdownRemark":{"id":"9d20cec3-7e4e-5d47-a5ad-195b757a97bb","excerpt":"바쁘다 바빠 오랜만에 글을 쓰는 것 같다. 일도 너무 바쁘고 현생사느라 바빠 글을 남기지 못했지만 그래도 중간중간 기록이 필요한 것 같아 급하게 글을 적는다. 현재 회사 프로젝트에서는 graphql 을 위해 apollo client 를 사용하기 때문에 별도의 state…","html":"<p>바쁘다 바빠<br>\n오랜만에 글을 쓰는 것 같다. 일도 너무 바쁘고 현생사느라 바빠 글을 남기지 못했지만<br>\n그래도 중간중간 기록이 필요한 것 같아 급하게 글을 적는다.</p>\n<p>현재 회사 프로젝트에서는 graphql 을 위해 apollo client 를 사용하기 때문에<br>\n별도의 state management 를 사용하지 않았다.</p>\n<p>state 관리가 필요할땐 rxjs 의 subject 를 활용하거나<br>\nreact 자체에서 제공하는 useReducer 를 활용해 간단한 reducer 를 만들어 사용했다.</p>\n<p>사실 현재 서비스 개발을 시작한지 오래되었고, 다양한 컨벤션이 존재하지만<br>\nstate 관리에 대해선..크게 신경쓰지 않았다.</p>\n<p>대부분의 데이터는 apollo client 의 cache 로 해결이 되고, 간단한건 위에 적었듯<br>\nrx 또는 reducer 를 활용했다.</p>\n<p>하지만..팀원이 늘어나며 각각 자신의 코딩 스타일을 접목하여 state 를 처리하기 시작하니<br>\n이게 서로 알아볼 순 있지만 일관성이 점점 사라지니 피로도가 증가하기 시작했다.</p>\n<p>각 팀원에게 자유도를 최대한 주고, 서로 피드백을 주고 받으며 점점 발전시켜가고 싶었지만<br>\n이젠 결정을 해야 할때가 되었다.</p>\n<p>다양한 state management 라이브러리가 존재하지만<br>\n일단 자유도가 높고, 쓰기 쉬우며, 작은 라이브러리가 필요했다.</p>\n<p>그래서 급하게 zustand, recoil, jotai 등을 살펴보고<br>\n결국 jotai 를 일단 도입하게 되었다.</p>\n<h2>Jotai</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/655ae10550419d7bb29fa3e984fba205/d698c/230919-1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.7027027027027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA50lEQVQY03WQO2qGQBSFB3yA4jMkUfgLwV98iyaKjYuwE1yHNuJerO3sBV2MrZvIyUhACP9XXO7c4Zx7ZoggCGVZapomiqIsy7qua3+gf3sNbklVVfu+13XNcZyiKJZlBUHwpNi2/XHjnYLmk2KaJpmm6TzPYRh4nocYgi9KnudpmiZJEoZhHMdRFKFiWBSF67qO4xiGQY7j2Lat67orOcRZll36bwqOqJcMFXYPyq94nue+78dxXNe1bVu8BKtgjNjY4HmeewPWSI7MBoVIksSyrO/7y7I0TcMwDCIgv6qqyj8wvP/oD3GOPL6xJ3c1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Jotai\"\n        title=\"Jotai\"\n        src=\"/static/655ae10550419d7bb29fa3e984fba205/fcda8/230919-1.png\"\n        srcset=\"/static/655ae10550419d7bb29fa3e984fba205/12f09/230919-1.png 148w,\n/static/655ae10550419d7bb29fa3e984fba205/e4a3f/230919-1.png 295w,\n/static/655ae10550419d7bb29fa3e984fba205/fcda8/230919-1.png 590w,\n/static/655ae10550419d7bb29fa3e984fba205/efc66/230919-1.png 885w,\n/static/655ae10550419d7bb29fa3e984fba205/c83ae/230919-1.png 1180w,\n/static/655ae10550419d7bb29fa3e984fba205/d698c/230919-1.png 1846w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>이글에서 jotai 는 어떤 철학이 있고, 동작원리는 어떻고, 다른 라이브러리와 비교시<br>\n어떤점이 좋다 ~~~ 라는 걸 설명하진 않는다.</p>\n<p>검색만 하면 그에 대한글이 아주 많으니 해당 글들을 참조하자.<br>\n이글에서는 나처럼 빠르게 결정하고, 빠르게 컨벤션을 만들기 위한 사람에게 도움이 되길 원하며<br>\n초기 컨벤션의 모습을 적어볼까 한다.</p>\n<p>Jotai 는 어떠한 프레임워크에도 종속되지 않고, 자유도가 높기 때문에<br>\n초기 컨벤션을 정하려는 팀 또는 개인은 고민이 조금 될 수 있다.</p>\n<p>처음부터 완벽한 컨벤션은 없으니 차차 발전시켜 가면 좋을 것 같다.</p>\n<h2>Convention</h2>\n<p>미리 말하지만 Jotai 를 접한지 얼마 되지 않았기 때문에<br>\n잘못된 점이 있다면 꼭 말해주면 좋겠다.</p>\n<p>특정 feature 또는 어떤 부분에 대해 store 를 활용하고자 한다면<br>\n해당 store 의 범위를 제한 할 필요가 있다.</p>\n<p>특정 Modal, Component 또는 특정 Container 에게만 적용하고 싶다면<br>\nJotai 에서 제공해주는 Provider 를 사용하자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { provider } from &quot;jotai&quot;\n\nexport const ProviderJotai = () =&gt; {\n  return &lt;Provider&gt;{children}&lt;/Provider&gt;\n}</code>\n        </deckgo-highlight-code>\n<p>그냥 이렇게 감싸 주면 된다.<br>\nProvider 는 react context 와 같이 Provider 내부의 Atom 은<br>\n해당 부모 Provider 를 경계로 별도의 Atom 으로 작동하게 된다.</p>\n<p>이 부분은 곧 변경 할테니 Provider 가 이렇구나만 알면되고<br>\nOK 그럼 Store 의 기본요소들, 즉 Store, Actions, Selector 를 적용해보자.</p>\n<p>특정 기능에서 사용 할 Container 주변에 Store 폴더를 하나 만든다.<br>\n해당 Store 폴더 안 개별 store 폴더를 만들고 내부에 Config 폴더를 만든다.</p>\n<p>그리고 Config 폴더 안 selector, actions, store 이렇게 3개의 파일을 만든다.<br>\n그리고 Store 폴더에서는 React 에서 사용하기 위한 커스텀훅을 만든다.</p>\n<p>대략적인 폴더 구조를 보면</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 474px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.756756756756754%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0UlEQVQY03WQy26DMBBF8w0QHjY2ODwEdmzhCIySMSFpxRd000026ar//wWdZh2uNKvRmaO5O0opZwxun/5j1cfj5QLWWkJImqbklXQ7O0JpRqk5Df3olJTDMEgp96+EYRgEQZIkmzDuGGOcs6/HczzDyVrv/bquzrllWeZ5FkLEcfwexsmyjHPu4NpJ1TRN3/da66qqlFLGmDzPt+T/ZiSLovj++YXl7gHQPE0TygEAt1EUbcJYCXZWiIPURogDmuu6Lsuy67q2bfEjvIvyt/AfN0kvYDIgL9MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Str\"\n        title=\"Str\"\n        src=\"/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png\"\n        srcset=\"/static/0f26b20cd5f5437584b25cbca7ad4eeb/12f09/230919-3.png 148w,\n/static/0f26b20cd5f5437584b25cbca7ad4eeb/e4a3f/230919-3.png 295w,\n/static/0f26b20cd5f5437584b25cbca7ad4eeb/5595f/230919-3.png 474w\"\n        sizes=\"(max-width: 474px) 100vw, 474px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>이렇개 사용할 Store 가 구분되고</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 462px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbUlEQVQoz4WSQU+DQBCFe/PSNBQK7S4sFKRABcoCpVQoWmtqTOylN2OMiYlXvfkn/NW+bnowatt32s3sl/dmZluUUoMZhq5P0vx85I+EHMcJggAHVAeH1UJ5OBxalrV9eimyvFksFk1TFMVKCCVN0w7CuhCjtGdaZLk2h7bv+3Ecw1lVVbwghByDDcYck5E4GX988iSGeVVVsEVZUZRjzrueDYNQncgdKbtv376OLCPhaZ7nEyHXdQ/xexj2RFWU+aZbbbNJWMxmZVmmaZplmed5yP9v+D1MAfe63XrbuXsLHAswsOl0iubDMDwRm+o6nOV8LZWbyB/NLyvEhjMXOgkbRJGk68f2w3sWBYCnQlghZkaEDsN056zwpcRXnmMnnF8IMcZkWe4J/R2bgJmJhnthefb85XrBVbNAq03T1HWNzrEzbA7X8Xj8i9/BWPVAU/uW2+U3puNynuCHgI+iCB8GA0MEkLZt9/v9n/A3VeZff8aw5goAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Str2\"\n        title=\"Str2\"\n        src=\"/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png\"\n        srcset=\"/static/2e1e618df3c16d0fd15b5b56c7c7e863/12f09/230919-2.png 148w,\n/static/2e1e618df3c16d0fd15b5b56c7c7e863/e4a3f/230919-2.png 295w,\n/static/2e1e618df3c16d0fd15b5b56c7c7e863/e389b/230919-2.png 462w\"\n        sizes=\"(max-width: 462px) 100vw, 462px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>내부에는 설정과 사용할 react hook 이 존재한다.<br>\n만약 React 가 아닌 다른 다른 프레임워크를 사용한다면<br>\n해당 프레임워크에서 사용할 Store 시작점 함수를 만들어 두자.</p>\n<blockquote>\n<p>이렇게 하면 Config 내부는 다른 어떤<br>\n프레임워크 에서든 사용가능하다.</p>\n</blockquote>\n<p>여기서 간단한 Store 로 예를 만들면</p>\n<p>먼저 Store 파일을 보자.<br>\n(모델의 타입이나 이름은 신경쓰지 말자)</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// store.ts\nimport { atom } from &quot;jotai&quot;\n\nexport interface TestStoreModel {\n  marker?: string;\n  sheetShow: boolean;\n  region: number;\n}\n\nconst initialTestStoreProp: TestStoreModel = {\n  sheetShow: false,\n  region: 0,\n  marker: &quot;test&quot;,\n}\n\nconst TestStoreAtom = atom &lt; TestStoreModel &gt; initialTestStoreProp\n\nexport const TestStoreInfo = {\n  store: TestStoreAtom,\n  initialTestStoreProp,\n}</code>\n        </deckgo-highlight-code>\n<p>Store 에서는 해당 Store의 Atom 과 초기 값을 정의해준다.<br>\n다음으로 actions 을 보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// actions.ts\nimport { TestStoreInfo } from &quot;./store&quot;\nimport { atom } from &quot;jotai&quot;\n\nconst onChangeRegion = atom(null, (_, set, region: number) =&gt; {\n  set(TestStoreInfo.store, prev =&gt; ({\n    ...prev,\n    region,\n  }))\n})\n\nconst onChangeMarker = atom(null, (_, set, marker: string) =&gt; {\n  set(TestStoreInfo.store, prev =&gt; ({\n    ...prev,\n    marker,\n  }))\n})\n\nconst onToggleBottomSheetShow = atom(null, (get, set) =&gt; {\n  set(TestStoreInfo.store, prev =&gt; ({\n    ...prev,\n    sheetShow: !prev.sheetShow,\n  }))\n})\n\nexport const TestStoreActions = {\n  onChangeMarker,\n  onToggleBottomSheetShow,\n  onChangeRegion,\n}</code>\n        </deckgo-highlight-code>\n<p>해당 Store 에서 사용할 Action 들을 정의해둔다.<br>\n마지막으로 selector 를 보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { TestStoreModel } from &quot;./store&quot;\n\nexport const MainMapStoreSelector = {\n  sheetShow: (store: TestStoreModel) =&gt; store.sheetShow,\n  region: (store: TestStoreModel) =&gt; store.region,\n  marker: (store: TestStoreModel) =&gt; store.marker,\n}</code>\n        </deckgo-highlight-code>\n<p>store 에서 selector 로 사용할 부분을 정의한다.</p>\n<p>jotai 는 자유도가 아주 높기 때문에\nactions 나 selecor 모두 다양하게 변형 시킬 수 있다.<br>\n위 예제는 정말정말 간단한 부분만 정의했기 때문에<br>\n사용할때는 각자 필요한 만큼 커스텀 해서 사용하자.</p>\n<h2>React 에서 사용할때?</h2>\n<p>이제 selector, store, actions 를 조합하여 React 에서 사용할 수 있도록<br>\n커스텀 훅을 만들어보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// use-test-store-hook.ts\nimport { TestStoreActions } from &quot;./config/actions&quot;\nimport { TestStoreSelector } from &quot;./config/selector&quot;\nimport { TestStoreInfo } from &quot;./config/store&quot;\n\nexport const useTestStore = () =&gt; {\n  const { store, initialTestStoreProp } = TestStoreInfo\n\n  return {\n    store,\n    actions: TestStoreActions,\n    selector: TestStoreSelector,\n    initialTestStoreProp,\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>이제 어떤 컴포넌트 에서도 useTestStore 를 활용하여 TestStore 에 접근이 가능하다.<br>\n만약 여러 Store 를 만들어서 활용하고 싶다면?<br>\n다른 Config 를 하나 더 만들어 해당 Hook 에 포함하면 된다.<br>\n이런식으로</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export const useTestContainerStore = () =&gt; {\n  const { store: testStore, initialTestStoreProp } = TestStoreInfo\n  const { store: modalStore, initialModalStoreProp } = ModalStoreInfo\n\n  return {\n    store: {\n      test: testStore,\n      modal: modalStore,\n    },\n    actions: {\n      test: TestStoreActions,\n      modal: ModalStoreActions,\n    },\n    selector: {\n      test: TestStoreSelector,\n      modal: ModalStoreSelector,\n    },\n    initialTestStoreProp,\n    initialModalStoreProp,\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>계속 확장이 가능하다.<br>\n실제로 사용할때는 어떤식으로 쓸까</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export const TestComponent = () =&gt; {\n  const { store, actions, selector } = useTestStore()\n\n  // Selector 예제\n  const marker = useAtomValue(\n    selectAtom(store.testStore, selector.testStore.marker)\n  )\n  const sheetShow = useAtomValue(\n    selectAtom(store.modalStore, selector.modalStore.sheetShow)\n  )\n\n  // actions 예제\n  const onToggleSheetShow = useSetAtom(\n    actions.testStore.onToggleBottomSheetShow\n  )\n  const onChangeMarker = useSetAtom(actions.modalStore.onChangeMarker)\n\n  return (\n    &lt;div&gt;\n      {marker}\n      {sheetShow}\n\n      &lt;ContainedButton\n        onClick={() =&gt; onChangeMarker(&quot;당근&quot;)}\n        children=&quot;Marker Actions&quot;\n      /&gt;\n      &lt;ContainedButton onClick={onToggleSheetShow} children=&quot;sheetShow&quot; /&gt;\n    &lt;/div&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>그냥 이렇게 원하는 Store 에서 원하는 selector 와 action 을 가져다<br>\n사용하면 된다.</p>\n<h2>Provider 는?</h2>\n<p>이제 다시 Provider 를 살펴보자.<br>\n어쨌든 Atom 은 React 의 life cycle 외부에 정의해야 하기 때문에<br>\n기본적으로 Global 로 동작하게 된다.</p>\n<p>이렇게 되면 프로젝트가 커질수록 추적이 힘들고 공유 컴포넌트나 기능에서<br>\n같은 Store 를 사용하기 힘들다.</p>\n<p>이제 Provider 로 경계를 맞춰주면 되긴 하는데, 이왕 감싸는거<br>\n다양한 Store 와 초기 값을 넣어 줄 수 있도록 Util 을 만들어 보자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import { PropsWithChildren, ReactNode } from &#39;react&#39;;\nimport { Provider, WritableAtom } from &#39;jotai&#39;;\nimport { useHydrateAtoms } from &#39;jotai/utils&#39;;\n\ntype AnyWritableAtom = WritableAtom&lt;unknown, any[], any&gt;;\nexport type AtomTuple&lt;A = AnyWritableAtom, V = unknown&gt; = readonly [A, V];\n\ninterface ProviderByJotaiProps {\n  store: AtomTuple[];\n}\n\ntype HydrateAtomsWithInitial = {\n  children: ReactNode;\n};\n\nexport function ProviderByJotai({ store, children }: PropsWithChildren&lt;ProviderByJotaiProps&gt;) {\n  const HydrateAtoms = ({ children }: HydrateAtomsWithInitial) =&gt; {\n    useHydrateAtoms([...store]);\n    return children;\n  };\n\n  return (\n    &lt;Provider&gt;\n      &lt;HydrateAtoms&gt;{children}&lt;/HydrateAtoms&gt;\n    &lt;/Provider&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 Provider 를 만들며 사용하고 싶은 Store 를 주입 받는<br>\nProvider Util 을 만들었다.</p>\n<p>실제로 사용하려면</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">export const TestComponent = ({ children }: PropsWithChildren&lt;unknown&gt;) =&gt; {\n  const { store, initialTestStoreProp, initialModalStoreProp } = useTestStore()\n\n  return (\n    &lt;ProviderByJotai\n      store={[\n        [store.testStore, initialTestStoreProp],\n        [store.modalStore, initialModalStoreProp],\n      ]}\n    &gt;\n      {children}\n    &lt;/ProviderByJotai&gt;\n  )\n}</code>\n        </deckgo-highlight-code>\n<p>이런식으로 Provider 에 원하는 Store 와 초기 값을 배열로 넣어 줄 수 있다.<br>\n이제 testStore 와 modalStore 는 해당 children 안에서 global 이 아니고\n별도로 작동하게 된다.</p>\n<h2>Util을 좀 더 만들어보자</h2>\n<p>여기서 몇가지 Util 을 추가 해보자.<br>\njotai 의 홈페이지에도 있는 useSelectAtom, useSplitAtom 을 추가하자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// use-select-atom.ts\nimport { Atom, useAtomValue } from &quot;jotai&quot;\nimport { selectAtom } from &quot;jotai/utils&quot;\n\nexport const useSelectAtom = &lt;T, Slice&gt;(\n  anAtom: Atom&lt;T&gt;,\n  keyFn: (v: T, prevSlice?: Slice) =&gt; Slice\n) =&gt; {\n  return useAtomValue(selectAtom(anAtom, keyFn))\n}\n\n/// useAtomValue(selectAtom(store, selector.marker)) 해당 부분을\n/// useSelectAtom(store, selector.marker) 이렇게 사용가능하다.</code>\n        </deckgo-highlight-code>\n<p>SplitAtom 은 배열 내부에 있는 값들을 별도의 Atom 으로 추출하여<br>\n개별적으로 작동하도록 만드는 기능이다.<br>\n배열 내부의 값 하나하나에 별도로 동작하는 렌더링을 주고 싶을때 아주 좋은 기능이다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// use-split-atom.ts\nimport { PrimitiveAtom, useAtom } from &quot;jotai&quot;\nimport { splitAtom } from &quot;jotai/utils&quot;\n\nexport const useSplitAtom = &lt;Item&gt;(anAtom: PrimitiveAtom&lt;Array&lt;Item&gt;&gt;) =&gt; {\n  return useAtom(splitAtom(anAtom))\n}</code>\n        </deckgo-highlight-code>\n<p>위 2개의 기능은 어짜피 Jotai 홈페이지에 나와있다.<br>\n가져다 썼을 뿐이고..</p>\n<p>실제로 귀찮은 부분은 따로 있었다.<br>\naction 을 사용할때</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// action 을 사용할때 useSetAtom 으로 감싸야 한다.\nconst onToggleSheetShow = useSetAtom(actions.testStore.onChangeMarker)</code>\n        </deckgo-highlight-code>\n<p>action 사용시 useSetAtom 을 적어주기 힘들다. 아니 귀찮다.<br>\n어짜피 hook 으로 사용된다면 actions 에 정의한 함수를 useTestStore 에서<br>\n미리 지정해주면 좋을 것 같다.</p>\n<p>그래서 createActions 를 만들었다.🤡</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// jotai-create-actions\nimport { ExtractAtomArgs, WritableAtom, useSetAtom } from &#39;jotai&#39;;\n\ntype WithInitialValue&lt;Value&gt; = {\n  init: Value;\n};\n\ntype actionsType&lt;T&gt; = {\n  [k in keyof T]: WritableAtom&lt;null, ExtractAtomArgs&lt;T&gt;, void&gt; &amp; WithInitialValue&lt;null&gt;;\n};\n\ntype WrappedActions&lt;T&gt; = {\n  [K in keyof T]: ReturnType&lt;typeof useSetAtom&lt;null, ExtractAtomArgs&lt;T[K]&gt;, void&gt;&gt;;\n};\n\nexport const jotaiCreateActions = &lt;T&gt;(actions: actionsType&lt;T&gt;) =&gt; {\n  return {\n    ...(Object.fromEntries(\n      Object.entries(actions).map(([key, action]) =&gt; {\n        return [\n          key,\n          useSetAtom(\n            action as WritableAtom&lt;null, ExtractAtomArgs&lt;T&gt;, void&gt; &amp; WithInitialValue&lt;null&gt;,\n          ),\n        ];\n      }),\n    ) as WrappedActions&lt;T&gt;),\n  };\n};</code>\n        </deckgo-highlight-code>\n<p>actions 를 돌면서 자동으로 함수를 useSetAtom 으로 감싸준다.\n이제 useTestStore 훅에서 해당 함수를 사용해주자.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// ...\nreturn {\n  store: {\n    test: testStore,\n    modal: modalStore,\n  },\n  actions: {\n    test: jotaiCreateActions &lt; typeof TestStoreActions &gt; TestStoreActions,\n    modal: jotaiCreateActions &lt; typeof ModalStoreActions &gt; ModalStoreActions,\n  },\n  selector: {\n    test: TestStoreSelector,\n    modal: ModalStoreSelector,\n  },\n  initialTestStoreProp,\n  initialModalStoreProp,\n}\n// ...</code>\n        </deckgo-highlight-code>\n<p>이렇게 해두면 이제 사용할때 useSetAtom 으로 감쌀 필요가 없다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const { actions } = useTestStore()\n// actions 예제\nconst onToggleSheetShow = actions.testStore.onToggleBottomSheetShow()\nconst onChangeMarker = actions.modalStore.onChangeMarker()</code>\n        </deckgo-highlight-code>\n<p>아 귀찮은 부분을 조금씩 지워나가고 있으니 속이 시원하다.<br>\nJotai 의 장점이다. 자유도가 뛰어나기 때문에 util 이나 custom hook 을<br>\n어떤식으로 만들지는 사용자의 손에 달려있다.</p>\n<p>추가로 살펴 볼 유용한 Util 은<br>\nfocusAtom 과 atomWithObservable 이다.</p>\n<p>그리고 중첩 Provider 사용시 유용한 jotai-molecules.<br>\n모두 설명하기엔 힘드니, 사용법을 보고 꼭 적용시켜보길.</p>\n<p>위 컨벤션은 Jotai 를 처음 도입할때 도움이 되길 바라는 초기 컨벤션 이며,<br>\n여기서 util 을 더 추가하고, 불편한 부분은 수정하면서<br>\n각자의 프로젝트에 맞게 변형해서 더욱 효율적이고 편하게 활용해보면 된다.</p>\n<p>글을 짧게 쓰려 했는데 쓰다보니 많아졌다.<br>\n하고 싶은 말이 더 많지만 이것도 줄이고 줄였다.</p>\n<blockquote>\n<p>혹시나 잘못된 부분이나 오타가 있다면 알려주면 감사하겠습니다.🥹</p>\n</blockquote>\n<p>그럼 손가락이 아파서 이만.🥹</p>","frontmatter":{"title":"Jotai 사용, 쉽고 빠른 Convention","date":"September 19, 2023","description":"Jotai 를 이제 도입한다면?"}}},"pageContext":{"slug":"/2023-09-19/","previous":{"fields":{"slug":"/2022-11-28/"},"frontmatter":{"title":"MFE 로 프로젝트를 전환"}},"next":{"fields":{"slug":"/2023-11-25/"},"frontmatter":{"title":"Tailwindcss with MFA"}}}},"staticQueryHashes":["2841359383","3490846071"]}