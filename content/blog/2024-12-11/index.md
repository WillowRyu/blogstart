---
title: "Passkey.io"
date: "2024-12-12"
description: "Rust ì™€ í•¨ê»˜"
---

ëŒ€ë¶€ë¶„ì˜ ì‚¬ì´íŠ¸ê°€ ID, PW ë¥¼ ì…ë ¥í•˜ê³  ë“¤ì–´ê°€ê²Œ ë˜ëŠ”ë°, ì£¼ê¸°ì ìœ¼ë¡œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í•˜ë„ë¡  
ê¶Œì¥ ë˜ëŠ” ê°•ì œì ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ìš”êµ¬í•˜ê³  ìˆë‹¤.

ì´ë•Œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ë³€ê²½í• ë•Œ ëŒ€ë¶€ë¶„ì˜ ì‚¬ëŒë“¤ì€ ì´ì „ ë¹„ë°€ë²ˆí˜¸ì™€ ì™„ì „íˆ ë‹¤ë¥¸ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ê¸°  
ë³´ë‹¤ ëŒ€ë¶€ë¶„ ì´ì „ ë¹„ë°€ë²ˆí˜¸ì—ì„œ 1~2ê°œì˜ ìˆ«ì ë˜ëŠ” ì˜ë¬¸ì„ ë³€ê²½í•´ì„œ ë³€ê²½í•˜ê²Œ ëœë‹¤.  
ì•„ë§ˆ ë‹¤ë“¤ ë³¸ì¸ë§Œì˜ ë¹„ë°€ë²ˆí˜¸ë¥¼ í•˜ë‚˜ì”© ê°„ì§í•˜ê³  ìˆìœ¼ë¦¬ë¼.

ì´ íŒ¨ìŠ¤ì›Œë“œ ë°©ì‹ì˜ ë¬¸ì œì ì€ ì˜ˆì „ë¶€í„° ì§€ì ë˜ì—ˆì§€ë§Œ í•˜ë‚˜ì˜ ë¹„ë°€ë²ˆí˜¸ê°€ ë…¸ì¶œëœë‹¤ë©´  
ë‚´ê°€ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ì‚¬ì´íŠ¸ê°€ ë‹¤ í„¸ë¦´ ìœ„í—˜ì´ ì¡´ì¬í•œë‹¤.

ì´ê±¸ ë³´ì™„í•´ì„œ ì´ì œëŠ” 2ì°¨ ì¸ì¦ì„ í•˜ê¸°ë„ í•˜ëŠ”ë° Authenticator ì•±ì„ í™œìš©í•´ 2FA ë¥¼  
í™œì„±í•˜ê±°ë‚˜, í•´ë‹¹ ì„œë¹„ìŠ¤ ì „ìš©ì•±ìœ¼ë¡œ ì´ë¥¼ ìˆ˜í–‰í•˜ê¸°ë„ í•œë‹¤,

ë˜ëŠ” êµ¬ê¸€ì˜ íŒ¨ìŠ¤ì›Œë“œ ê´€ë¦¬ìëŠ” ê·¸ëƒ¥ë´ë„ ì™¸ìš°ê¸° í˜ë“  ë‚œí•´í•œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ìë™ìœ¼ë¡œ ì¶”ì²œí•´ì£¼ê³   
ì €ì¥í•´ì£¼ê¸°ë„ í•œë‹¤.

ì´ ì‹œì ì—ì„œ ì˜ˆì „ì— ì–´ë–¤ ì‚¬ì´íŠ¸ ì¸ì§€ ê¸°ì–µ ë‚˜ì§„ ì•Šì§€ë§Œ íŒ¨ìŠ¤í‚¤ë¥¼ ìƒì„±í•´ì„œ ë¡œê·¸ì¸ í–ˆë˜  
ê¸°ì–µì´ ìˆë‹¤.

ê·¸ë•Œ ë§¥ë¶ì— ìˆëŠ” ì§€ë¬¸ìœ¼ë¡œ íŒ¨ìŠ¤í‚¤ë¥¼ ë§Œë“¤ê³  íŠ¹ì • ì‚¬ì´íŠ¸ì— ë“±ë¡í•´ë‘ë©´ í•´ë‹¹ ì„œë¹„ìŠ¤ì— ì ‘ê·¼í• ë•Œ  
ê°„í¸í•˜ê²Œ ì§€ë¬¸ìœ¼ë¡œ ë¡œê·¸ì¸í•´ì„œ í¸ë¦¬í–ˆë˜ ê¸°ì–µì´ ìˆë‹¤.  
ì¶”ê°€ë¡œ ë§¥ë¶ì´ ì—†ì„ë•ŒëŠ” ëª¨ë°”ì¼ì˜ ìƒì²´ì¸ì¦ì„ ì´ìš©í•´ì„œ ë¡œê·¸ì¸ í•  ìˆ˜ ìˆì—ˆë‹¤.

ê·¸ë˜ì„œ ì´ ê¸°íšŒì— íŒ¨ìŠ¤í‚¤ë¥¼ ì•Œì•„ë³´ê³  ì˜ˆì œë¥¼ ë§Œë“¤ì–´ ë³´ì•˜ë‹¤.

## FIDO

ì¼ë‹¨ íŒ¨ìŠ¤í‚¤ë¥¼ ë§Œë“  ì§‘ë‹¨(?)ì„ ì•Œì•„ë³´ë ¤ë©´ `FIDO(Fast IDentity Online) Alliance` ë¥¼  
ì•Œì•„ì•¼ í•œë‹¤.

FIDO ì—°í•©ì€ ì˜¨ë¼ì¸ ì¸ì¦ì„ ê°„ì†Œí™”í•˜ê³  ë³´ì•ˆì„ ê°•í™”í•˜ê¸° ìœ„í—¤ 2012ë…„ì— ì„¤ë¦½ëœ  
ë¹„ì˜ë¦¬ ë‹¨ì²´ì´ë‹¤.

ì´ë“¤ì€ ì¸ì¦ì„ ìœ„í•œ `UAF`, `U2F`, `FIDO2` í‘œì¤€ì„ ë§Œë“¤ì—ˆëŠ”ë° í˜„ì¬ ë§ì€ ê³³ì—ì„œ ì´ í‘œì¤€ì„ ì´ìš©í•˜ì—¬  
ì„œë¹„ìŠ¤ ë˜ê³  ìˆë‹¤.

ê°„ë‹¨íˆ `UAF (Universal Authentication Framework)` ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì—†ëŠ” ì¸ì¦ì„  
ëª©í‘œë¡œ ë§Œë“¤ì–´ì§„ í‘œì¤€ì´ë©° í˜„ì¬ ìš°ë¦¬ê°€ ë§ì´ ì‚¬ìš©í•˜ê³  ìˆëŠ” ìƒì²´ì¸ì‹ ë˜ëŠ” PIN ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•´  
ì¸ì¦ì„ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤.

`U2F (Universal 2nd Factor)` ëŠ” ê¸°ì¡´ ë¹„ë°€ë²ˆí˜¸ ì¸ì¦ì— 2ë‹¨ê³„ ì¸ì¦ì„ ì¶”ê°€í•˜ê¸°  
ìœ„í•´ ì„¤ê³„ëœ í‘œì¤€ìœ¼ë¡œ ì£¼ë¡œ ë¬¼ë¦¬ ë³´ì•ˆí‚¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¸ì¦ì— ì‚¬ìš©ëœë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ `FIDO2` ê°€ ì§€ê¸ˆ ì„¤ëª…í•˜ë ¤ëŠ” íŒ¨ìŠ¤í‚¤ê°€ ë”°ë¥´ëŠ” í‘œì¤€ì´ë©°, ë¹„ë°€ë²ˆí˜¸ ì—†ì´ ì¸ì¦ì„ ê°€ëŠ¥ì¼€  
í•˜ëŠ” í‘œì¤€ì´ë‹¤.

í˜„ì¬ FIDO ì—°í•©ì—ëŠ” Apple, MS, Google, ìƒ˜ìˆ­ ë“± ë§ì€ ê¸€ë¡œë²… ë¹…í…Œí¬ ê¸°ì—…ì´ ì°¸ê°€í•´  
ì•ˆì „í•˜ê³  í¸ë¦¬í•˜ë©°, í¬ë¡œìŠ¤ ì¸ì¦ì´ ê°€ëŠ¥í•˜ë„ë¡ ë…¸ë ¥ ì¤‘ì´ë‹¤.  
ìš°ë¦¬ëŠ” ê·¸ê±¸ ì¼ë‹¨ ì“°ë©´ ëœë‹¤.

## íŒ¨ìŠ¤í‚¤?

ìƒì²´ì¸ì¦ë§Œí¼ ì•ˆì „í•œ ì¸ì¦ì´ ìˆì„ê¹Œ?  
íŒ¨ìŠ¤í‚¤ì—ì„œëŠ” ìš°ë¦¬ê°€ ì£¼ìœ„ì—ì„œ ë§ì´ ì ‘í•˜ëŠ” Touch ID, Face ID, Windows Hello ë“±  
ìƒì²´ì¸ì‹ì„ í™œìš©í•´ íŒ¨ìŠ¤ì›Œë“œ ì—†ëŠ” ì•ˆì „í•œ ì¸ì¦ì„ ë³´ì¥í•œë‹¤.

ìƒì²´ì¸ì‹ì˜ ì¥ì ì€ ë§ì•ˆí•´ë„ ë‹¤ë“¤ ì•Œê³  ìˆì„ê±°ê³ , íŒ¨ìŠ¤í‚¤ë¥¼ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ íŒ¨ìŠ¤ì›Œë“œì˜ ë„ë‚œ ë˜ëŠ”  
ë¹„ë°€ë²ˆí˜¸ë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ë°”ê¾¸ë©´ì„œ ìŠì–´ë²„ë¦¬ëŠ” ë¶ˆìƒì‚¬ë¥¼ ë°©ì§€ í• ìˆ˜ ìˆë‹¤.

ìœ„ FIDO ì—°í•©ì— ì†í•œ ê¸°ì—…ë“¤ì„ ë´ë„ ì•Œê² ì§€ë§Œ íŒ¨ìŠ¤í‚¤ëŠ” íŠ¹ì • OS, ê¸°ê¸°ì— ì†í•˜ì§€ ì•Šê³   
ì„œë¡œ í¬ë¡œìŠ¤ ì¸ì¦ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— windows ë¡œ ë“±ë¡í•œ íŒ¨ìŠ¤í‚¤ë¥¼ ë§¥os ë‚˜ ëª¨ë°”ì¼ì—ì„œ  
ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

ë­ ê·¸ë ‡ë‹¤ê³  ì¥ì ë§Œ ì¡´ì¬í•˜ëŠ” ê±´ ì•„ë‹ˆë‹¤.  
ì¼ë‹¨ ì–´ì¨Œë“  ìƒì²´ ì¸ì‹ì´ ê°€ëŠ¥í•œ ê¸°ê¸°ê°€ ìˆì–´ì•¼ í•˜ê³ , íŒ¨ìŠ¤ì›Œë“œë¥¼ ë„ë‚œ,ë¶„ì‹¤ì˜ ìœ„í—˜ì€ ì—†ì§€ë§Œ  
ë§Œì•½ ë“±ë¡í•œ ëª¨ë“  ë””ë°”ì´ìŠ¤ë¥¼ ìƒì–´ë²„ë¦°ë‹¤ë©´ ê³„ì • ë³µêµ¬ê°€ ì¡°ê¸ˆ ë³µì¡í•´ ì§ˆ ìˆ˜ ìˆë‹¤.  
ì´ ë¶€ë¶„ì€ ë°±ì—… ì¸ì¦ì„ ì¶”ê°€ í•¨ìœ¼ë¡œì¨ ì¶©ë¶„íˆ í•´ê²° ë  ë“¯ í•˜ë‹¤.

ê°€ì¥ í° ë¬¸ì œëŠ” ë‹¤ë¥¸ ê¸°ìˆ ë“¤ë„ ê·¸ë ‡ì§€ë§Œ ì´ˆê¸° ë‹¨ê³„ë¼ ì´ë¥¼ ì§€ì›í•˜ëŠ” ì„œë¹„ìŠ¤ê°€ ë§ì´ ì—†ëŠ”ê²Œ  
ë‹¨ì ì¼ìˆ˜ë„? ê·¸ ë§ì€ ê·¸ë™ì•ˆ íŒ¨ìŠ¤ì›Œë“œë§Œ ì‚¬ìš©í•˜ë˜ ì‚¬ìš©ìë“¤ì´ í˜¼ë€ì„ ê²ªì„ ìˆ˜ ìˆë‹¤.

ë¹…í…Œí¬ ê¸°ì—…ë“¤ì€ ì´ë¯¸ ë„ì…í•˜ê³  ê¶Œì¥ì„ í•˜ê³  ìˆê¸´í•œë°..  
ì–´ì¨Œë“  ë°±ì—…ì„ ìœ„í•´ì„œë„ ë§ˆìŒ ì† íŒ¨ìŠ¤ì›Œë“œ í•˜ë‚˜ëŠ” ë‹¤ë“¤ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤.

## íŒ¨ìŠ¤í‚¤ ìƒì„±

`WebAuthn` ì´ë¼ëŠ” ê³µê°œí‚¤ ê¸°ë°˜ ì¸ì¦ìœ¼ë¡œ ì´ë¥¼ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤.  
ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í•˜ë©´ User, Client, Server ì˜ ê´€ì ìœ¼ë¡œ ë³´ì.

| ê¸°ì¤€   | í–‰ë™                                                                       | ìˆ˜ì‹ ì |
| ------ | -------------------------------------------------------------------------- | ------ |
| User   | íŒ¨ìŠ¤í‚¤ ìƒì„± ìš”ì²­                                                           | Client |
| Client | í•´ë‹¹ ì„œë¹„ìŠ¤ì˜ ë„ë©”ì¸, ê³ ìœ  ê³„ì •ì •ë³´ (ì´ë©”ì¼, ì‚¬ìš©ì ID) ì „ë‹¬               | Server |
| Server | ìˆ˜ì‹  ì •ë³´ë¡œ Challenge, RPID, ê³µê°œí‚¤ ì˜µì…˜ ìƒì„± í•˜ì—¬ ì „ë‹¬                    | Client |
| Client | Authenticator ì—ê²Œ ìˆ˜ì‹ ë°›ì€ ì •ë³´ë¥¼ ì „ë‹¬                                    | User   |
| User   | ìƒì²´ì¸ì‹ ìœ¼ë¡œ ì‚¬ìš©ì ë³¸ì¸ ì¸ì¦                                             | Client |
| Client | ê³µê°œí‚¤,ê°œì¸í‚¤ ìŒ ìƒì„±. ê°œì¸í‚¤ ê¸°ê¸°ì €ì¥ Challenge ê°œì¸í‚¤ë¡œ ì„œëª…             | Client |
| Client | ê³µê°œí‚¤, ì„œëª…í•œ Challenge, ê·¸ì™¸ ì‚¬ìš©ì ì •ë³´(ë””ë°”ì´ìŠ¤ ì •ë³´ ë“±) ì „ë‹¬          | Server |
| Server | ì„œëª…ì„ ê³µê°œí‚¤ë¡œ ê²€ì¦. ê²€ì¦ ì„±ê³µí›„ ì„œë²„ì— ê³µê°œí‚¤, ì‚¬ìš©ì ID, ê·¸ì™¸ ì •ë³´ ì €ì¥ | -      |

ëŒ€ëµ ìˆœì„œëŒ€ë¡œ í‘œë¡œ ë§Œë“¤ì–´ë´¤ë‹¤.  
ë‚´ ë§ˆí¬ë‹¤ìš´ì´ í˜•í¸ì—†ëŠ” ê±¸ ì´í•´í–ˆìŒ í•œë‹¤.

ì—¬ê¸°ì„œ `Challenge` ëŠ” Client ì—ì„œ ë°›ì€ ì •ë³´ë¡œ Webauthn ì˜ API ë¡œ ìƒì„±í•œ  
ArrayBuffer ê°’ì´ë‹¤.

`Authenticator` ëŠ” ë””ë°”ì´ìŠ¤ì˜ ì¸ì¦ì„ ë‹´ë‹¹í•˜ëŠ” ë³´ì•ˆì¥ì¹˜ ì´ë‹¤.  
ìŠ¤ë§ˆíŠ¸í°ì˜ ìƒì²´ì¸ì¦ ëª¨ë“ˆì´ë‚˜ ë§¥ë¶ì˜ TouchId ê°™ì€ í”Œë«í¼ ì¸ì¦ì ë˜ëŠ”  
USB, NFC, ë¸”ë£¨íˆ¬ìŠ¤ ì¥ì¹˜ë¥¼ ëœ»í•œë‹¤.

ì´ì œ íŒ¨ìŠ¤í‚¤ê°€ ìƒì„± ë˜ì—ˆë‹¤ë©´ ì‚¬ìš©ìëŠ” íŒ¨ìŠ¤í‚¤ë¥¼ í†µí•´ ê°„ë‹¨í•˜ê²Œ ì¸ì¦ì ˆì°¨ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

## íŒ¨ìŠ¤í‚¤ ì¸ì¦

ê·¸ëŸ¼ ë§Œë“¤ì–´ì§„ íŒ¨ìŠ¤í‚¤ë¡œ ì¸ì¦í•˜ëŠ” ì ˆì°¨ëŠ” ì–´ë–»ê²Œ ë ê¹Œ?  
ëŒ€ëµì ìœ¼ë¡œ ìƒì„±ê³¼ ë¹„ìŠ·í•˜ë‹¤.

| ê¸°ì¤€   | í–‰ë™                                                          | ìˆ˜ì‹ ì |
| ------ | ------------------------------------------------------------- | ------ |
| User   | íŒ¨ìŠ¤í‚¤ë¥¼ ì´ìš©í•´ ì¸ì¦ ìš”ì²­.                                    | Client |
| Client | í•´ë‹¹ ì„œë¹„ìŠ¤ì˜ RPID ì™€ ì¸ì¦ ìš”ì²­ (ì‚¬ìš©ì ê³„ì •ì •ë³´ ë“±) ì „ë‹¬     | Server |
| Server | ìˆ˜ì‹  ì •ë³´ë¡œ Challenge, RPID, ì‚¬ìš©ìì˜ ì¸ì¦í‚¤ ë¥¼ ì „ë‹¬          | Client |
| Client | User ì—ê²Œ ìƒì²´ ì¸ì¦ ìš”ì²­                                      | User   |
| User   | ìƒì²´ ì¸ì¦ì„ ì´ìš©í•˜ì—¬ ì¸ì¦                                     | Client |
| Client | ì¸ì¦ í›„ ê°œì¸í‚¤ë¡œ Challenge ë¥¼ ì„œëª…. RPID, ì‚¬ìš©ì ì¸ì¦í‚¤ ì „ë‹¬. | Server |
| Server | ì‚¬ìš©ì ì¸ì¦í‚¤ë¡œ ì‚¬ìš©ì ê³„ì •ì— ë“±ë¡ëœ ê³µê°œí‚¤ ì¡°íšŒ.             | Server |
| Server | ê³µê°œí‚¤ê°€ ìˆì„ê²½ìš° ì‚¬ìš©ì ë””ë°”ì´ìŠ¤ì—ì„œ ì™”ìŒì„ ê²€ì¦.            | Server |
| Server | ì„œëª…í•œ Challenge ë¥¼ ì„œë²„ì—ì„œ ë³´ë‚¸ ê°’ê³¼ ê°™ì€ì§€ í™•ì¸.           | Server |
| Server | Challenge ê°€ ê²€ì¦ë˜ë©´ ì¸ì¦ ì™„ë£Œ                               | -      |

ìƒì„±ë¶€ë¶„ê³¼ ë¹„ìŠ·í•˜ë‹¤.  
í¬ê²Œ ë‹¤ë¥¸ì ì€ ì‚¬ìš©ì ê³ ìœ  ì •ë³´ë¡œ ë“±ë¡ëœ ì‚¬ìš©ì ì¸ì¦í‚¤ë¥¼ ì„œë²„ì—ì„œ ì „ë‹¬í•´ì£¼ëŠ” ë¶€ë¶„ì´ë‹¤.

## ì‹¤ì œ ì½”ë“œ ì˜ˆì œ

ì¼ë‹¨ github repo ëŠ” [PasskeyEx](https://github.com/WillowRyu/passkey-ex) ì´ë‹¤.

í´ë¼ì´ì–¸íŠ¸ ë¶€ë¶„ì€ Remix ë¡œ ë§Œë“¤ì–´ë´¤ê³   
ì„œë²„ëŠ” Rust ì™€ Webauthn ì„ ìœ„í•œ node server ë„ í•¨ê»˜ ì‚¬ìš©í–ˆë‹¤.

![index](./1.gif)

ë¡œê·¸ì¸ í™”ë©´ì´ë‹¤.  
ì¡°ê¸ˆ ì‹¤í—˜ì ì¸ UI ë¥¼ ì ìš©í•˜ê³  ìˆì–´ì„œ íŠ¹ì´í•´ ë³´ì¼ ìˆ˜ ìˆë‹¤.

ì²˜ìŒ ë“¤ì–´ì™”ì„ë•Œ

```javascript
 const checkWebAuthAvailable: () => Promise<{
    username: string;
  }> = async () => {
    if (
      window.PublicKeyCredential &&
      !!PublicKeyCredential.isConditionalMediationAvailable
    ) {
      try {
        const cma = await PublicKeyCredential.isConditionalMediationAvailable();
        if (cma) {
          const user = await authenticate();
          const userName = user?.data?.username as string;
          return { username: userName ?? "" };
        }
      } catch {
        alert("WebAuthn is not available");
      }
    }

    return {
      username: "",
    };
  };
```

ìœ„ ì½”ë“œê°€ ë¨¼ì € ì‹¤í–‰ëœë‹¤.  
ì—¬ê¸°ì„œ `PublicKeyCredential` ì€ ê³µê°œí‚¤/ê°œì¸í‚¤ ìŒì„ ì´ìš©í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ ì¤‘ í•˜ë‚˜ë¡œ  
í•´ë‹¹ ì¸í„°í˜ì´ìŠ¤ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³ , `isConditionalMediationAvailable` ì˜ ì§€ì›ì„ í™•ì¸í•œë‹¤.  
`isConditionalMediationAvailable` ì‚¬ìš©ì ì…ë ¥ì—†ì´ ë“±ë¡ëœ ìê²©ì¦ëª… ë°ì´í„°ë¥¼ ê°€ì ¸ ì˜¬ ìˆ˜ ìˆëŠ” ë°©ì‹ì´ë‹¤.

ë¸Œë¼ìš°ì €ê°€ `isConditionalMediationAvailable` ë¥¼ ì§€ì›í•˜ê³  ì´ë¥¼ ì ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë¯¸ë¦¬  
input ì˜ autoComplete ì— `webauthn` ì„ ì¶”ê°€í•´ë‘ë©´ ëœë‹¤.

```javascript
<CustomInput
  autoFocus
  autoComplete="username webauthn"
  name="username"
  value={username}
  onChange={e => setUsername(e.target.value)}
  placeholder=""
  title="Your Name"
  subText="Please enter any name."
/>
```

ì´ë ‡ê²Œ ë‘ë©´ ì‹¤ì œë¡œ ì‚¬ìš©ìê°€ ì¸ì¦ì‘ì—…ìš¸ í•˜ê¸° ê¹Œì§€ background ì—ì„œ ëŒ€ê¸°í•˜ê³  ìˆê²Œ ë˜ê³ 

![login](./2.png)

ì´ëŸ°ì‹ìœ¼ë¡œ ê¸°ì¡´ì— ë“±ë¡í•œ passkey ë¥¼ ì´ìš©í•´ ì¸ì¦ì´ ê°€ëŠ¥í•˜ê²Œ ëœë‹¤.  
ì¼ë‹¨ ë¨¼ì € íŒ¨ìŠ¤í‚¤ì˜ ë“±ë¡ì „ ê°„ë‹¨í•˜ê²Œ ì‚¬ìš©ìë¥¼ ë“±ë¡í•˜ê³ 

```javascript
  form?.addEventListener("submit", async (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();

    if (e.target) {
      const formData = new FormData(e.target as HTMLFormElement);
      const cred: FormDataObj = {};

      formData.forEach((v, k) => (cred[k] = v));
      _fetch((e.target as HTMLFormElement).action, {
        payload: cred,
      })
        .then((res) => {
          if (res?.data?.id) {
            location.href = "http://localhost:5173/reauth";
            return;
          }
          alert(res?.message);
        })
        .catch(console.log);
    }
  });
```

ì„œë²„ì—ì„œëŠ” í•´ë‹¹ username ì„ ì €ì¥í•˜ê²Œ ëœë‹¤.

```rust
pub async fn handle_username(
    Extension(db): Extension<DatabaseConnection>,
    session: Session,
    Json(payload): Json<CreateUser>,
) -> Result<Json<ResponseUser>, Response> {
    let username_regex = Regex::new(r"^[a-zA-Z0-9@\.\-_]+$").unwrap();

    if !username_regex.is_match(&payload.username) {
        return Err(
            AppError::new("Invalid username".to_owned(), StatusCode::BAD_REQUEST).into_response(),
        );
    }

    let user = match find_user_by_username(&db, &payload.username).await {
        Ok(user) => user,
        Err(_) => {
            let id = generate_base64_id();
            let new_user = users::ActiveModel {
                username: Set(payload.username.to_owned()),
                displayname: Set(payload.username.to_owned()),
                id: Set(id),
            };

            new_user.insert(&db).await.map_err(|_| {
                AppError::new(
                    "Failed to save user".to_owned(),
                    StatusCode::INTERNAL_SERVER_ERROR,
                )
                .into_response()
            })?
        }
    };

    store_username_in_session(&session, payload.username.to_owned()).await?;

    Ok(Json(ResponseUser { data: user }))
}

```

ì´ì œ password ë¥¼ ì…ë ¥í•˜ê¸° ìœ„í•œ reauth í˜ì´ì§€ë¡œ ê°€ê²Œ ë˜ëŠ”ë°  
í˜„ì¬ëŠ” password ë¥¼ ë”°ë¡œ ì €ì¥í•˜ì§€ ì•Šê³  ê·¸ëƒ¥ ì•„ë¬´ê±°ë‚˜ ë„£ì–´ë„ ì§„í–‰ì´ ëœë‹¤.

![password](./3.png)

ì–´ì¨Œë“  password ë¥¼ ë„£ê³  ë¡œê·¸ì¸ í•˜ê²Œë˜ë©´ ì´ì œ passkey ë¥¼ ë§Œë“¤ìˆ˜ ìˆëŠ”  
ì‚¬ìš©ì ì •ë³´ ì°½ì´ ë‚˜ì˜¨ë‹¤.

![home](./4.png)

ì—¬ê¸°ì„œ CreatePasskey ë¥¼ ì´ìš©í•´ íŒ¨ìŠ¤í‚¤ ìƒì„±ì„ í•˜ê²Œ ëœë‹¤.

```javascript
export const useCreateCredential = () => {
  const createCred = async () => {
    const response = await _fetch(auth_api.registerRequest);
    const { data: options } = response;

    options.user.id = base64url.decode(options.user.id);
    options.challenge = base64url.decode(options.challenge);

    if (options.excludeCredentials) {
      for (let cred of options.excludeCredentials) {
        cred.id = base64url.decode(cred.id);
      }
    }

    options.authenticatorSelection = {
      authenticatorAttachment: "platform",
      requireResidentKey: true,
    };

    const cred = (await navigator.credentials.create({
      publicKey: options,
    })) as any;

    const credential: any = {};
    credential.id = cred?.id;
    credential.rawId = cred?.id;
    credential.type = cred?.type;

    if (cred?.authenticatorAttachment) {
      credential.authenticatorAttachment = cred.authenticatorAttachment;
    }

    const clientDataJSON = base64url.encode(cred.response.clientDataJSON);
    const attestationObject = base64url.encode(cred.response.attestationObject);

    const transports = cred.response.getTransports
      ? cred.response.getTransports()
      : [];

    credential.response = {
      clientDataJSON,
      attestationObject,
      transports,
    };

    return await _fetch(auth_api.registerResponse, {
      payload: credential,
    });
  };

  return [createCred] as const;
};
```

ì²«ë²ˆì§¸

```javascript
await _fetch(auth_api.registerRequest)
```

ì—¬ê¸°ì„œ ì´ë¯¸ server ì—ì„œëŠ” login í•œ ì‚¬ìš©ìì˜ ì •ë³´ë¥¼ session ì— ì €ì¥í•˜ê³  ìˆê¸° ë•Œë¬¸ì—  
ë³„ë„ì˜ payload ì—†ì´ challenge ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ ìš”ì²­ì„ í•œë‹¤.  
ìƒì„±ëœ challenge ëŠ” ì„œë²„ì˜ session ì— ì €ì¥ë˜ê³ , í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡ëœë‹¤.

```rust
pub async fn handle_register_request(
    Extension(db): Extension<sea_orm::DatabaseConnection>,
    session: Session,
    request: Request,
) -> Result<Json<RespnseValue>, AppError> {
    if let Some(user) = request.extensions().get::<users::Model>() {
        let mut exclude_credentials: Vec<ExcludeCredentials> = vec![];
        if let Ok(credentials) = get_keys_by_user_id(&db, &user.id).await {
            credentials.iter().for_each(|cred| {
                let id_buffer = base64_url_decode(&cred.id).unwrap_or_else(|_| vec![]);
                exclude_credentials.push(ExcludeCredentials {
                    id: String::from_utf8(id_buffer).unwrap_or_else(|_| "".to_string()),
                    r#type: "public-key".to_string(),
                    transport: cred.transports.clone(),
                });
            });
        }

        let user_id = user.id.as_bytes().to_vec();

        let request_props = &json!({
            "rpName": "SimpleWebAuthn Example",
            "rpID": "localhost",
            "userID": &user_id,
            "userName": &user.username,
            "userDisplayName": &user.displayname,
            "attestationType": "none",
            "excludeCredentials": exclude_credentials,
            "authenticatorSelection": {
                "authenticatorAttachment": "platform",
                "requireResidentKey": true
            },
        });

        let resp = reqwest::Client::new()
            .post("http://localhost:3001/generate-options")
            .json(&request_props)
            .send()
            .await?;

        let json_resp = resp.json::<Value>().await?;

        session
            .insert(
                const_value::CHALLENGE_KEY,
                &json_resp.get(const_value::CHALLENGE_KEY),
            )
            .await?;

        Ok(Json(RespnseValue { data: json_resp }))
    } else {
        Err(user_not_found_error())
    }
}
```

ì •ìƒì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì „ì†¡ë°›ìœ¼ë©´ ì ˆì°¨ëŒ€ë¡œ Authenticator ì—ì„œ ì¸ì¦ì„ ì§„í–‰í•œë‹¤.  
ë‚œ í˜„ì¬ ë§¥ë¶ì—ì„œ ì§„í–‰í•˜ê¸° ë•Œë¬¸ì— TouchId ì¸ì¦ì´ ë‚˜ì˜¤ê²Œ ëœë‹¤.

![auth](./5.png)

```javascript
const cred = (await navigator.credentials.create({
      publicKey: options,
    })) as any;
```

ì´ë¶€ë¶„ì´ ì‹¤ì œ ìƒì²´ ì¸ì¦ìœ¼ë¡œ í‚¤ìŒì„ ë§Œë“œëŠ” ê³³ì´ë‹¤.

ì´ì œ ìœ„ ìˆœì„œëŒ€ë¡œ ì¸ì¦ì„ ë§ˆì¹˜ê²Œ ë˜ë©´ ê³µê°œí‚¤/ê°œì¸í‚¤ê°€ ìƒì„±ë˜ê³ ,  
ì „ë‹¬ë°›ì€ Challenge ë¥¼ ì„œëª…í•˜ê³  ë‹¤ì‹œ ì„œë²„ë¡œ ë³´ë‚¸ë‹¤.

```javascript
return await _fetch(auth_api.registerResponse, {
  payload: credential,
})
```

ì„œë²„ì—ì„œëŠ” ì´ì œ ì „ë‹¬ë°›ì€ ì¸ì¦ ì •ë³´ë¡œ ê²€ì¦í•˜ê²Œ ëœë‹¤.

```rust
 let expected_challenge = session
        .get::<String>(const_value::CHALLENGE_KEY)
        .await
        .unwrap();

  // example host
  let expected_origin = "http://localhost:5173";
  let expected_rp_id = "localhost";

  let request_post = &json!({
    "response": payload,
    "expectedChallenge": &expected_challenge,
    "expectedOrigin": &expected_origin,
    "expectedRPID": &expected_rp_id,
    "requireUserVerification": false,
  });

  let resp = reqwest::Client::new()
      .post("http://localhost:3001/verify-credentials")
      .json(&request_post)
      .send()
      .await?;
```

ì‹¤ì œë¡œ ê²€ì¦í•˜ëŠ”ê±´ Webauthn ì„ ì‹¤í–‰í•˜ëŠ” node_server ì´ë‹¤.

```rust
  if !json_resp.verified {
      return Err(AppError::new(
          "Verification failed".to_string(),
          StatusCode::UNAUTHORIZED,
      ));
  }

  let base64_credntial_public_key =
      base64_url_encode(&json_resp.registration_info.credential_public_key);
  let user_agent = user_agent_handler(&headers).await;
  let transports = payload
      .get("response")
      .and_then(|response| response.get("transports"))
      .and_then(|transports| transports.as_array())
      .ok_or(AppError::new(
          "transports error".to_string(),
          StatusCode::BAD_REQUEST,
      ))?;

  let transports_vec = transports
      .iter()
      .filter_map(|t| t.as_str().map(|s| s.to_string()))
      .collect();

  let new_credential = credentials::ActiveModel {
      id: Set(json_resp.registration_info.credential_id),
      publickey: Set(base64_credntial_public_key),
      user_id: Set(Some(user.id.clone())),
      transports: Set(transports_vec),
      name: Set(user_agent),
  };

  new_credential.insert(&db).await.map_err(|_| {
      AppError::new(
          "Failed to save credential".to_string(),
          StatusCode::INTERNAL_SERVER_ERROR,
      )
  })?;

  session.remove::<String>(const_value::CHALLENGE_KEY).await?;
  session.insert(const_value::SIGNED_IN_KEY, "yes").await?;

  Ok(Json(ResponseUser { data: user }))
```

ê²€ì¦ì— ì„±ê³µí•˜ê²Œ ë˜ë©´ DB ì— ì¸ì¦í‚¤ì™€ ê³µê°œí‚¤ ì •ë³´ ê·¸ì™¸ ì‚¬ìš©ì ì •ë³´ë¥¼ ì €ì¥í•˜ê³   
session ì—ì„œ Challenge ë¥¼ ì‚­ì œ í•˜ê²Œ ëœë‹¤.

í•˜ë©´ì„œ ê·€ì°®ì•˜ë˜(?)ì ì€ ê³ ë†ˆì˜ Serialize, Deserialize ì ˆì°¨ì™€  
base64 encode, decode ë‹¤.  
rust ê°€ ì—„ê²©í•œ íƒ€ì…ì„ ì‚¬ìš©í•˜ë‹¤ë³´ë‹ˆ ì´ê±° ë§ì¶”ëŠ”ë° ì• ë¥¼ ë¨¹ì—ˆë‹¤.

node_server ì—ì„œ ê²€ì¦ì„ ë°›ê³  ë‚˜ì˜¨ Json ë°ì´í„°ë¥¼ Deserialize í•´ì•¼ í•˜ëŠ”ë°  
Json íƒ€ì…ìœ¼ë¡œ ì–´ê±°ì§€ë¡œ í•˜ëŠ” ë°©ë²•ë„ ìˆì§€ë§Œ, ì‚¬ì‹¤ ê·¸ëŸ¬ë©´ íƒ€ì…ì•ˆì •ì„±ì´  
ì•ˆì¢‹ê³  ê²°ì •ì ìœ¼ë¡œ ë‚´ê°€ ë³´ê¸° ì•ˆì¢‹ë‹¤.ğŸ¤¡  
ë•Œë¬¸ì— ê²°êµ­ ì‘ë‹µ ê²°ê³¼ë¥¼ Rust ì—ì„œ ì‚¬ìš©ê°€ëŠ¥í•˜ë„ë¡ ë§Œë“¤ì—ˆë‹¤.

```rust
#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct RegistrationInfo {
    credential_id: String,

    #[serde(deserialize_with = "deserialize_public_key")]
    credential_public_key: Vec<u8>,
}

#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct RequestData {
    registration_info: RegistrationInfo,
    verified: bool,
}
```

í•´ë‹¹ ë°ì´í„° ëª¨ë¸ì„ ì“°ëŠ”ë° ì €ë„˜ì˜ public_key ê°€ ì•„ë§ˆ ArrayBuffer íƒ€ì…ì¸ë°  
íƒ€ì… ë§¤ì¹­ì´ ì•ˆë˜ì„œ Rust ì—ì„œ ë‹¤ì‹œ ë³€í™˜ì„ í•´ì¤¬ë‹¤.

```rust
fn deserialize_public_key<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>
where
    D: Deserializer<'de>,
{
    // `HashMap<String, u8>`ë¡œ ë°ì´í„°ë¥¼ ë°›ìŒ
    let map: HashMap<String, u8> = HashMap::deserialize(deserializer)?;

    // í‚¤ë¥¼ ìˆ«ìë¡œ ë³€í™˜í•˜ì—¬ ì •ë ¬í•˜ê³ , í•´ë‹¹ ê°’ì„ Vec<u8>ì— ì¶”ê°€
    let mut values: Vec<(usize, u8)> = map
        .into_iter()
        .filter_map(|(k, v)| k.parse::<usize>().ok().map(|i| (i, v)))
        .collect();

    values.sort_by_key(|&(k, _)| k);

    Ok(values.into_iter().map(|(_, v)| v).collect())
}
```

ì–´ì©„ë“  ê²€ì¦ì— ì„±ê³µí•˜ë©´

![home](./6.png)

ì´ë ‡ê²Œ ìƒˆë¡œìš´ íŒ¨ìŠ¤í‚¤ê°€ ë“±ë¡ë˜ì—ˆë‹¤.  
ì•ì— ìˆëŠ” `Macintosh` ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë””ë°”ì´ìŠ¤ ì •ë³´ë¥¼ ì „ë‹¬í• ë•Œ ê°™ì´ ì…ë ¥ë˜ê³   
ì´ë¦„ì„ ë§ˆìŒëŒ€ë¡œ ë³€ê²½ì´ ê°€ëŠ¥í•˜ë‹¤.

ì´ì œ ë¡œê·¸ì•„ì›ƒ í›„ input ì°½ì„ ë³´ë©´

![logout](./7.png)

![login](./8.png)

ì§  í•˜ê³  í˜„ì¬ ë“±ë¡í•œ íŒ¨ìŠ¤í‚¤ê°€ ë‹¤ ë³´ì¸ë‹¤.

ì˜†ì— ì í˜€ ìˆë“¯ì´ í•´ë‹¹ íŒ¨ìŠ¤í‚¤ì˜ ì •ë³´ë¥¼ `êµ¬ê¸€ ë¹„ë°€ë²ˆí˜¸ ê´€ë¦¬ì`ì— ì €ì¥ í–ˆê¸° ë•Œë¬¸ì—  
ì´ì œ êµ¬ê¸€ ì•„ì´ë””ë§Œ ìˆìœ¼ë©´ ì–´ë–¤ ë””ë°”ì´ìŠ¤ë“  í•´ë‹¹ ì‚¬ì´íŠ¸ë¥¼ ì ‘ì†í• ë•Œ  
íŒ¨ìŠ¤í‚¤ë¡œ ê°„ë‹¨íˆ ì¸ì¦ì´ ê°€ëŠ¥í•˜ë‹¤.

ë§¥ë¶ì˜ TouchId ë¿ë§Œ ì•„ë‹ˆë¼ ëª¨ë°”ì¼ì— í•´ë‹¹ êµ¬ê¸€ ì•„ì´ë””ê°€ ë¡œê·¸ì¸ ë˜ì–´ ìˆë‹¤ë©´  
`ë³„ë„ì˜ ë“±ë¡ì—†ì´ ëª¨ë°”ì¼ì˜ ìƒì²´ ì¸ì¦` ìœ¼ë¡œë„ ê°€ëŠ¥í•˜ë‹¤.  
í¸í•˜ê¸´ ì •ë§ í¸í•˜ë‹¤.  
ê·¸ë¦¬ê³  ìŠ¤ë§ˆíŠ¸ í•˜ë‹¤.

ìœ„ì— ì ì—ˆë“¯ì´ í˜„ì¬ëŠ” ë„ì…í•œ ê³³ì´ ë§ì´ ì—†ì–´ì„œ ë¬¸ì œì§€ë§Œ  
ì‹¤ì œë¡œ ë§Œë“œëŠ” ì ˆì°¨ ìì²´ëŠ” ê·¸ë¦¬ ì–´ë µì§€ ì•Šë‹¤.

ì´ë¯¸ API ê°€ ë‹¤ ì¡´ì¬í•˜ê³ , ê°„ë‹¨í•˜ê²Œ íŒ¨ìŠ¤í‚¤ë¥¼ ë„ì…í•˜ê²Œ í•´ì£¼ëŠ” ì„œë¹„ìŠ¤ë„  
ë§ì€ ê±¸ë¡œ ì•ˆë‹¤.

ì²˜ìŒ ì‹¤ì„œë¹„ìŠ¤ì— ì ìš©í• ë•ŒëŠ” íŒ¨ìŠ¤ì›Œë“œ ë¡œê·¸ì¸ê³¼ íŒ¨ìŠ¤í‚¤ ë‘˜ë‹¤ ê°™ì´ ì œê³µí•˜ë©´ì„œ  
ì ì§„ì ìœ¼ë¡œ ë³€í™˜ì„ í•˜ë©´ ë  ê²ƒ ê°™ë‹¤.

ì½”ë“œ ì„¤ëª…ì´ ì¡°ê¸ˆ ë¹ˆì•½í•œë° ë‹¤ ì„¤ëª…í•˜ë ¤ë‹ˆ ë„ˆë¬´ ë§ì•„ì„œ  
ë” ê¶ê¸ˆí•˜ë‹¤ë©´ ì½”ë“œë¡œ ì˜ˆì œë¥¼ ì‹¤í–‰í•´ë³´ê³  ì‚´í´ë³´ê¸¸ ë°”ë€ë‹¤.  
ì•„ë‹ˆë©´ êµ¬ê¸€ì˜ [Passkey example](https://developers.google.com/codelabs/passkey-form-autofill?hl=ko#0) ì„ ì‚´í´ë³´ì.

ë‚´ê°€ ë§Œë“  ì½”ë“œì—­ì‹œ í•´ë‹¹ ì½”ë“œë¥¼ ì°¸ê³  í–ˆìœ¼ë©°, ì„œë²„ë¥¼ Rustë¡œ ë³€ê²½í•˜ê³   
ë””ìì¸ì„ ë°”ê¾¸ê³ , í´ë¼ì´ì–¸íŠ¸ë¥¼ Remix ë¡œ ë³€ê²½í•˜ë©´ì„œ ì´ê²ƒì €ê²ƒ ì¡°ê¸ˆë” ì¶”ê°€í•˜ê³   
í–ˆì„ ë¿ì´ë‹¤.  
ê±°ì˜ ì‹¹ ê°ˆì•„ ì—ê¸´ í–ˆë‹¤. ğŸ¤¡

## ë

ë‹¤ìŒì€ ë­˜ ë§Œë“¤ê¹Œ í•˜ë‹¤ê°€ ì‹¤ì œë¡œ ì§„í–‰í•˜ëŠ” ì‚¬ì´ë“œ í”„ë¡œì íŠ¸ ì™¸ Rust ë¡œ  
Tailwind ê´€ë ¨ Parser ë¥¼ ë§Œë“¤ì–´ ë³¼ ì˜ˆì •ì´ë‹¤.
